'From Pharo2.0 of 7 March 2013 [Latest update: #20619] on 12 February 2015 at 8:20:01 am'!PPCompoGrammar subclass: #PPCompoParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Parser-Core'!!PPCompoParser commentStamp: 'lr 11/29/2009 09:58' prior: 0!Enhances the Smalltalk grammar with production actions to build parse-tree nodes of the refactoring browser.!!PPCompoParser methodsFor: 'private' stamp: 'PetrSpacek 11/11/2013 18:42'!addComments: aCollectionOfIntervals toNode: aNode	(aCollectionOfIntervals isNil or: [ aCollectionOfIntervals isEmpty ])		ifFalse: [ aNode comments: aNode comments , aCollectionOfIntervals ]! !!PPCompoParser methodsFor: 'private' stamp: 'PetrSpacek 11/11/2013 18:42'!addStatements: aCollection into: aNode	aCollection isNil 		ifTrue: [ ^ aNode ].	aCollection do: [ :each |		each class == PPCompoToken			ifFalse: [ aNode addNode:  each ]			ifTrue: [				aNode statements isEmpty					ifTrue: [ self addComments: each comments toNode: aNode ]					ifFalse: [ self addComments: each comments toNode: (aNode statements last) ].				aNode periods: (aNode periods asOrderedCollection					addLast: each start;					yourself) ] ].	^ aNode! !!PPCompoParser methodsFor: 'private' stamp: 'TestRunner 11/5/2009 10:36'!build: aNode assignment: anArray	^ anArray isEmpty		ifTrue: [ aNode ]		ifFalse: [			anArray reverse 				inject: aNode				into: [ :result :each |					RBAssignmentNode 						variable: each first						value: result						position: each second start ] ]! !!PPCompoParser methodsFor: 'private' stamp: 'lr 9/11/2010 10:11'!build: aNode cascade: anArray 	| messages semicolons |	^ (anArray isNil or: [ anArray isEmpty ]) 		ifTrue: [ aNode ]		ifFalse: [			messages := OrderedCollection new: anArray size + 1.			messages addLast: aNode.			semicolons := OrderedCollection new.			anArray do: [ :each | 				messages addLast: (self 					build: aNode receiver					messages: (Array with: each second)).				semicolons addLast: each first start ].			RBCascadeNode messages: messages semicolons: semicolons ]! !!PPCompoParser methodsFor: 'private' stamp: 'PetrSpacek 10/19/2012 15:20'!build: aNode messages: anArray 	^ (anArray isNil or: [ anArray isEmpty ]) 		ifTrue: [ aNode ]		ifFalse: [			anArray 				inject: aNode				into: [ :rec :msg | 					msg isNil 						ifTrue: [ rec ]						ifFalse: [							RBMessageNode 								receiver: rec								selectorParts: msg first								arguments: msg second ] ] ]! !!PPCompoParser methodsFor: 'private' stamp: 'lr 8/14/2011 12:03'!build: aTempCollection sequence: aStatementCollection	| result |	result := self		addStatements: aStatementCollection		into: RBSequenceNode new.	aTempCollection isEmpty ifFalse: [		result			leftBar: aTempCollection first start			temporaries: aTempCollection second			rightBar: aTempCollection last start ].	^ result! !!PPCompoParser methodsFor: 'private' stamp: 'FerrandAnthony 2/11/2015 11:18'!build: aNode serviceInvocation: anArray 	^ (anArray isNil or: [ anArray isEmpty ]) 		ifTrue: [ aNode ]		ifFalse: [			|inst ar|			inst := aNode.			anArray do: [:e |				inst := CompoServiceInvocationNode  					receiver: inst					selector: e first					arguments: e second.				"(inst receiver isKindOf: (Smalltalk at: #CompoParseNode))					ifTrue: [ inst receiver parent: inst ]."				inst receiver parent: inst.			].						"return inst"			inst.		].! !!PPCompoParser methodsFor: 'private' stamp: 'PetrSpacek 11/13/2012 22:10'!build: aNode serviceInvocationBase: anArray 	^ (anArray isNil or: [ anArray isEmpty ]) 		ifTrue: [ aNode ]		ifFalse: [			|inst|			inst := CompoServiceInvocationNode  					receiver: aNode					selector: anArray first					arguments: anArray second.			(aNode isKindOf: (Smalltalk at: #CompoParseNode))				ifTrue: [ aNode parent: inst ].			"return inst"			inst.		].! !!PPCompoParser methodsFor: 'private' stamp: 'FerrandAnthony 2/6/2015 14:34'!buildArchitecture: nodes	|inst conns disconns|		conns := (nodes at: 3).	disconns := nil.	conns ifNotNil: [		disconns := conns select: [:c | (c isKindOf: (Smalltalk at: #CompoDisconnectionNode)) ].		conns := conns select: [:c | (c isKindOf: (Smalltalk at: #CompoConnectionNode)) | (c isKindOf: (Smalltalk at: #CompoConnectionRockNode)) ].	].		inst := CompoArchitectureNode new			disconns: disconns ;			conns: conns ;			yourself.				conns ifNotNil: [conns do: [:c | c parent: inst]].	disconns ifNotNil: [disconns do: [:c | c parent: inst]].				^inst.		! !!PPCompoParser methodsFor: 'private' stamp: 'lr 8/14/2011 12:00'!buildArray: aStatementCollection	^ self addStatements: aStatementCollection into: RBArrayNode new! !!PPCompoParser methodsFor: 'private' stamp: 'PetrSpacek 11/7/2012 20:09'!buildCollectionPort: nodes	|inst name expr|	name := nodes at: 1.	expr := nodes at: 3.		inst := CompoCollectionPortLiteralNode new				portName: name;				indexExpr: expr;				yourself.					(expr isKindOf: (Smalltalk at: #CompoParseNode))		ifTrue: [ expr parent: inst ].				^ inst.		! !!PPCompoParser methodsFor: 'private' stamp: 'FerrandAnthony 2/1/2015 13:57'!buildConnection: nodes	|inst src dest|	src := nodes at: 2.	dest := nodes at: 4.		inst := CompoConnectionNode new		srcAddress: src;		destAddress: dest;		kind: ((nodes at: 5) isNil ifTrue: [nil] ifFalse:[ (nodes at: 5) at: 2 ]) ;		yourself.			^ inst.! !!PPCompoParser methodsFor: 'private' stamp: 'PetrSpacek 11/8/2012 13:24'!buildDeferenceLiteral: nodes	^ CompoDereferenceLiteralNode new		literal: (nodes at: 2);		applicationsCount: (nodes at: 1) size;		yourself.! !!PPCompoParser methodsFor: 'private' stamp: 'PetrSpacek 11/11/2013 21:25'!buildDescriptor: nodes	|body inst|	body := nodes at: 5.	inst := CompoDescriptorNode named: (nodes at: 2) metadesc: (nodes at: 1) extends: ((nodes at: 3) ifNotNil: [(nodes at: 3) second]) body: (body) source: (nodes first collection copy).	body ifNotNil: [ body do: [:node | node parent: inst]].	^ inst.! !!PPCompoParser methodsFor: 'private' stamp: 'PetrSpacek 11/7/2012 18:56'!buildDisconnection: nodes	|inst src dest|	src := nodes at: 2.	dest := nodes at: 4.		inst := CompoDisconnectionNode new		srcAddress: src;		destAddress: dest;		kind: nil ;		yourself.			^ inst.! !!PPCompoParser methodsFor: 'private' stamp: 'PetrSpacek 11/7/2012 16:59'!buildExProvisions: nodes	|body inst|	body := nodes at: 4.	inst := CompoExProvisionsNode new ports: body.	body do: [:node | node parent: inst].	^ inst.! !!PPCompoParser methodsFor: 'private' stamp: 'PetrSpacek 11/7/2012 16:58'!buildExRequirements: nodes	|body inst|	body := nodes at: 4.	inst := CompoExRequirementsNode new ports: body.	body do: [:node | node parent: inst].	^ inst.! !!PPCompoParser methodsFor: 'private' stamp: 'PetrSpacek 11/18/2013 17:18'!buildFor: nodes	|inst cond seed inc body|	seed := (nodes at: 3).	cond := (nodes at: 5).	inc := (nodes at: 7).	body := (nodes at: 10).		inst := CompoForNode new			condition: cond;			seed: seed;			incrementation: inc;			body: body;			yourself.		cond parent: inst.	^inst.! !!PPCompoParser methodsFor: 'private' stamp: 'PetrSpacek 11/18/2013 17:23'!buildIf: nodes	|inst cond ifBody elseBody|	cond := (nodes at: 2).	ifBody := (nodes at: 4).	elseBody := (nodes at: 6).	elseBody ifNotNil: [ elseBody := (elseBody at: 3) ].		inst := CompoIfNode new			condition: cond;			ifBody: ifBody;			elseBody: elseBody;			yourself.		cond parent: inst.	^inst.! !!PPCompoParser methodsFor: 'private' stamp: 'PetrSpacek 11/7/2012 16:57'!buildInProvisions: nodes	|body inst|	body := nodes at: 4.	inst := CompoInProvisionsNode new ports: body.	body do: [:node | node parent: inst].	^ inst.! !!PPCompoParser methodsFor: 'private' stamp: 'PetrSpacek 11/7/2012 17:00'!buildInRequirements: nodes	|ar inst|	ar := nodes at: 4.	"internal requirements can be injected, therefore we have to setup injection, which is optionaly given in second position of each element of [nodes at: 4]"	(ar isNil)		ifTrue: [ ar := nil]		ifFalse: [			ar := ar collect: [:e | ((e at: 2) isNil) ifTrue: [ (e at: 1) yourself ] ifFalse: [ (e at: 1) pInjection: ((e at: 2) at: 2); yourself ]]		].		inst := CompoInRequirementsNode new ports: ar.	ar do: [:node | node parent: inst].	^ inst.! !!PPCompoParser methodsFor: 'private' stamp: 'PetrSpacek 11/7/2012 18:29'!buildInterface: nodes	|body inst|	body := (nodes at: 4) at: 2.	inst := CompoInterfaceNode named: (nodes at: 2) extends: ((nodes at: 3) ifNotNil: [(nodes at: 3) second]) body: (body) source: (nodes first collection copy).	body ifNotNil: [body do: [:node | node parent: inst]].	^ inst.! !!PPCompoParser methodsFor: 'private' stamp: 'lr 3/1/2010 10:51'!buildMethod: aMethodNode	aMethodNode selectorParts 		do: [ :each | aMethodNode addComments: each comments ].	aMethodNode arguments		do: [ :each | aMethodNode addComments: each token comments ].	aMethodNode pragmas do: [ :pragma |		aMethodNode addComments: pragma comments.		pragma selectorParts 			do: [ :each | aMethodNode addComments: each comments ].		pragma arguments do: [ :each | 			each isLiteralArray				ifFalse: [ aMethodNode addComments: each token comments ] ].		pragma comments: nil ].	^ aMethodNode! !!PPCompoParser methodsFor: 'private' stamp: 'FerrandAnthony 2/11/2015 11:03'!buildPort: nodes	|inst interf|	interf := (nodes at: 4).	(interf isKindOf: (Smalltalk at: #Collection))		ifTrue: [interf := interf second].			"(((nodes at: 1) isNil not) and: [(nodes at: 5) isNil not])		ifTrue: [ self error: 'Port  ' , (nodes at: 1) value asString , ' is declared as atomic, kind-of clause cannot be used!!'].	"		inst := CompoPortNode new		pName: (nodes at: 1);		pInterface: (interf);		pKind: ( (nodes at: 5) isNil ifTrue: [nil] ifFalse: [ (nodes at: 5) at: 2 ] ) ;		pIsCollectionPort: ( (nodes at: 2) isNil ifTrue: [false] ifFalse: [true] ) ;		pInjection: nil;		yourself.		(interf isKindOf: (Smalltalk at: #Collection))		ifTrue: [interf do: [:sign | sign parent: inst]].		^ inst.! !!PPCompoParser methodsFor: 'private' stamp: 'FerrandAnthony 2/11/2015 11:04'!buildPortAddress: nodes	|inst right|	right := nodes at: 3.		(right isKindOf: (Smalltalk at: #Collection))		ifTrue: [ right := right at: 2].	inst := CompoPortAddressNode new				left: (nodes at: 1) ;				right: right;				yourself.					(right isKindOf: (Smalltalk at: #CompoParseNode))		ifTrue: [ right parent: inst ].		^inst.! !!PPCompoParser methodsFor: 'private' stamp: 'PetrSpacek 11/8/2012 13:48'!buildService: nodes	|inst sign body|	sign := (nodes at: 2).	body := (nodes at: 4).		inst := CompoServiceNode new			signature: sign;			body: body;			bodyStart: (((nodes at: 3) stop) + 1);			bodyEnd: (((nodes at: 5) start) - 1 );			yourself.		sign parent: inst.		^ inst.! !!PPCompoParser methodsFor: 'private' stamp: 'PetrSpacek 11/7/2012 18:17'!buildServiceSign: nodes	^ CompoServiceSignNode new		selector: (nodes at: 1);		arguments: (nodes at: 3);		yourself.! !!PPCompoParser methodsFor: 'private' stamp: 'lr 8/14/2011 12:25'!buildString: aString 	(aString isEmpty or: [ aString first ~= $' or: [ aString last ~= $' ] ])		ifTrue: [ ^ aString ].	^ (aString 		copyFrom: 2		to: aString size - 1) 		copyReplaceAll: ''''''		with: ''''! !!PPCompoParser methodsFor: 'private' stamp: 'PetrSpacek 11/18/2013 17:21'!buildWhile: nodes	|inst cond body|	cond := (nodes at: 2).	body := (nodes at: 4).		inst := CompoWhileNode new			condition: cond;			body: body;			yourself.		cond parent: inst.	^inst.! !!PPCompoParser methodsFor: 'grammar' stamp: 'lr 8/14/2011 11:51'!array	^ super array map: [ :openNode :statementNodes :closeNode |		(self buildArray: statementNodes)			left: openNode start;			right: closeNode start;			yourself ]! !!PPCompoParser methodsFor: 'grammar' stamp: 'lr 12/6/2009 10:40'!expression	^ super expression map: [ :variableNodes :expressionNodes | self build: expressionNodes assignment: variableNodes ]! !!PPCompoParser methodsFor: 'grammar' stamp: 'PetrSpacek 11/11/2013 18:17'!forStatement	^ super forStatement ==> [:nodes | self buildFor: nodes]! !!PPCompoParser methodsFor: 'grammar' stamp: 'PetrSpacek 11/11/2013 18:18'!ifStatement		^ super ifStatement ==> [:nodes | self buildIf: nodes]! !!PPCompoParser methodsFor: 'grammar' stamp: 'lr 8/13/2011 21:09'!method	^ super method map: [ :methodNode :bodyNode | 		methodNode pragmas: bodyNode first.		methodNode body: bodyNode second.		self buildMethod: methodNode ]! !!PPCompoParser methodsFor: 'grammar' stamp: 'lr 3/1/2010 10:27'!methodDeclaration	^ super methodDeclaration ==> [ :nodes |		RBMethodNode 			selectorParts: nodes first			arguments: nodes second ]! !!PPCompoParser methodsFor: 'grammar' stamp: 'lr 8/14/2011 11:24'!methodSequence	^ super methodSequence map: [ :periodNodes1 :pragmaNodes1 :periodNodes2 :tempNodes :periodNodes3 :pragmaNodes2 :periodNodes4 :statementNodes |		Array			with: pragmaNodes1 , pragmaNodes2			with: (self build: tempNodes sequence: periodNodes1 , periodNodes2 , periodNodes3 , periodNodes4 , statementNodes) ]! !!PPCompoParser methodsFor: 'grammar' stamp: 'lr 12/6/2009 10:42'!parens	^ super parens map: [ :openToken :expressionNode :closeToken | expressionNode addParenthesis: (openToken start to: closeToken start) ]! !!PPCompoParser methodsFor: 'grammar' stamp: 'FerrandAnthony 2/11/2015 20:34'!pragma	^ super pragma ==> [ :nodes |		|inst|		inst := (RBPragmaNode selectorParts: nodes third first arguments: nodes third second).				self addComments: (nodes first comments) toNode: inst.		self addComments: (nodes last comments) toNode: inst.		inst			left: nodes first start;			right: nodes last start.		inst. ]! !!PPCompoParser methodsFor: 'grammar' stamp: 'lr 12/6/2009 10:42'!return	^ super return map: [ :token :expressionNode | RBReturnNode return: token start value: expressionNode ]! !!PPCompoParser methodsFor: 'grammar' stamp: 'lr 8/14/2011 11:14'!sequence	^ super sequence map: [ :tempNodes :periodNodes :statementNodes | self build: tempNodes sequence: periodNodes , statementNodes ]! !!PPCompoParser methodsFor: 'grammar' stamp: 'FerrandAnthony 2/11/2015 15:21'!variable	^ super variable ==> [ :token | CompoRBVariableNode identifierToken: token ]! !!PPCompoParser methodsFor: 'grammar' stamp: 'PetrSpacek 11/11/2013 18:25'!whileStatement	^ super whileStatement ==> [:nodes | self buildWhile: nodes]! !!PPCompoParser methodsFor: 'grammar-literals' stamp: 'TestRunner 11/5/2009 11:41'!arrayLiteral	^ super arrayLiteral ==> [ :nodes | RBLiteralArrayNode startPosition: nodes first start contents: nodes second stopPosition: nodes last start isByteArray: false ]! !!PPCompoParser methodsFor: 'grammar-literals' stamp: 'TestRunner 11/5/2009 11:41'!arrayLiteralArray	^ super arrayLiteralArray ==> [ :nodes | RBLiteralArrayNode startPosition: nodes first start contents: nodes second stopPosition: nodes last start isByteArray: false ]! !!PPCompoParser methodsFor: 'grammar-literals' stamp: 'TestRunner 11/5/2009 11:41'!byteLiteral	^ super byteLiteral ==> [ :nodes | RBLiteralArrayNode startPosition: nodes first start contents: nodes second stopPosition: nodes last start isByteArray: true ]! !!PPCompoParser methodsFor: 'grammar-literals' stamp: 'TestRunner 11/5/2009 11:41'!byteLiteralArray	^ super byteLiteralArray ==> [ :nodes | RBLiteralArrayNode startPosition: nodes first start contents: nodes second stopPosition: nodes last start isByteArray: true ]! !!PPCompoParser methodsFor: 'grammar-literals' stamp: 'TestRunner 11/5/2009 11:28'!charLiteral	^ super charLiteral ==> [ :token | RBLiteralValueNode literalToken: (RBLiteralToken value: token value second start: token start stop: token stop) ]! !!PPCompoParser methodsFor: 'grammar-literals' stamp: 'TestRunner 11/5/2009 11:29'!falseLiteral	^ super falseLiteral ==> [ :token | RBLiteralValueNode literalToken: (RBLiteralToken value: false start: token start stop: token stop) ]! !!PPCompoParser methodsFor: 'grammar-literals' stamp: 'TestRunner 11/5/2009 11:29'!nilLiteral	^ super nilLiteral ==> [ :token | RBLiteralValueNode literalToken: (RBLiteralToken value: nil start: token start stop: token stop) ]! !!PPCompoParser methodsFor: 'grammar-literals' stamp: 'TestRunner 11/5/2009 13:33'!numberLiteral	^ super numberLiteral ==> [ :token | RBLiteralValueNode literalToken: (RBNumberLiteralToken value: (Number readFrom: token value) start: token start stop: token stop source: token value) ]! !!PPCompoParser methodsFor: 'grammar-literals' stamp: 'TestRunner 11/5/2009 11:30'!stringLiteral	^ super stringLiteral ==> [ :token | RBLiteralValueNode literalToken: (RBLiteralToken value: (self buildString: token value) start: token start stop: token stop) ]! !!PPCompoParser methodsFor: 'grammar-literals' stamp: 'lr 8/14/2011 12:24'!symbolLiteral	^ super symbolLiteral ==> [ :tokens | RBLiteralValueNode literalToken: (RBLiteralToken value: (self buildString: tokens last value) asSymbol start: tokens first start stop: tokens last stop) ]! !!PPCompoParser methodsFor: 'grammar-literals' stamp: 'TestRunner 11/5/2009 11:45'!symbolLiteralArray	^ super symbolLiteralArray ==> [ :token | RBLiteralValueNode literalToken: (RBLiteralToken value: (self buildString: token value) asSymbol start: token start stop: token stop) ]! !!PPCompoParser methodsFor: 'grammar-literals' stamp: 'TestRunner 11/5/2009 11:29'!trueLiteral	^ super trueLiteral ==> [ :token | RBLiteralValueNode literalToken: (RBLiteralToken value: true start: token start stop: token stop) ]! !!PPCompoParser methodsFor: 'grammar-literals-compo' stamp: 'PetrSpacek 11/7/2012 19:21'!collectionPortLiteral	^ super collectionPortLiteral ==> [ :nodes | self buildCollectionPort: nodes ]! !!PPCompoParser methodsFor: 'grammar-literals-compo' stamp: 'PetrSpacek 11/8/2012 13:23'!dereferenceLiteral	^ super dereferenceLiteral ==> [ :nodes | self buildDeferenceLiteral: nodes ]! !!PPCompoParser methodsFor: 'grammar-literals-compo' stamp: 'PetrSpacek 11/7/2012 19:13'!portAddressLiteral	^ super portAddressLiteral  ==> [ :nodes | self buildPortAddress: nodes ]! !!PPCompoParser methodsFor: 'grammar-messages' stamp: 'lr 12/6/2009 10:39'!binaryExpression	^ super binaryExpression map: [ :receiverNode :messageNodes | self build: receiverNode messages: messageNodes ]! !!PPCompoParser methodsFor: 'grammar-messages' stamp: 'PetrSpacek 10/19/2012 15:15'!binaryExpressionLimited	^ super binaryExpressionLimited map: [ :receiverNode :messageNodes | self build: receiverNode messages: messageNodes ]! !!PPCompoParser methodsFor: 'grammar-messages' stamp: 'PetrSpacek 10/19/2012 15:09'!cascadeExpression	"^ super cascadeExpression map: [ :receiverNode :messageNodes | self build: receiverNode cascade: messageNodes ]"	^ super cascadeExpression map: [ :receiverNode  | self build: receiverNode cascade: nil ]! !!PPCompoParser methodsFor: 'grammar-messages' stamp: 'PetrSpacek 10/19/2012 15:09'!keywordExpression	"^ super keywordExpression map: [ :receiveNode :messageNode | self build: receiveNode messages: (Array with: messageNode) ]"	^ super keywordExpression map: [ :receiveNode  | self build: receiveNode messages: nil ]! !!PPCompoParser methodsFor: 'grammar-messages' stamp: 'PetrSpacek 11/13/2012 22:06'!unaryExpression	^ super unaryExpression ==> [:nodes |  self build: (nodes first) serviceInvocation: (nodes second)]! !!PPCompoParser methodsFor: 'grammar-messages' stamp: 'PetrSpacek 11/13/2012 22:10'!unarySubExpression	^ super unarySubExpression ==> [ :nodes | self build: (nodes at: 1) serviceInvocationBase: (nodes at: 2)]! !!PPCompoParser methodsFor: 'grammar-compo' stamp: 'PetrSpacek 11/7/2012 19:01'!architecture
	^ super architecture ==> [:nodes | self buildArchitecture: nodes]! !!PPCompoParser methodsFor: 'grammar-compo' stamp: 'PetrSpacek 10/19/2012 16:13'!compoExpr
	^ super compoExpr! !!PPCompoParser methodsFor: 'grammar-compo' stamp: 'PetrSpacek 10/19/2012 16:13'!compoIdent
	^ super compoIdent! !!PPCompoParser methodsFor: 'grammar-compo' stamp: 'PetrSpacek 11/7/2012 18:42'!connection
	^ super connection ==> [:nodes | self buildConnection: nodes]! !!PPCompoParser methodsFor: 'grammar-compo' stamp: 'PetrSpacek 10/19/2012 16:13'!constraint
	^ super constraint! !!PPCompoParser methodsFor: 'grammar-compo' stamp: 'PetrSpacek 10/19/2012 23:23'!descriptor
	^ super descriptor ==> [:nodes | self buildDescriptor: nodes ]! !!PPCompoParser methodsFor: 'grammar-compo' stamp: 'PetrSpacek 11/7/2012 18:42'!disconnection
	^ super disconnection ==> [:nodes | self buildDisconnection: nodes]! !!PPCompoParser methodsFor: 'grammar-compo' stamp: 'PetrSpacek 11/7/2012 15:34'!exProvisions
	^ super exProvisions ==> [:nodes | self buildExProvisions: nodes]! !!PPCompoParser methodsFor: 'grammar-compo' stamp: 'PetrSpacek 11/7/2012 15:38'!exRequirements
	^ super exRequirements ==> [:nodes | self buildExRequirements: nodes]! !!PPCompoParser methodsFor: 'grammar-compo' stamp: 'PetrSpacek 11/7/2012 15:38'!inProvisions
	^ super inProvisions ==> [:nodes | self buildInProvisions: nodes]! !!PPCompoParser methodsFor: 'grammar-compo' stamp: 'PetrSpacek 11/7/2012 15:38'!inRequirements
	^ super inRequirements ==> [:nodes | self buildInRequirements: nodes]! !!PPCompoParser methodsFor: 'grammar-compo' stamp: 'PetrSpacek 11/7/2012 18:23'!interface
	^ super interface ==> [:nodes | self buildInterface: nodes]! !!PPCompoParser methodsFor: 'grammar-compo' stamp: 'PetrSpacek 11/7/2012 15:49'!port
	^ super port ==> [:nodes | self buildPort: nodes]! !!PPCompoParser methodsFor: 'grammar-compo' stamp: 'PetrSpacek 11/8/2012 13:33'!service
	^ super service ==> [:nodes | self buildService: nodes]! !!PPCompoParser methodsFor: 'grammar-compo' stamp: 'PetrSpacek 11/7/2012 18:12'!serviceSign
	^ super serviceSign ==> [:nodes | self buildServiceSign: nodes]! !!PPCompoParser methodsFor: 'grammar-compo' stamp: 'PetrSpacek 10/19/2012 16:13'!serviceSignsList
	^ super serviceSignsList! !!PPCompoParser methodsFor: 'grammar-blocks' stamp: 'lr 12/6/2009 10:37'!block	^ super block map: [ :leftToken :blockNode :rightToken | blockNode left: leftToken start; right: rightToken start ]! !!PPCompoParser methodsFor: 'grammar-blocks' stamp: 'lr 9/27/2009 12:42'!blockArgument	^ super blockArgument ==> #second! !!PPCompoParser methodsFor: 'grammar-blocks' stamp: 'lr 2/4/2010 11:42'!blockBody	^ super blockBody ==> [ :nodes | 		| result |		result := RBBlockNode arguments: nodes first first body: nodes last.		nodes first last isNil			ifFalse: [ result bar: nodes first last start ].		result ]! !!PPCompoParser methodsFor: 'accessing' stamp: 'PetrSpacek 10/19/2012 16:26'!startDeclaration	"Make the sequence node has a method node as its parent and that the source is set."	^ ([ :stream | stream collection ] asParser and , super startDeclaration) map: [ :source :node | 	    "build node here".	    node. ]! !!PPCompoParser methodsFor: 'accessing' stamp: 'lr 2/19/2010 08:07'!startExpression	"Make the sequence node has a method node as its parent and that the source is set."	^ ([ :stream | stream collection ] asParser and , super startExpression) map: [ :source :node | 		(RBMethodNode selector: #doIt body: node)			source: source.		(node statements size = 1 and: [ node temporaries isEmpty ])			ifTrue: [ node statements first ]			ifFalse: [ node ] ]! !!PPCompoParser methodsFor: 'accessing' stamp: 'lr 2/19/2010 08:20'!startMethod	"Make sure the method node has the source code properly set."		^ ([ :stream | stream collection ] asParser and , super startMethod)		map: [ :source :node | node source: source ]! !!PPCompoParser methodsFor: 'as yet unclassified' stamp: 'FerrandAnthony 2/5/2015 13:38'!buildConnection_rock: nodes	|inst src dest|	src := nodes at: 2.	dest := nodes at: 4.		inst := CompoConnectionRockNode new		srcAddress: src;		destAddress: dest;		kind: nil ;		yourself.			^ inst.! !!PPCompoParser methodsFor: 'as yet unclassified' stamp: 'FerrandAnthony 2/1/2015 13:37'!connection_rock	^ super connection_rock ==> [:nodes | self buildConnection_rock: nodes]! !!PPCompoParser methodsFor: 'as yet unclassified' stamp: 'FerrandAnthony 2/11/2015 22:28'!smalltalkInjection	^ super smalltalkInjection  ==> [ :nodes |		|inst code|				inst := CompoSmalltalkInjectionNode new.		code := ''.				(nodes second) do: [ :item |			(item = '>!!')				ifTrue: [ code := code , '>'. ]				ifFalse: [ code := code , (item asString). ] 		].			inst code: code.		inst. ]! !