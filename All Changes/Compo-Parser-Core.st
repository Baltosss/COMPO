PPTokenParser subclass: #PPCompoTokenParser	instanceVariableNames: ''	classVariableNames: 'SeparatorPredicate'	poolDictionaries: ''	category: 'Compo-Parser-Core'!!PPCompoTokenParser commentStamp: 'lr 11/29/2009 09:59' prior: 0!A parser that knows how to skip comments and whitespace in Smalltalk and how to instantiate tokens.!!PPCompoTokenParser methodsFor: 'private' stamp: 'PetrSpacek 10/17/2012 15:20'!defaultTokenClass	^ PPCompoToken! !!PPCompoTokenParser methodsFor: 'parsing' stamp: 'lr 10/5/2010 16:30'!parseComments: anArray on: aStream	| start comments |	comments := anArray.	[ [ aStream atEnd not and: [ SeparatorPredicate value: aStream uncheckedPeek ] ]		whileTrue: [ aStream next ].	 aStream atEnd not and: [ aStream uncheckedPeek = $" ] ] whileTrue: [		aStream next.		start := aStream position.		aStream upTo: $".		comments := comments copyWith: (start to: aStream position) ].	^ comments! !!PPCompoTokenParser methodsFor: 'parsing' stamp: 'lr 4/6/2010 20:12'!parseOn: aStream	| start comments token |	start := aStream position.	comments := self		parseComments: #()		on: aStream.	token := super parseOn: aStream.	token isPetitFailure ifTrue: [		aStream position: start.		^ token ].	comments := self		parseComments: comments		on: aStream.	^ token comments: comments! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PPCompoTokenParser class	instanceVariableNames: ''!!PPCompoTokenParser class methodsFor: 'initialization' stamp: 'lr 9/5/2010 23:42'!initialize	SeparatorPredicate := PPCharSetPredicate on: [ :char | char isSeparator ]! !PPToken subclass: #PPCompoToken	instanceVariableNames: 'comments'	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Parser-Core'!!PPCompoToken methodsFor: 'accessing' stamp: 'lr 12/7/2009 09:30'!comments	^ comments! !!PPCompoToken methodsFor: 'accessing' stamp: 'lr 12/7/2009 09:30'!comments: anArray	comments := anArray! !!PPCompoToken methodsFor: 'accessing' stamp: 'PetrSpacek 11/24/2013 22:53'!isValue	^ false.! !!PPCompoToken methodsFor: 'accessing' stamp: 'PetrSpacek 11/11/2013 18:34'!value	^ self inputValue! !!PPCompoToken methodsFor: 'compatiblity' stamp: 'lr 2/14/2010 11:58'!length	^ self size! !PPCompositeParser subclass: #PPCompoGrammar	instanceVariableNames: 'array arrayItem arrayLiteral arrayLiteralArray assignment assignmentToken binary binaryExpression binaryMessage binaryMethod binaryPragma binaryToken block blockArgument blockArguments blockArgumentsWith blockArgumentsWithout blockBody byteLiteral byteLiteralArray cascadeExpression cascadeMessage char charLiteral charToken expression falseLiteral falseToken identifier identifierToken keyword keywordExpression keywordMessage keywordMethod keywordPragma keywordToken literal message method methodDeclaration methodSequence multiword nilLiteral nilToken number numberLiteral numberToken parens period periodToken pragma pragmaMessage pragmas primary return sequence startExpression startMethod statements string stringLiteral stringToken symbol symbolLiteral symbolLiteralArray temporaries trueLiteral trueToken unary unaryExpression unaryMessage unaryMethod unaryPragma unaryToken variable dereferenceLiteral collectionPortLiteral portAddressLiteral selfAddressLiteral compoIdent serviceSignsList serviceSign port connection connectionAlt disconnection rockConnection rockConnectionAlt exProvisions exRequirements inProvisions inRequirements service architecture compoExpr descriptor interface semicolon semicolonToken comma commaToken constraint binaryMessageLimited binaryTokenLimited binaryExpressionLimited binaryLimited startDeclaration startConnection unarySubExpression startService forStatement whileStatement ifStatement smalltalkInjection'	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Parser-Core'!!PPCompoGrammar commentStamp: 'lr 11/29/2009 09:58' prior: 0!A parser for Smalltalk methods and expressions.!!PPCompoGrammar methodsFor: 'grammar' stamp: 'PetrSpacek 11/13/2013 14:15'!array	^ ${ asParser compoToken , (expression delimitedBy: semicolonToken ) optional , $} asParser compoToken! !!PPCompoGrammar methodsFor: 'grammar' stamp: 'lr 9/27/2009 12:42'!assignment	^ variable , assignmentToken! !!PPCompoGrammar methodsFor: 'grammar' stamp: 'lr 9/27/2009 12:42'!expression	^ assignment star , cascadeExpression! !!PPCompoGrammar methodsFor: 'grammar' stamp: 'PetrSpacek 11/18/2013 20:45'!forStatement	^ 'for' asParser compoToken , $( asParser compoToken , expression , semicolonToken , expression, semicolonToken , expression , $) asParser compoToken , ${ asParser compoToken , methodSequence, $} asParser compoToken.! !!PPCompoGrammar methodsFor: 'grammar' stamp: 'PetrSpacek 11/18/2013 16:58'!ifStatement	^ 'if' asParser compoToken , parens, ${ asParser compoToken , methodSequence, $} asParser compoToken, ('else' asParser compoToken , ${ asParser compoToken , methodSequence, $} asParser compoToken) optional.		! !!PPCompoGrammar methodsFor: 'grammar' stamp: 'PetrSpacek 11/8/2012 23:40'!literal	^ numberLiteral / stringLiteral / charLiteral / arrayLiteral / byteLiteral / symbolLiteral / nilLiteral / trueLiteral / falseLiteral / dereferenceLiteral / portAddressLiteral / collectionPortLiteral! !!PPCompoGrammar methodsFor: 'grammar' stamp: 'lr 9/27/2009 12:42'!message	^ keywordMessage / binaryMessage / unaryMessage! !!PPCompoGrammar methodsFor: 'grammar' stamp: 'lr 9/27/2009 12:42'!method	^ methodDeclaration , methodSequence! !!PPCompoGrammar methodsFor: 'grammar' stamp: 'lr 9/27/2009 12:42'!methodDeclaration	^ keywordMethod / unaryMethod / binaryMethod! !!PPCompoGrammar methodsFor: 'grammar' stamp: 'PetrSpacek 10/18/2012 15:02'!methodSequence	^ semicolonToken  star , pragmas , semicolonToken star , temporaries , semicolonToken star , pragmas , semicolonToken star , statements! !!PPCompoGrammar methodsFor: 'grammar' stamp: 'PetrSpacek 10/17/2012 15:26'!parens	^ $( asParser compoToken , expression , $) asParser compoToken! !!PPCompoGrammar methodsFor: 'grammar' stamp: 'FerrandAnthony 2/11/2015 20:35'!pragma	^ $< asParser compoToken , $!! asParser compoToken not, pragmaMessage , $> asParser compoToken! !!PPCompoGrammar methodsFor: 'grammar' stamp: 'lr 9/27/2009 12:42'!pragmas	^ pragma star! !!PPCompoGrammar methodsFor: 'grammar' stamp: 'lr 5/3/2010 21:39'!primary	^ literal / variable / block / parens / array! !!PPCompoGrammar methodsFor: 'grammar' stamp: 'PetrSpacek 11/9/2012 00:01'!return	"^ $^ asParser compoToken , expression"	^ 'return' asParser compoToken , expression! !!PPCompoGrammar methodsFor: 'grammar' stamp: 'PetrSpacek 10/18/2012 15:01'!sequence	^ temporaries , semicolonToken star , statements! !!PPCompoGrammar methodsFor: 'grammar' stamp: 'FerrandAnthony 2/15/2015 09:44'!statements	^ (return , semicolonToken star			==> [ :nodes | (Array with: nodes first) , (nodes last) ])	/ (forStatement , semicolonToken star			==> [ :nodes | (Array with: nodes first) , (nodes last) ])	/ (whileStatement , semicolonToken star			==> [ :nodes | (Array with: nodes first) , (nodes last) ])	/ (ifStatement , semicolonToken star			==> [ :nodes | (Array with: nodes first) , (nodes last) ])	/ ((connection / disconnection / rockConnection / connectionAlt / rockConnectionAlt) wrapped , ((semicolonToken  plus , statements ==> [ :nodes | nodes first , nodes last ]) 								/ semicolonToken star)			==> [ :nodes | (Array with: nodes first) , (nodes last) ])	/	(expression wrapped , ((semicolonToken  plus , statements ==> [ :nodes | nodes first , nodes last ])								/ semicolonToken star)			==> [ :nodes | (Array with: nodes first) , (nodes last) ])	/	(semicolonToken star)! !!PPCompoGrammar methodsFor: 'grammar' stamp: 'PetrSpacek 10/17/2012 15:26'!temporaries	^ ($| asParser compoToken , variable star , $| asParser compoToken) optional ==> [ :nodes | nodes ifNil: [ #() ] ]! !!PPCompoGrammar methodsFor: 'grammar' stamp: 'FerrandAnthony 2/18/2015 14:06'!variable	^ $!! asParser compoToken optional, identifierToken! !!PPCompoGrammar methodsFor: 'grammar' stamp: 'PetrSpacek 11/18/2013 16:59'!whileStatement	^ 'while' asParser compoToken , parens , ${ asParser compoToken , methodSequence, $} asParser compoToken.		! !!PPCompoGrammar methodsFor: 'grammar-literals' stamp: 'TestRunner 10/23/2009 17:39'!arrayItem	^ literal / symbolLiteralArray / arrayLiteralArray / byteLiteralArray! !!PPCompoGrammar methodsFor: 'grammar-literals' stamp: 'PetrSpacek 10/17/2012 15:26'!arrayLiteral	^ '#(' asParser compoToken , arrayItem star , $) asParser compoToken! !!PPCompoGrammar methodsFor: 'grammar-literals' stamp: 'PetrSpacek 10/17/2012 15:26'!arrayLiteralArray	^ $( asParser compoToken , arrayItem star , $) asParser compoToken! !!PPCompoGrammar methodsFor: 'grammar-literals' stamp: 'PetrSpacek 10/17/2012 15:26'!byteLiteral	^ '#[' asParser compoToken , numberLiteral star , $] asParser compoToken! !!PPCompoGrammar methodsFor: 'grammar-literals' stamp: 'PetrSpacek 10/17/2012 15:26'!byteLiteralArray	^ $[ asParser compoToken , numberLiteral star , $] asParser compoToken! !!PPCompoGrammar methodsFor: 'grammar-literals' stamp: 'lr 9/27/2009 12:42'!charLiteral	^ charToken! !!PPCompoGrammar methodsFor: 'grammar-literals' stamp: 'lr 9/27/2009 12:42'!nilLiteral	^ nilToken! !!PPCompoGrammar methodsFor: 'grammar-literals' stamp: 'lr 9/27/2009 12:42'!numberLiteral	^ numberToken! !!PPCompoGrammar methodsFor: 'grammar-literals' stamp: 'lr 9/27/2009 12:42'!stringLiteral	^ stringToken! !!PPCompoGrammar methodsFor: 'grammar-literals' stamp: 'PetrSpacek 10/17/2012 15:26'!symbolLiteral	"This is totally fucked up: The Pharo compiler allows multiple #, arbitrary spaces between the # and the symbol, as well as comments inbetween. And yes, it is used."	^ $# asParser compoToken plus , symbol compoToken ==> [ :tokens | tokens first copyWith: tokens last ]! !!PPCompoGrammar methodsFor: 'grammar-literals' stamp: 'PetrSpacek 10/17/2012 15:26'!symbolLiteralArray	^ symbol compoToken! !!PPCompoGrammar methodsFor: 'grammar-literals' stamp: 'lr 9/27/2009 12:42'!trueLiteral	^ trueToken! !!PPCompoGrammar methodsFor: 'token' stamp: 'PetrSpacek 10/17/2012 15:26'!assignmentToken	^ self class allowUnderscoreAssignment		ifTrue: [ (':=' asParser / '_' asParser) compoToken ]		ifFalse: [ ':=' asParser compoToken ]! !!PPCompoGrammar methodsFor: 'token' stamp: 'PetrSpacek 10/17/2012 15:26'!binaryToken	^ binary compoToken! !!PPCompoGrammar methodsFor: 'token' stamp: 'PetrSpacek 10/19/2012 12:21'!binaryTokenLimited	^ binaryLimited compoToken! !!PPCompoGrammar methodsFor: 'token' stamp: 'PetrSpacek 10/17/2012 15:26'!charToken	^ char compoToken! !!PPCompoGrammar methodsFor: 'token' stamp: 'PetrSpacek 10/18/2012 14:47'!commaToken	^ comma compoToken! !!PPCompoGrammar methodsFor: 'token' stamp: 'PetrSpacek 10/17/2012 15:26'!falseToken	^ ('false' asParser , #word asParser not) compoToken! !!PPCompoGrammar methodsFor: 'token' stamp: 'PetrSpacek 10/17/2012 15:26'!identifierToken	^ identifier compoToken! !!PPCompoGrammar methodsFor: 'token' stamp: 'PetrSpacek 10/17/2012 15:26'!keywordToken	^ keyword compoToken! !!PPCompoGrammar methodsFor: 'token' stamp: 'PetrSpacek 10/17/2012 15:26'!nilToken	^ ('nil' asParser , #word asParser not) compoToken! !!PPCompoGrammar methodsFor: 'token' stamp: 'PetrSpacek 10/17/2012 15:26'!numberToken	^ number compoToken! !!PPCompoGrammar methodsFor: 'token' stamp: 'PetrSpacek 10/17/2012 15:26'!periodToken	^ period compoToken! !!PPCompoGrammar methodsFor: 'token' stamp: 'PetrSpacek 10/18/2012 14:44'!semicolonToken	^ semicolon compoToken! !!PPCompoGrammar methodsFor: 'token' stamp: 'PetrSpacek 10/17/2012 15:26'!stringToken	^ string compoToken! !!PPCompoGrammar methodsFor: 'token' stamp: 'PetrSpacek 10/17/2012 15:26'!trueToken	^ ('true' asParser , #word asParser not) compoToken! !!PPCompoGrammar methodsFor: 'token' stamp: 'PetrSpacek 10/17/2012 15:26'!unaryToken	^ unary compoToken! !!PPCompoGrammar methodsFor: 'primitives' stamp: 'lr 8/11/2011 23:29'!binary	^ (PPPredicateObjectParser anyOf: '!!%&*+,-/<=>?@\|~') plus! !!PPCompoGrammar methodsFor: 'primitives' stamp: 'PetrSpacek 10/19/2012 12:22'!binaryLimited	^ (PPPredicateObjectParser anyOf: '!!%&*+-/<=>?@\|~') plus! !!PPCompoGrammar methodsFor: 'primitives' stamp: 'lr 9/27/2009 12:42'!char	^ $$ asParser , #any asParser! !!PPCompoGrammar methodsFor: 'primitives' stamp: 'PetrSpacek 10/18/2012 14:47'!comma	^ $, asParser! !!PPCompoGrammar methodsFor: 'primitives' stamp: 'lr 7/11/2011 11:32'!identifier	^ self class allowUnderscoreAssignment		ifTrue: [ #letter asParser , #word asParser star ]		ifFalse: [			(PPPredicateObjectParser				on: [ :each | each isLetter or: [ each = $_ ] ]				message: 'letter expected') ,			(PPPredicateObjectParser				on: [ :each | each isAlphaNumeric or: [ each = $_ ] ]				message: 'letter or digit expected') star ]! !!PPCompoGrammar methodsFor: 'primitives' stamp: 'lr 9/27/2009 12:42'!keyword	^ identifier , $: asParser! !!PPCompoGrammar methodsFor: 'primitives' stamp: 'lr 9/27/2009 12:42'!multiword	^ keyword plus! !!PPCompoGrammar methodsFor: 'primitives' stamp: 'lr 8/13/2011 20:33'!number	^ ($- asParser optional , #digit asParser) and , [ :stream | 		[ Number readFrom: stream ] 			on: Error			do: [ :err | PPFailure message: err messageText at: stream position ] ] 				asParser! !!PPCompoGrammar methodsFor: 'primitives' stamp: 'lr 8/13/2011 20:51'!period	^ $. asParser! !!PPCompoGrammar methodsFor: 'primitives' stamp: 'PetrSpacek 10/18/2012 14:44'!semicolon	^ $; asParser! !!PPCompoGrammar methodsFor: 'primitives' stamp: 'lr 1/8/2010 15:38'!string	^ $' asParser , ('''''' asParser / $' asParser negate) star , $' asParser! !!PPCompoGrammar methodsFor: 'primitives' stamp: 'lr 9/27/2009 12:42'!symbol	^ unary / binary / multiword / string! !!PPCompoGrammar methodsFor: 'primitives' stamp: 'lr 9/27/2009 12:42'!unary	^ identifier , $: asParser not! !!PPCompoGrammar methodsFor: 'grammar-literals-compo' stamp: 'PetrSpacek 10/18/2012 13:42'!collectionPortLiteral	^ identifier compoToken, $[ asParser compoToken , expression , $] asParser compoToken.! !!PPCompoGrammar methodsFor: 'grammar-literals-compo' stamp: 'FerrandAnthony 1/31/2015 15:45'!dereferenceLiteral	^ $& asParser compoToken plus , identifier compoToken! !!PPCompoGrammar methodsFor: 'grammar-literals-compo' stamp: 'FerrandAnthony 2/16/2015 15:14'!portAddressLiteral	^ identifier compoToken, $@ asParser compoToken , ( collectionPortLiteral / ($( asParser compoToken , cascadeExpression , $) asParser compoToken) / dereferenceLiteral / identifierToken ).! !!PPCompoGrammar methodsFor: 'grammar-literals-compo' stamp: 'FerrandAnthony 2/16/2015 14:57'!selfAddressLiteral	 ^ identifier compoToken.! !!PPCompoGrammar methodsFor: 'grammar-messages' stamp: 'lr 9/27/2009 12:42'!binaryExpression	^ unaryExpression , binaryMessage star! !!PPCompoGrammar methodsFor: 'grammar-messages' stamp: 'PetrSpacek 10/19/2012 12:20'!binaryExpressionLimited	^ unaryExpression , binaryMessageLimited star! !!PPCompoGrammar methodsFor: 'grammar-messages' stamp: 'lr 12/6/2009 10:38'!binaryMessage	^ (binaryToken , unaryExpression) ==> [ :nodes | 		Array 			with: (Array with: nodes first)			with: (Array with: nodes second) ]! !!PPCompoGrammar methodsFor: 'grammar-messages' stamp: 'PetrSpacek 10/19/2012 12:20'!binaryMessageLimited	^ (binaryTokenLimited , unaryExpression) ==> [ :nodes | 		Array 			with: (Array with: nodes first)			with: (Array with: nodes second) ]! !!PPCompoGrammar methodsFor: 'grammar-messages' stamp: 'FerrandAnthony 2/11/2015 20:40'!cascadeExpression	"^ keywordExpression , cascadeMessage star"	^ keywordExpression / pragma / smalltalkInjection" ==> [:nodes | nodes first]."! !!PPCompoGrammar methodsFor: 'grammar-messages' stamp: 'PetrSpacek 10/18/2012 15:05'!cascadeMessage	^ $, asParser compoToken , message! !!PPCompoGrammar methodsFor: 'grammar-messages' stamp: 'PetrSpacek 10/26/2012 15:56'!keywordExpression	"^ binaryExpression , keywordMessage optional"	^ binaryExpression.! !!PPCompoGrammar methodsFor: 'grammar-messages' stamp: 'lr 12/6/2009 10:38'!keywordMessage	^ (keywordToken , binaryExpression) plus ==> [ :nodes | 		Array 			with: (nodes collect: [ :each | each first ])			with: (nodes collect: [ :each | each second ]) ]! !!PPCompoGrammar methodsFor: 'grammar-messages' stamp: 'PetrSpacek 11/13/2012 22:11'!unaryExpression	^ unarySubExpression , unaryMessage star! !!PPCompoGrammar methodsFor: 'grammar-messages' stamp: 'PetrSpacek 10/26/2012 16:12'!unaryMessage	"^ unaryToken ==> [ :node | 		Array 			with: (Array with: node)			with: Array new ]"	^ (periodToken, identifierToken , $( asParser compoToken , ( binaryExpressionLimited delimitedBy: comma) withoutSeparators optional , $) asParser compoToken) ==> [ :nodes | Array with: (nodes second) with: (nodes at: 4) ].			! !!PPCompoGrammar methodsFor: 'grammar-messages' stamp: 'PetrSpacek 10/26/2012 16:12'!unarySubExpression	^ primary , unaryMessage optional! !!PPCompoGrammar methodsFor: 'grammar-methods' stamp: 'lr 12/6/2009 10:38'!binaryMethod	^ (binaryToken , variable) ==> [ :nodes | 		Array 			with: (Array with: nodes first)			with: (Array with: nodes second) ]! !!PPCompoGrammar methodsFor: 'grammar-methods' stamp: 'lr 12/6/2009 10:38'!keywordMethod	^ (keywordToken , variable) plus ==> [ :nodes | 		Array 			with: (nodes collect: [ :each | each first ])			with: (nodes collect: [ :each | each second ]) ]! !!PPCompoGrammar methodsFor: 'grammar-methods' stamp: 'lr 12/6/2009 10:39'!unaryMethod	^ identifierToken ==> [ :node | 		Array 			with: (Array with: node)			with: Array new ]! !!PPCompoGrammar methodsFor: 'grammar-pragmas' stamp: 'TestRunner 10/23/2009 17:34'!binaryPragma	^ (binaryToken , arrayItem) ==> [ :nodes | 		Array 			with: (Array with: nodes first)			with: (Array with: nodes second) ]! !!PPCompoGrammar methodsFor: 'grammar-pragmas' stamp: 'TestRunner 10/23/2009 17:35'!keywordPragma	^ (keywordToken , arrayItem) plus ==> [ :nodes | 		Array 			with: (nodes collect: [ :each | each first ])			with: (nodes collect: [ :each | each second ]) ]! !!PPCompoGrammar methodsFor: 'grammar-pragmas' stamp: 'lr 9/27/2009 12:42'!pragmaMessage	^ keywordPragma / unaryPragma / binaryPragma! !!PPCompoGrammar methodsFor: 'grammar-pragmas' stamp: 'TestRunner 10/23/2009 16:35'!unaryPragma	^ identifierToken ==> [ :node | 		Array 			with: (Array with: node)			with: (Array new) ]! !!PPCompoGrammar methodsFor: 'grammar-compo' stamp: 'FerrandAnthony 2/15/2015 09:18'!architecture	^ 'architecture' asParser compoToken , ${ asParser compoToken , ((connection / disconnection / rockConnection / connectionAlt / rockConnectionAlt) delimitedBy: semicolonToken) withoutSeparators optional , $} asParser compoToken! !!PPCompoGrammar methodsFor: 'grammar-compo' stamp: 'PetrSpacek 11/7/2012 15:09'!compoExpr	^ exProvisions / exRequirements / inProvisions / inRequirements / constraint / service / architecture! !!PPCompoGrammar methodsFor: 'grammar-compo' stamp: 'PetrSpacek 10/18/2012 15:13'!compoIdent	^ identifierToken! !!PPCompoGrammar methodsFor: 'grammar-compo' stamp: 'FerrandAnthony 2/18/2015 19:06'!connection	^ 'connect' asParser compoToken , (portAddressLiteral / selfAddressLiteral) , 'to' asParser compoToken , (portAddressLiteral /  variable / selfAddressLiteral) , ('kind-of' asParser compoToken , compoIdent) optional! !!PPCompoGrammar methodsFor: 'grammar-compo' stamp: 'FerrandAnthony 2/18/2015 19:07'!connectionAlt	^ (portAddressLiteral / selfAddressLiteral), '>>>' asParser compoToken , (portAddressLiteral / variable / selfAddressLiteral) , ('kind-of' asParser compoToken , compoIdent  ) optional! !!PPCompoGrammar methodsFor: 'grammar-compo' stamp: 'PetrSpacek 10/18/2012 14:27'!constraint	^ 'constraint' asParser compoToken , serviceSign , ${ asParser compoToken , methodSequence, $} asParser compoToken! !!PPCompoGrammar methodsFor: 'grammar-compo' stamp: 'PetrSpacek 11/11/2013 21:18'!descriptor	^ compoIdent , compoIdent , ('extends' asParser compoToken , compoIdent) optional , ${ asParser compoToken , compoExpr star, $} asParser compoToken! !!PPCompoGrammar methodsFor: 'grammar-compo' stamp: 'FerrandAnthony 2/1/2015 13:09'!disconnection	^ 'disconnect' asParser compoToken , portAddressLiteral , 'from' asParser compoToken , portAddressLiteral! !!PPCompoGrammar methodsFor: 'grammar-compo' stamp: 'PetrSpacek 11/7/2012 16:31'!exProvisions	^ 'externally' asParser compoToken optional , 'provides' asParser compoToken , ${ asParser  compoToken, (port delimitedBy: semicolonToken) withoutSeparators optional , $} asParser compoToken! !!PPCompoGrammar methodsFor: 'grammar-compo' stamp: 'PetrSpacek 11/7/2012 16:31'!exRequirements	^ 'externally' asParser compoToken optional , 'requires' asParser compoToken ,  ${ asParser  compoToken, (port delimitedBy: semicolonToken) withoutSeparators optional , $} asParser compoToken! !!PPCompoGrammar methodsFor: 'grammar-compo' stamp: 'lr 9/27/2009 12:42'!falseLiteral	^ falseToken! !!PPCompoGrammar methodsFor: 'grammar-compo' stamp: 'PetrSpacek 11/7/2012 16:13'!inProvisions	^ 'internally' asParser compoToken optional , 'provides' asParser compoToken , ${ asParser  compoToken, (port delimitedBy: semicolonToken) withoutSeparators optional , $} asParser compoToken! !!PPCompoGrammar methodsFor: 'grammar-compo' stamp: 'PetrSpacek 11/7/2012 16:31'!inRequirements	^ 'internally' asParser compoToken optional , 'requires' asParser compoToken , ${ asParser  compoToken, ((port , ('inject-with' asParser compoToken , compoIdent) optional) delimitedBy: semicolonToken ) withoutSeparators optional , $} asParser compoToken! !!PPCompoGrammar methodsFor: 'grammar-compo' stamp: 'PetrSpacek 11/7/2012 15:06'!interface	^ 'interface' asParser compoToken , compoIdent , ('extends' asParser compoToken , compoIdent) optional , serviceSignsList ! !!PPCompoGrammar methodsFor: 'grammar-compo' stamp: 'PetrSpacek 11/22/2013 13:58'!port	^ compoIdent, '[]' asParser compoToken optional , $: asParser compoToken , (compoIdent / $* asParser compoToken / serviceSignsList) , ('ofKind' asParser compoToken , compoIdent) optional! !!PPCompoGrammar methodsFor: 'grammar-compo' stamp: 'FerrandAnthony 2/19/2015 18:05'!service	^ ('service' asParser compoToken / 'operation' asParser compoToken) , serviceSign ,  (':req' asParser compoToken / ':pro' asParser compoToken) optional, ${ asParser compoToken , methodSequence, $} asParser compoToken! !!PPCompoGrammar methodsFor: 'grammar-compo' stamp: 'PetrSpacek 11/7/2012 16:30'!serviceSign	^ compoIdent , $( asParser compoToken , (compoIdent delimitedBy: commaToken) withoutSeparators optional , $) asParser compoToken! !!PPCompoGrammar methodsFor: 'grammar-compo' stamp: 'PetrSpacek 11/7/2012 16:30'!serviceSignsList	^ ${ asParser compoToken , (serviceSign delimitedBy: semicolonToken) withoutSeparators optional , $} asParser compoToken ! !!PPCompoGrammar methodsFor: 'grammar-blocks' stamp: 'PetrSpacek 10/17/2012 15:26'!block	^ $[ asParser compoToken , blockBody , $] asParser compoToken! !!PPCompoGrammar methodsFor: 'grammar-blocks' stamp: 'PetrSpacek 10/17/2012 15:26'!blockArgument	^ $: asParser compoToken , variable! !!PPCompoGrammar methodsFor: 'grammar-blocks' stamp: 'lr 2/4/2010 13:21'!blockArguments	^ blockArgumentsWith / blockArgumentsWithout! !!PPCompoGrammar methodsFor: 'grammar-blocks' stamp: 'PetrSpacek 10/17/2012 15:26'!blockArgumentsWith	^ blockArgument plus , ($| asParser compoToken / ($] asParser compoToken and ==> [ :node | nil ]))! !!PPCompoGrammar methodsFor: 'grammar-blocks' stamp: 'lr 2/4/2010 11:44'!blockArgumentsWithout	^ nil asParser ==> [ :nodes | Array with: #() with: nil ]! !!PPCompoGrammar methodsFor: 'grammar-blocks' stamp: 'lr 2/4/2010 11:39'!blockBody	^ blockArguments , sequence! !!PPCompoGrammar methodsFor: 'parsing' stamp: 'PetrSpacek 10/26/2012 15:41'!parseConnection: aString 	^ self parseConnection: aString onError: [ :msg :pos | self error: msg ].! !!PPCompoGrammar methodsFor: 'parsing' stamp: 'PetrSpacek 10/26/2012 15:41'!parseConnection: aString onError: aBlock	^ startConnection parse: aString onError: aBlock.! !!PPCompoGrammar methodsFor: 'parsing' stamp: 'PetrSpacek 10/19/2012 16:23'!parseDeclaration: aString 	^ self parseDeclaration: aString onError: [ :msg :pos | self error: msg ]! !!PPCompoGrammar methodsFor: 'parsing' stamp: 'PetrSpacek 10/19/2012 23:12'!parseDeclaration: aString onError: aBlock	^ startDeclaration parse: aString onError: aBlock! !!PPCompoGrammar methodsFor: 'parsing' stamp: 'lr 2/19/2010 08:00'!parseExpression: aString 	^ self parseExpression: aString onError: [ :msg :pos | self error: msg ]! !!PPCompoGrammar methodsFor: 'parsing' stamp: 'lr 2/19/2010 08:04'!parseExpression: aString onError: aBlock	^ startExpression parse: aString onError: aBlock! !!PPCompoGrammar methodsFor: 'parsing' stamp: 'PetrSpacek 10/18/2012 15:18'!parseMethod: aString 	"^ self parseMethod: aString onError: [ :msg :pos | self error: msg ]"! !!PPCompoGrammar methodsFor: 'parsing' stamp: 'PetrSpacek 10/18/2012 15:18'!parseMethod: aString onError: aBlock	"^ startMethod parse: aString onError: aBlock"! !!PPCompoGrammar methodsFor: 'parsing' stamp: 'PetrSpacek 11/11/2012 18:25'!parseService: aString 	^ self parseService: aString onError: [ :msg :pos | self error: msg ]! !!PPCompoGrammar methodsFor: 'parsing' stamp: 'PetrSpacek 11/11/2012 18:25'!parseService: aString onError: aBlock	^ startService parse: aString onError: aBlock! !!PPCompoGrammar methodsFor: 'accessing' stamp: 'PetrSpacek 10/18/2012 14:38'!start	"Default start production."	^ (descriptor / interface) star end! !!PPCompoGrammar methodsFor: 'accessing' stamp: 'FerrandAnthony 2/15/2015 09:10'!startConnection 	^ (connection / disconnection / rockConnection / connectionAlt / rockConnectionAlt) end.! !!PPCompoGrammar methodsFor: 'accessing' stamp: 'PetrSpacek 11/7/2012 15:09'!startDeclaration	^ (descriptor / interface) end! !!PPCompoGrammar methodsFor: 'accessing' stamp: 'lr 2/19/2010 08:03'!startExpression	"Start production for the expression."	^ sequence end! !!PPCompoGrammar methodsFor: 'accessing' stamp: 'PetrSpacek 10/18/2012 14:39'!startMethod	"Start production for the method."	"^ method end"! !!PPCompoGrammar methodsFor: 'accessing' stamp: 'PetrSpacek 11/11/2012 18:26'!startService	"Start production for the method."	^ service end.! !!PPCompoGrammar methodsFor: 'as yet unclassified' stamp: 'FerrandAnthony 2/18/2015 19:05'!rockConnection	^ 'connect' asParser compoToken , (portAddressLiteral / selfAddressLiteral) , 'to' asParser compoToken , literal! !!PPCompoGrammar methodsFor: 'as yet unclassified' stamp: 'FerrandAnthony 2/18/2015 19:05'!rockConnectionAlt	^ (portAddressLiteral / selfAddressLiteral), '>>>' asParser compoToken , literal! !!PPCompoGrammar methodsFor: 'as yet unclassified' stamp: 'FerrandAnthony 2/16/2015 15:26'!smalltalkInjection	^ '<!!' asParser, ((PPPredicateObjectParser anyExceptAnyOf: '>') / ('>!!' asParser)) star, ( '>' asParser)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PPCompoGrammar class	instanceVariableNames: ''!!PPCompoGrammar class methodsFor: 'testing' stamp: 'lr 5/1/2012 09:33'!allowUnderscoreAssignment	^ (Scanner respondsTo: #allowUnderscoreAsAssignment) and: [ Scanner allowUnderscoreAsAssignment ]! !!PPCompoGrammar class methodsFor: 'accessing' stamp: 'PetrSpacek 11/15/2012 01:05'!parse: aString	|result wasError eMsg ePos copyStart copyEnd|	wasError := false.	ePos :=0.	result := self new parseDeclaration: aString onError: [ :msg :pos | eMsg := msg. ePos := pos. wasError := true ].	(wasError) ifTrue: [		wasError := false.		result := self new parseService: aString onError: [ :msg :pos | eMsg := msg. ePos := pos. wasError := true ]	].	(wasError) ifTrue: [		wasError := false.		result := self new parseConnection: aString onError: [ :msg :pos | eMsg := msg. ePos := pos. wasError := true ]	].	(wasError) ifTrue: [		wasError := false.		result := self new parseExpression: aString onError: [ :msg :pos | eMsg := msg. ePos := pos. wasError := true ]	].	(ePos > 4) ifTrue: [copyStart := ePos - 4] ifFalse: [copyStart := 1].	(ePos + 4 > (aString size)) ifTrue: [copyEnd := (aString size)] ifFalse: [copyEnd := ePos + 4].	(wasError) ifTrue: [ self error: 'Compo parse error ''', eMsg ,''' on position ',ePos asString,' near ''' , (aString copyFrom: copyStart to: copyEnd)  , '''' ].		^ result.! !!PPCompoGrammar class methodsFor: 'accessing' stamp: 'PetrSpacek 10/26/2012 15:47'!parseConenction: aString onError: aBlock	^ self new parseConnection: aString onError: aBlock! !!PPCompoGrammar class methodsFor: 'accessing' stamp: 'PetrSpacek 10/26/2012 15:48'!parseConnection: aString	^ self new parseConnection: aString! !!PPCompoGrammar class methodsFor: 'accessing' stamp: 'PetrSpacek 10/19/2012 23:09'!parseDeclaration: aString	^ self new parseDeclaration: aString! !!PPCompoGrammar class methodsFor: 'accessing' stamp: 'PetrSpacek 10/19/2012 23:10'!parseDeclaration: aString onError: aBlock	^ self new parseDeclaration: aString onError: aBlock! !!PPCompoGrammar class methodsFor: 'accessing' stamp: 'lr 2/19/2010 08:08'!parseExpression: aString	^ self new parseExpression: aString! !!PPCompoGrammar class methodsFor: 'accessing' stamp: 'lr 2/19/2010 08:09'!parseExpression: aString onError: aBlock	^ self new parseExpression: aString onError: aBlock! !!PPCompoGrammar class methodsFor: 'accessing' stamp: 'lr 2/19/2010 08:09'!parseMethod: aString	^ self new parseMethod: aString! !!PPCompoGrammar class methodsFor: 'accessing' stamp: 'lr 2/19/2010 08:09'!parseMethod: aString onError: aBlock	^ self new parseMethod: aString onError: aBlock! !!PPCompoGrammar class methodsFor: 'accessing' stamp: 'PetrSpacek 11/11/2012 18:28'!parseService: aString	^ self new parseService: aString! !!PPCompoGrammar class methodsFor: 'accessing' stamp: 'PetrSpacek 11/11/2012 18:28'!parseService: aString onError: aBlock	^ self new parseService: aString onError: aBlock! !!PPCompoGrammar class methodsFor: 'as yet unclassified' stamp: 'FerrandAnthony 2/7/2015 21:33'!matchesLiteral: aString	^ self new literal matches: aString! !PPCompoGrammar subclass: #PPCompoParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Parser-Core'!!PPCompoParser commentStamp: 'lr 11/29/2009 09:58' prior: 0!Enhances the Smalltalk grammar with production actions to build parse-tree nodes of the refactoring browser.!!PPCompoParser methodsFor: 'private' stamp: 'PetrSpacek 11/11/2013 18:42'!addComments: aCollectionOfIntervals toNode: aNode	(aCollectionOfIntervals isNil or: [ aCollectionOfIntervals isEmpty ])		ifFalse: [ aNode comments: aNode comments , aCollectionOfIntervals ]! !!PPCompoParser methodsFor: 'private' stamp: 'PetrSpacek 11/11/2013 18:42'!addStatements: aCollection into: aNode	aCollection isNil 		ifTrue: [ ^ aNode ].	aCollection do: [ :each |		each class == PPCompoToken			ifFalse: [ aNode addNode:  each ]			ifTrue: [				aNode statements isEmpty					ifTrue: [ self addComments: each comments toNode: aNode ]					ifFalse: [ self addComments: each comments toNode: (aNode statements last) ].				aNode periods: (aNode periods asOrderedCollection					addLast: each start;					yourself) ] ].	^ aNode! !!PPCompoParser methodsFor: 'private' stamp: 'TestRunner 11/5/2009 10:36'!build: aNode assignment: anArray	^ anArray isEmpty		ifTrue: [ aNode ]		ifFalse: [			anArray reverse 				inject: aNode				into: [ :result :each |					RBAssignmentNode 						variable: each first						value: result						position: each second start ] ]! !!PPCompoParser methodsFor: 'private' stamp: 'lr 9/11/2010 10:11'!build: aNode cascade: anArray 	| messages semicolons |	^ (anArray isNil or: [ anArray isEmpty ]) 		ifTrue: [ aNode ]		ifFalse: [			messages := OrderedCollection new: anArray size + 1.			messages addLast: aNode.			semicolons := OrderedCollection new.			anArray do: [ :each | 				messages addLast: (self 					build: aNode receiver					messages: (Array with: each second)).				semicolons addLast: each first start ].			RBCascadeNode messages: messages semicolons: semicolons ]! !!PPCompoParser methodsFor: 'private' stamp: 'PetrSpacek 10/19/2012 15:20'!build: aNode messages: anArray 	^ (anArray isNil or: [ anArray isEmpty ]) 		ifTrue: [ aNode ]		ifFalse: [			anArray 				inject: aNode				into: [ :rec :msg | 					msg isNil 						ifTrue: [ rec ]						ifFalse: [							RBMessageNode 								receiver: rec								selectorParts: msg first								arguments: msg second ] ] ]! !!PPCompoParser methodsFor: 'private' stamp: 'lr 8/14/2011 12:03'!build: aTempCollection sequence: aStatementCollection	| result |	result := self		addStatements: aStatementCollection		into: RBSequenceNode new.	aTempCollection isEmpty ifFalse: [		result			leftBar: aTempCollection first start			temporaries: aTempCollection second			rightBar: aTempCollection last start ].	^ result! !!PPCompoParser methodsFor: 'private' stamp: 'FerrandAnthony 2/11/2015 11:18'!build: aNode serviceInvocation: anArray 	^ (anArray isNil or: [ anArray isEmpty ]) 		ifTrue: [ aNode ]		ifFalse: [			|inst ar|			inst := aNode.			anArray do: [:e |				inst := CompoServiceInvocationNode  					receiver: inst					selector: e first					arguments: e second.				"(inst receiver isKindOf: (Smalltalk at: #CompoParseNode))					ifTrue: [ inst receiver parent: inst ]."				inst receiver parent: inst.			].						"return inst"			inst.		].! !!PPCompoParser methodsFor: 'private' stamp: 'PetrSpacek 11/13/2012 22:10'!build: aNode serviceInvocationBase: anArray 	^ (anArray isNil or: [ anArray isEmpty ]) 		ifTrue: [ aNode ]		ifFalse: [			|inst|			inst := CompoServiceInvocationNode  					receiver: aNode					selector: anArray first					arguments: anArray second.			(aNode isKindOf: (Smalltalk at: #CompoParseNode))				ifTrue: [ aNode parent: inst ].			"return inst"			inst.		].! !!PPCompoParser methodsFor: 'private' stamp: 'FerrandAnthony 2/15/2015 09:38'!buildArchitecture: nodes	|inst conns disconns|		conns := (nodes at: 3).	disconns := nil.	conns ifNotNil: [		disconns := conns select: [:c | (c isKindOf: (Smalltalk at: #CompoDisconnectionNode)) ].		conns := conns select: [:c | (c isKindOf: (Smalltalk at: #CompoConnectionNode)) | (c isKindOf: (Smalltalk at: #CompoConnectionRockNode)) ].	].		inst := CompoArchitectureNode new			disconns: disconns ;			conns: conns ;			yourself.				conns ifNotNil: [conns do: [:c | c parent: inst]].	disconns ifNotNil: [disconns do: [:c | c parent: inst]].				^inst.		! !!PPCompoParser methodsFor: 'private' stamp: 'lr 8/14/2011 12:00'!buildArray: aStatementCollection	^ self addStatements: aStatementCollection into: RBArrayNode new! !!PPCompoParser methodsFor: 'private' stamp: 'PetrSpacek 11/7/2012 20:09'!buildCollectionPort: nodes	|inst name expr|	name := nodes at: 1.	expr := nodes at: 3.		inst := CompoCollectionPortLiteralNode new				portName: name;				indexExpr: expr;				yourself.					(expr isKindOf: (Smalltalk at: #CompoParseNode))		ifTrue: [ expr parent: inst ].				^ inst.		! !!PPCompoParser methodsFor: 'private' stamp: 'FerrandAnthony 2/18/2015 19:35'!buildConnection: nodes	|inst src dest|	src := nodes at: 2.	dest := nodes at: 4.		inst := CompoConnectionNode new		srcAddress: src;		destAddress: dest;		kind: ((nodes at: 5) isNil ifTrue: [nil] ifFalse:[ (nodes at: 5) at: 2 ]) ;		yourself.			^ inst.! !!PPCompoParser methodsFor: 'private' stamp: 'FerrandAnthony 2/18/2015 19:52'!buildConnectionAlt: nodes	|inst src dest|	src := nodes at: 1.	dest := nodes at: 3.		inst := CompoConnectionNode new		srcAddress: src;		destAddress: dest;		kind: ((nodes at: 4) isNil ifTrue: [nil] ifFalse:[ (nodes at: 4) at: 2 ]) ;		yourself.			^ inst.! !!PPCompoParser methodsFor: 'private' stamp: 'PetrSpacek 11/8/2012 13:24'!buildDeferenceLiteral: nodes	^ CompoDereferenceLiteralNode new		literal: (nodes at: 2);		applicationsCount: (nodes at: 1) size;		yourself.! !!PPCompoParser methodsFor: 'private' stamp: 'PetrSpacek 11/11/2013 21:25'!buildDescriptor: nodes	|body inst|	body := nodes at: 5.	inst := CompoDescriptorNode named: (nodes at: 2) metadesc: (nodes at: 1) extends: ((nodes at: 3) ifNotNil: [(nodes at: 3) second]) body: (body) source: (nodes first collection copy).	body ifNotNil: [ body do: [:node | node parent: inst]].	^ inst.! !!PPCompoParser methodsFor: 'private' stamp: 'PetrSpacek 11/7/2012 18:56'!buildDisconnection: nodes	|inst src dest|	src := nodes at: 2.	dest := nodes at: 4.		inst := CompoDisconnectionNode new		srcAddress: src;		destAddress: dest;		kind: nil ;		yourself.			^ inst.! !!PPCompoParser methodsFor: 'private' stamp: 'PetrSpacek 11/7/2012 16:59'!buildExProvisions: nodes	|body inst|	body := nodes at: 4.	inst := CompoExProvisionsNode new ports: body.	body do: [:node | node parent: inst].	^ inst.! !!PPCompoParser methodsFor: 'private' stamp: 'PetrSpacek 11/7/2012 16:58'!buildExRequirements: nodes	|body inst|	body := nodes at: 4.	inst := CompoExRequirementsNode new ports: body.	body do: [:node | node parent: inst].	^ inst.! !!PPCompoParser methodsFor: 'private' stamp: 'PetrSpacek 11/18/2013 17:18'!buildFor: nodes	|inst cond seed inc body|	seed := (nodes at: 3).	cond := (nodes at: 5).	inc := (nodes at: 7).	body := (nodes at: 10).		inst := CompoForNode new			condition: cond;			seed: seed;			incrementation: inc;			body: body;			yourself.		cond parent: inst.	^inst.! !!PPCompoParser methodsFor: 'private' stamp: 'PetrSpacek 11/18/2013 17:23'!buildIf: nodes	|inst cond ifBody elseBody|	cond := (nodes at: 2).	ifBody := (nodes at: 4).	elseBody := (nodes at: 6).	elseBody ifNotNil: [ elseBody := (elseBody at: 3) ].		inst := CompoIfNode new			condition: cond;			ifBody: ifBody;			elseBody: elseBody;			yourself.		cond parent: inst.	^inst.! !!PPCompoParser methodsFor: 'private' stamp: 'PetrSpacek 11/7/2012 16:57'!buildInProvisions: nodes	|body inst|	body := nodes at: 4.	inst := CompoInProvisionsNode new ports: body.	body do: [:node | node parent: inst].	^ inst.! !!PPCompoParser methodsFor: 'private' stamp: 'PetrSpacek 11/7/2012 17:00'!buildInRequirements: nodes	|ar inst|	ar := nodes at: 4.	"internal requirements can be injected, therefore we have to setup injection, which is optionaly given in second position of each element of [nodes at: 4]"	(ar isNil)		ifTrue: [ ar := nil]		ifFalse: [			ar := ar collect: [:e | ((e at: 2) isNil) ifTrue: [ (e at: 1) yourself ] ifFalse: [ (e at: 1) pInjection: ((e at: 2) at: 2); yourself ]]		].		inst := CompoInRequirementsNode new ports: ar.	ar do: [:node | node parent: inst].	^ inst.! !!PPCompoParser methodsFor: 'private' stamp: 'PetrSpacek 11/7/2012 18:29'!buildInterface: nodes	|body inst|	body := (nodes at: 4) at: 2.	inst := CompoInterfaceNode named: (nodes at: 2) extends: ((nodes at: 3) ifNotNil: [(nodes at: 3) second]) body: (body) source: (nodes first collection copy).	body ifNotNil: [body do: [:node | node parent: inst]].	^ inst.! !!PPCompoParser methodsFor: 'private' stamp: 'lr 3/1/2010 10:51'!buildMethod: aMethodNode	aMethodNode selectorParts 		do: [ :each | aMethodNode addComments: each comments ].	aMethodNode arguments		do: [ :each | aMethodNode addComments: each token comments ].	aMethodNode pragmas do: [ :pragma |		aMethodNode addComments: pragma comments.		pragma selectorParts 			do: [ :each | aMethodNode addComments: each comments ].		pragma arguments do: [ :each | 			each isLiteralArray				ifFalse: [ aMethodNode addComments: each token comments ] ].		pragma comments: nil ].	^ aMethodNode! !!PPCompoParser methodsFor: 'private' stamp: 'FerrandAnthony 2/11/2015 11:03'!buildPort: nodes	|inst interf|	interf := (nodes at: 4).	(interf isKindOf: (Smalltalk at: #Collection))		ifTrue: [interf := interf second].			"(((nodes at: 1) isNil not) and: [(nodes at: 5) isNil not])		ifTrue: [ self error: 'Port  ' , (nodes at: 1) value asString , ' is declared as atomic, kind-of clause cannot be used!!'].	"		inst := CompoPortNode new		pName: (nodes at: 1);		pInterface: (interf);		pKind: ( (nodes at: 5) isNil ifTrue: [nil] ifFalse: [ (nodes at: 5) at: 2 ] ) ;		pIsCollectionPort: ( (nodes at: 2) isNil ifTrue: [false] ifFalse: [true] ) ;		pInjection: nil;		yourself.		(interf isKindOf: (Smalltalk at: #Collection))		ifTrue: [interf do: [:sign | sign parent: inst]].		^ inst.! !!PPCompoParser methodsFor: 'private' stamp: 'FerrandAnthony 2/16/2015 15:01'!buildPortAddress: nodes	|inst right |		right := (nodes at: 3). 				(right isKindOf: (Smalltalk at: #Collection)) ifTrue: [ right := right at: 2].	inst := CompoPortAddressNode new				left: (nodes at: 1);				right: right;				yourself.					(right isKindOf: (Smalltalk at: #CompoParseNode))		ifTrue: [ right parent: inst ].		^inst.! !!PPCompoParser methodsFor: 'private' stamp: 'FerrandAnthony 2/16/2015 15:17'!buildSelfAddress: nodes	| inst |	inst := CompoPortAddressNode new				left: nodes;				right: 'self';				yourself.					^inst.! !!PPCompoParser methodsFor: 'private' stamp: 'FerrandAnthony 2/19/2015 18:05'!buildService: nodes	|inst sign body|	sign := (nodes at: 2).	body := (nodes at: 5).		inst := CompoServiceNode new			signature: sign;			body: body;			returnReq: ((((nodes at: 3) value) = ':req'));			returnPro: ((((nodes at: 3) value) = ':pro'));			bodyStart: (((nodes at: 4) stop) + 1);			bodyEnd: (((nodes at: 6) start) - 1 );			yourself.		sign parent: inst.		^ inst.! !!PPCompoParser methodsFor: 'private' stamp: 'PetrSpacek 11/7/2012 18:17'!buildServiceSign: nodes	^ CompoServiceSignNode new		selector: (nodes at: 1);		arguments: (nodes at: 3);		yourself.! !!PPCompoParser methodsFor: 'private' stamp: 'lr 8/14/2011 12:25'!buildString: aString 	(aString isEmpty or: [ aString first ~= $' or: [ aString last ~= $' ] ])		ifTrue: [ ^ aString ].	^ (aString 		copyFrom: 2		to: aString size - 1) 		copyReplaceAll: ''''''		with: ''''! !!PPCompoParser methodsFor: 'private' stamp: 'PetrSpacek 11/18/2013 17:21'!buildWhile: nodes	|inst cond body|	cond := (nodes at: 2).	body := (nodes at: 4).		inst := CompoWhileNode new			condition: cond;			body: body;			yourself.		cond parent: inst.	^inst.! !!PPCompoParser methodsFor: 'grammar' stamp: 'lr 8/14/2011 11:51'!array	^ super array map: [ :openNode :statementNodes :closeNode |		(self buildArray: statementNodes)			left: openNode start;			right: closeNode start;			yourself ]! !!PPCompoParser methodsFor: 'grammar' stamp: 'lr 12/6/2009 10:40'!expression	^ super expression map: [ :variableNodes :expressionNodes | self build: expressionNodes assignment: variableNodes ]! !!PPCompoParser methodsFor: 'grammar' stamp: 'PetrSpacek 11/11/2013 18:17'!forStatement	^ super forStatement ==> [:nodes | self buildFor: nodes]! !!PPCompoParser methodsFor: 'grammar' stamp: 'PetrSpacek 11/11/2013 18:18'!ifStatement		^ super ifStatement ==> [:nodes | self buildIf: nodes]! !!PPCompoParser methodsFor: 'grammar' stamp: 'lr 8/13/2011 21:09'!method	^ super method map: [ :methodNode :bodyNode | 		methodNode pragmas: bodyNode first.		methodNode body: bodyNode second.		self buildMethod: methodNode ]! !!PPCompoParser methodsFor: 'grammar' stamp: 'lr 3/1/2010 10:27'!methodDeclaration	^ super methodDeclaration ==> [ :nodes |		RBMethodNode 			selectorParts: nodes first			arguments: nodes second ]! !!PPCompoParser methodsFor: 'grammar' stamp: 'lr 8/14/2011 11:24'!methodSequence	^ super methodSequence map: [ :periodNodes1 :pragmaNodes1 :periodNodes2 :tempNodes :periodNodes3 :pragmaNodes2 :periodNodes4 :statementNodes |		Array			with: pragmaNodes1 , pragmaNodes2			with: (self build: tempNodes sequence: periodNodes1 , periodNodes2 , periodNodes3 , periodNodes4 , statementNodes) ]! !!PPCompoParser methodsFor: 'grammar' stamp: 'lr 12/6/2009 10:42'!parens	^ super parens map: [ :openToken :expressionNode :closeToken | expressionNode addParenthesis: (openToken start to: closeToken start) ]! !!PPCompoParser methodsFor: 'grammar' stamp: 'FerrandAnthony 2/11/2015 20:34'!pragma	^ super pragma ==> [ :nodes |		|inst|		inst := (RBPragmaNode selectorParts: nodes third first arguments: nodes third second).				self addComments: (nodes first comments) toNode: inst.		self addComments: (nodes last comments) toNode: inst.		inst			left: nodes first start;			right: nodes last start.		inst. ]! !!PPCompoParser methodsFor: 'grammar' stamp: 'lr 12/6/2009 10:42'!return	^ super return map: [ :token :expressionNode | RBReturnNode return: token start value: expressionNode ]! !!PPCompoParser methodsFor: 'grammar' stamp: 'lr 8/14/2011 11:14'!sequence	^ super sequence map: [ :tempNodes :periodNodes :statementNodes | self build: tempNodes sequence: periodNodes , statementNodes ]! !!PPCompoParser methodsFor: 'grammar' stamp: 'FerrandAnthony 2/18/2015 10:52'!variable	^ super variable ==> [ :token | (CompoRBVariableNode identifierToken: (token at: 2)) itself: (((token at: 1) = nil) not) ]! !!PPCompoParser methodsFor: 'grammar' stamp: 'PetrSpacek 11/11/2013 18:25'!whileStatement	^ super whileStatement ==> [:nodes | self buildWhile: nodes]! !!PPCompoParser methodsFor: 'grammar-literals' stamp: 'TestRunner 11/5/2009 11:41'!arrayLiteral	^ super arrayLiteral ==> [ :nodes | RBLiteralArrayNode startPosition: nodes first start contents: nodes second stopPosition: nodes last start isByteArray: false ]! !!PPCompoParser methodsFor: 'grammar-literals' stamp: 'TestRunner 11/5/2009 11:41'!arrayLiteralArray	^ super arrayLiteralArray ==> [ :nodes | RBLiteralArrayNode startPosition: nodes first start contents: nodes second stopPosition: nodes last start isByteArray: false ]! !!PPCompoParser methodsFor: 'grammar-literals' stamp: 'TestRunner 11/5/2009 11:41'!byteLiteral	^ super byteLiteral ==> [ :nodes | RBLiteralArrayNode startPosition: nodes first start contents: nodes second stopPosition: nodes last start isByteArray: true ]! !!PPCompoParser methodsFor: 'grammar-literals' stamp: 'TestRunner 11/5/2009 11:41'!byteLiteralArray	^ super byteLiteralArray ==> [ :nodes | RBLiteralArrayNode startPosition: nodes first start contents: nodes second stopPosition: nodes last start isByteArray: true ]! !!PPCompoParser methodsFor: 'grammar-literals' stamp: 'TestRunner 11/5/2009 11:28'!charLiteral	^ super charLiteral ==> [ :token | RBLiteralValueNode literalToken: (RBLiteralToken value: token value second start: token start stop: token stop) ]! !!PPCompoParser methodsFor: 'grammar-literals' stamp: 'TestRunner 11/5/2009 11:29'!falseLiteral	^ super falseLiteral ==> [ :token | RBLiteralValueNode literalToken: (RBLiteralToken value: false start: token start stop: token stop) ]! !!PPCompoParser methodsFor: 'grammar-literals' stamp: 'TestRunner 11/5/2009 11:29'!nilLiteral	^ super nilLiteral ==> [ :token | RBLiteralValueNode literalToken: (RBLiteralToken value: nil start: token start stop: token stop) ]! !!PPCompoParser methodsFor: 'grammar-literals' stamp: 'TestRunner 11/5/2009 13:33'!numberLiteral	^ super numberLiteral ==> [ :token | RBLiteralValueNode literalToken: (RBNumberLiteralToken value: (Number readFrom: token value) start: token start stop: token stop source: token value) ]! !!PPCompoParser methodsFor: 'grammar-literals' stamp: 'TestRunner 11/5/2009 11:30'!stringLiteral	^ super stringLiteral ==> [ :token | RBLiteralValueNode literalToken: (RBLiteralToken value: (self buildString: token value) start: token start stop: token stop) ]! !!PPCompoParser methodsFor: 'grammar-literals' stamp: 'lr 8/14/2011 12:24'!symbolLiteral	^ super symbolLiteral ==> [ :tokens | RBLiteralValueNode literalToken: (RBLiteralToken value: (self buildString: tokens last value) asSymbol start: tokens first start stop: tokens last stop) ]! !!PPCompoParser methodsFor: 'grammar-literals' stamp: 'TestRunner 11/5/2009 11:45'!symbolLiteralArray	^ super symbolLiteralArray ==> [ :token | RBLiteralValueNode literalToken: (RBLiteralToken value: (self buildString: token value) asSymbol start: token start stop: token stop) ]! !!PPCompoParser methodsFor: 'grammar-literals' stamp: 'TestRunner 11/5/2009 11:29'!trueLiteral	^ super trueLiteral ==> [ :token | RBLiteralValueNode literalToken: (RBLiteralToken value: true start: token start stop: token stop) ]! !!PPCompoParser methodsFor: 'grammar-literals-compo' stamp: 'PetrSpacek 11/7/2012 19:21'!collectionPortLiteral	^ super collectionPortLiteral ==> [ :nodes | self buildCollectionPort: nodes ]! !!PPCompoParser methodsFor: 'grammar-literals-compo' stamp: 'PetrSpacek 11/8/2012 13:23'!dereferenceLiteral	^ super dereferenceLiteral ==> [ :nodes | self buildDeferenceLiteral: nodes ]! !!PPCompoParser methodsFor: 'grammar-literals-compo' stamp: 'PetrSpacek 11/7/2012 19:13'!portAddressLiteral	^ super portAddressLiteral  ==> [ :nodes | self buildPortAddress: nodes ]! !!PPCompoParser methodsFor: 'grammar-literals-compo' stamp: 'FerrandAnthony 2/16/2015 15:02'!selfAddressLiteral	^ super selfAddressLiteral  ==> [ :nodes | self buildSelfAddress: nodes ]! !!PPCompoParser methodsFor: 'grammar-messages' stamp: 'lr 12/6/2009 10:39'!binaryExpression	^ super binaryExpression map: [ :receiverNode :messageNodes | self build: receiverNode messages: messageNodes ]! !!PPCompoParser methodsFor: 'grammar-messages' stamp: 'PetrSpacek 10/19/2012 15:15'!binaryExpressionLimited	^ super binaryExpressionLimited map: [ :receiverNode :messageNodes | self build: receiverNode messages: messageNodes ]! !!PPCompoParser methodsFor: 'grammar-messages' stamp: 'PetrSpacek 10/19/2012 15:09'!cascadeExpression	"^ super cascadeExpression map: [ :receiverNode :messageNodes | self build: receiverNode cascade: messageNodes ]"	^ super cascadeExpression map: [ :receiverNode  | self build: receiverNode cascade: nil ]! !!PPCompoParser methodsFor: 'grammar-messages' stamp: 'PetrSpacek 10/19/2012 15:09'!keywordExpression	"^ super keywordExpression map: [ :receiveNode :messageNode | self build: receiveNode messages: (Array with: messageNode) ]"	^ super keywordExpression map: [ :receiveNode  | self build: receiveNode messages: nil ]! !!PPCompoParser methodsFor: 'grammar-messages' stamp: 'PetrSpacek 11/13/2012 22:06'!unaryExpression	^ super unaryExpression ==> [:nodes |  self build: (nodes first) serviceInvocation: (nodes second)]! !!PPCompoParser methodsFor: 'grammar-messages' stamp: 'PetrSpacek 11/13/2012 22:10'!unarySubExpression	^ super unarySubExpression ==> [ :nodes | self build: (nodes at: 1) serviceInvocationBase: (nodes at: 2)]! !!PPCompoParser methodsFor: 'grammar-compo' stamp: 'PetrSpacek 11/7/2012 19:01'!architecture
	^ super architecture ==> [:nodes | self buildArchitecture: nodes]! !!PPCompoParser methodsFor: 'grammar-compo' stamp: 'PetrSpacek 10/19/2012 16:13'!compoExpr
	^ super compoExpr! !!PPCompoParser methodsFor: 'grammar-compo' stamp: 'PetrSpacek 10/19/2012 16:13'!compoIdent
	^ super compoIdent! !!PPCompoParser methodsFor: 'grammar-compo' stamp: 'PetrSpacek 11/7/2012 18:42'!connection
	^ super connection ==> [:nodes | self buildConnection: nodes]! !!PPCompoParser methodsFor: 'grammar-compo' stamp: 'FerrandAnthony 2/15/2015 09:51'!connectionAlt
	^ super connectionAlt ==> [:nodes | self buildConnectionAlt: nodes]! !!PPCompoParser methodsFor: 'grammar-compo' stamp: 'PetrSpacek 10/19/2012 16:13'!constraint
	^ super constraint! !!PPCompoParser methodsFor: 'grammar-compo' stamp: 'PetrSpacek 10/19/2012 23:23'!descriptor
	^ super descriptor ==> [:nodes | self buildDescriptor: nodes ]! !!PPCompoParser methodsFor: 'grammar-compo' stamp: 'PetrSpacek 11/7/2012 18:42'!disconnection
	^ super disconnection ==> [:nodes | self buildDisconnection: nodes]! !!PPCompoParser methodsFor: 'grammar-compo' stamp: 'PetrSpacek 11/7/2012 15:34'!exProvisions
	^ super exProvisions ==> [:nodes | self buildExProvisions: nodes]! !!PPCompoParser methodsFor: 'grammar-compo' stamp: 'PetrSpacek 11/7/2012 15:38'!exRequirements
	^ super exRequirements ==> [:nodes | self buildExRequirements: nodes]! !!PPCompoParser methodsFor: 'grammar-compo' stamp: 'PetrSpacek 11/7/2012 15:38'!inProvisions
	^ super inProvisions ==> [:nodes | self buildInProvisions: nodes]! !!PPCompoParser methodsFor: 'grammar-compo' stamp: 'PetrSpacek 11/7/2012 15:38'!inRequirements
	^ super inRequirements ==> [:nodes | self buildInRequirements: nodes]! !!PPCompoParser methodsFor: 'grammar-compo' stamp: 'PetrSpacek 11/7/2012 18:23'!interface
	^ super interface ==> [:nodes | self buildInterface: nodes]! !!PPCompoParser methodsFor: 'grammar-compo' stamp: 'PetrSpacek 11/7/2012 15:49'!port
	^ super port ==> [:nodes | self buildPort: nodes]! !!PPCompoParser methodsFor: 'grammar-compo' stamp: 'PetrSpacek 11/8/2012 13:33'!service
	^ super service ==> [:nodes | self buildService: nodes]! !!PPCompoParser methodsFor: 'grammar-compo' stamp: 'PetrSpacek 11/7/2012 18:12'!serviceSign
	^ super serviceSign ==> [:nodes | self buildServiceSign: nodes]! !!PPCompoParser methodsFor: 'grammar-compo' stamp: 'PetrSpacek 10/19/2012 16:13'!serviceSignsList
	^ super serviceSignsList! !!PPCompoParser methodsFor: 'grammar-blocks' stamp: 'lr 12/6/2009 10:37'!block	^ super block map: [ :leftToken :blockNode :rightToken | blockNode left: leftToken start; right: rightToken start ]! !!PPCompoParser methodsFor: 'grammar-blocks' stamp: 'lr 9/27/2009 12:42'!blockArgument	^ super blockArgument ==> #second! !!PPCompoParser methodsFor: 'grammar-blocks' stamp: 'lr 2/4/2010 11:42'!blockBody	^ super blockBody ==> [ :nodes | 		| result |		result := RBBlockNode arguments: nodes first first body: nodes last.		nodes first last isNil			ifFalse: [ result bar: nodes first last start ].		result ]! !!PPCompoParser methodsFor: 'accessing' stamp: 'PetrSpacek 10/19/2012 16:26'!startDeclaration	"Make the sequence node has a method node as its parent and that the source is set."	^ ([ :stream | stream collection ] asParser and , super startDeclaration) map: [ :source :node | 	    "build node here".	    node. ]! !!PPCompoParser methodsFor: 'accessing' stamp: 'lr 2/19/2010 08:07'!startExpression	"Make the sequence node has a method node as its parent and that the source is set."	^ ([ :stream | stream collection ] asParser and , super startExpression) map: [ :source :node | 		(RBMethodNode selector: #doIt body: node)			source: source.		(node statements size = 1 and: [ node temporaries isEmpty ])			ifTrue: [ node statements first ]			ifFalse: [ node ] ]! !!PPCompoParser methodsFor: 'accessing' stamp: 'lr 2/19/2010 08:20'!startMethod	"Make sure the method node has the source code properly set."		^ ([ :stream | stream collection ] asParser and , super startMethod)		map: [ :source :node | node source: source ]! !!PPCompoParser methodsFor: 'as yet unclassified' stamp: 'FerrandAnthony 2/15/2015 08:43'!buildRockConnection: nodes	|inst src dest|	src := nodes at: 2.	dest := nodes at: 4.		inst := CompoConnectionRockNode new		srcAddress: src;		destAddress: dest;		kind: nil ;		yourself.			^ inst.! !!PPCompoParser methodsFor: 'as yet unclassified' stamp: 'FerrandAnthony 2/15/2015 08:48'!buildRockConnectionAlt: nodes	|inst src dest|	src := nodes at: 1.	dest := nodes at: 3.		inst := CompoConnectionRockNode new		srcAddress: src;		destAddress: dest;		kind: nil ;		yourself.			^ inst.! !!PPCompoParser methodsFor: 'as yet unclassified' stamp: 'FerrandAnthony 2/15/2015 08:44'!rockConnection	^ super rockConnection ==> [:nodes | self buildRockConnection: nodes]! !!PPCompoParser methodsFor: 'as yet unclassified' stamp: 'FerrandAnthony 2/15/2015 09:51'!rockConnectionAlt	^ super rockConnectionAlt ==> [:nodes | self buildRockConnectionAlt: nodes]! !!PPCompoParser methodsFor: 'as yet unclassified' stamp: 'FerrandAnthony 2/11/2015 22:28'!smalltalkInjection	^ super smalltalkInjection  ==> [ :nodes |		|inst code|				inst := CompoSmalltalkInjectionNode new.		code := ''.				(nodes second) do: [ :item |			(item = '>!!')				ifTrue: [ code := code , '>'. ]				ifFalse: [ code := code , (item asString). ] 		].			inst code: code.		inst. ]! !PPCompoTokenParser initialize!