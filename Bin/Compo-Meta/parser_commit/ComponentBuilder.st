'From Pharo2.0 of 7 March 2013 [Latest update: #20619] on 9 February 2015 at 10:49:49 am'!Object subclass: #ComponentBuilder	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Meta'!!ComponentBuilder methodsFor: 'instance creation' stamp: 'Fred 6/20/2014 14:47'!createInstanceOf: desc	|pdDict ports inst architecture connsColl disconnsColl|	"create new component instance"	inst := desc new.		"initialize owner"	inst instVarNamed: #owner put: nil.		"initialize ports"		inst		instVarNamed: #ports		put: Dictionary new.			pdDict := self getAllDeclaredPortDescriptionsFrom: desc.	ports := inst instVarNamed: #ports.		pdDict keysAndValuesDo: [ :pn :pdColl |		|pInst pKind pVisibility pd|		"inheritance stuff"		pd := self applyPortInheritanceRulez: pdColl.				pKind := ((((((pd instVarNamed: #ports) at: #kind) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts) at: 1) instVarNamed: #owner.		pVisibility := ((((((pd instVarNamed: #ports) at: #visibility) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts) at: 1) instVarNamed: #owner.				pInst := (Smalltalk at: pKind) new.				self initPortInstance: pInst.		pInst instVarNamed: #owner put: inst.		((pInst instVarNamed: #ports) at: #name) cs__connectTo__par01: (pn defaultPort).		((pInst instVarNamed: #ports) at: #visibility) cs__connectTo__par01: (pVisibility defaultPort).				ports at: pn put: pInst.	].	"connect owner port of ports"	ports do: [ :p |		((p instVarNamed: #ports) at: #owner) cs__connectTo__par01: ((ports) at: #self).	].	"initialize connections"	"here we are going to create connections, we take into account INHERITANCE and first perform all disconnects and the connects, this way we specialize connections already created by super-descriptor of current descriptor."	connsColl := OrderedCollection new.	disconnsColl := OrderedCollection new.	architecture := self getAllDeclaredConnectionDescriptionsFrom:  desc.		architecture do: [ :cd | 		| array |		array := Array new: 5.		array at: 1 put: (((((((cd instVarNamed: #ports) at: #sourcePort) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts) at: 1) instVarNamed: #owner).		array at: 2 put: (((((((cd instVarNamed: #ports) at: #sourceComponent) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts) at: 1) instVarNamed: #owner).		array at: 3 put: (((((((cd instVarNamed: #ports) at: #destinationPort) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts) at: 1) instVarNamed: #owner).		array at: 4 put: (((((((cd instVarNamed: #ports) at: #destinationComponent) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts) at: 1) instVarNamed: #owner).		array at: 5 put: (((((((cd instVarNamed: #ports) at: #isDisconnection) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts) at: 1) instVarNamed: #owner).		(array at: 5)			ifTrue: [ disconnsColl add: array ]			ifFalse: [ 				"here we place first statements containing ''.new()'' as a substring"				(('*new()*' match: (array at: 2)) or: [ '*new()*' match: (array at: 4) ])					ifTrue: [ connsColl addFirst: array ]					ifFalse: [ connsColl addLast: array ] ] ].		"	disconnsColl		do: [ :conn | 			| srcP destP |			srcP := self getPortTargetCollection: (conn at: 1) on: (conn at: 2) forIntance: inst.				destP := self getPortTargetCollection: (conn at:3) on: (conn at: 4) forIntance: inst.			srcP do: [ :sp | sp cs__disconnect ] ].	"	connsColl		do: [ :conn | 			| srcP destP |			srcP := disconnsColl select: [ :disconn |				| b1 b2 b3 b4 |				b1 := ((disconn at: 1) = (conn at: 1)).				b2 := ((disconn at: 2) = (conn at: 2)).				b3 := ((disconn at: 3) = (conn at: 3)).				b4 := ((disconn at: 4) = (conn at: 4)).				((b1 and: [b2]) and: [b3]) and: b4.			].			(srcP size == 0) ifTrue: [ 				srcP := self getPortTargetCollection: (conn at: 1) on: (conn at: 2) forIntance: inst.				destP := self getPortTargetCollection: (conn at: 3) on: (conn at: 4) forIntance: inst.				srcP do: [ :sp | destP do: [ :dp | sp cs__connectTo__par01: dp ] ]			].	].	"return default port of the new instance"	^ (inst instVarNamed: #ports) at: #default. ! !!ComponentBuilder methodsFor: 'helpers' stamp: 'PetrSpacek 11/24/2013 20:22'!applyPortInheritanceRulez: aStackOfPortDescriptions 	"The argument [aStackOfPortDescriptions] contains a stack of PortDescriptions of the same port	as it was redefined in sub-descriptors. The top of the stack is the port description of the oldests parent.	This method applies the Compo-ports inheritance on the PortDescriptions given in the argument [aStackOfPortDescriptions]"	|res prev|	(aStackOfPortDescriptions size = 1)		ifTrue: [ res := aStackOfPortDescriptions pop. ]		ifFalse: [			res := aStackOfPortDescriptions pop.			prev := res.			[ aStackOfPortDescriptions isEmpty not ] whileTrue: [				|tr trIntf prevIntf|				tr := aStackOfPortDescriptions pop.				prev := tr.				trIntf := self getInterfaceOfPortDescription: tr.				prevIntf := self getInterfaceOfPortDescription: prev.				(prevIntf isArray) ifTrue: [					(trIntf isArray)						ifTrue: [ self setInterfaceOfPortDescription: res interface: ((Set withAll: (prevIntf,trIntf)) asArray).  ]						ifFalse: [  self shouldBeImplemented .  ]				].				"important"				prev := tr.			].		 ].		^ res.! !!ComponentBuilder methodsFor: 'helpers' stamp: 'PetrSpacek 11/24/2013 18:35'!getAllDeclaredConnectionDescriptionsFrom: aDesc	"returns a dictionary of connection descriptions"	|pdDict currentDesc cd pn|	(aDesc isKindOf: (Smalltalk at: #Descriptor))		ifFalse: [ self error: ((aDesc name asString) , ' has to be a descriptor') ].			pdDict := Dictionary new.		currentDesc := aDesc.		[ currentDesc ~= (Smalltalk at: #Object) ]		whileTrue: [ 						(((((currentDesc instVarNamed: #ports) at: #architecture) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts)				do: [ :atomicport |					cd := (atomicport  instVarNamed: #owner) instVarNamed: #owner. "get the current connection description"					pn := cd identityHash.					pdDict at: pn put: cd.				].						currentDesc := currentDesc superclass.			(currentDesc == (Smalltalk at: #Class))				ifTrue: [ currentDesc :=  (Smalltalk at: #Component)].		].			^ pdDict.! !!ComponentBuilder methodsFor: 'helpers' stamp: 'PetrSpacek 11/24/2013 17:37'!getAllDeclaredPortDescriptionsFrom: aDesc	"returns a dictionary of stacks"	|pdDict currentDesc pd pn|	(aDesc isKindOf: (Smalltalk at: #Descriptor))		ifFalse: [ self error: ((aDesc name asString) , ' has to be a descriptor') ].			pdDict := Dictionary new.		currentDesc := aDesc.		[ currentDesc ~= (Smalltalk at: #Object) ]		whileTrue: [ 						(((((currentDesc instVarNamed: #ports) at: #ports) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts)				do: [ :atomicport |					pd := (atomicport  instVarNamed: #owner) instVarNamed: #owner. "get the current port description"					pn := ((((((pd instVarNamed: #ports) at: #name) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts) at: 1) instVarNamed: #owner.					(pdDict includesKey: pn) ifFalse: [ pdDict at: pn put: (Stack new) ].					(pdDict at: pn) push: pd.				].			"cs__connectTo__par01: ((((pd instVarNamed: #ports) at: #default) instVarNamed: #ports) at: #default)"						currentDesc := currentDesc superclass.			(currentDesc == (Smalltalk at: #Class))				ifTrue: [ currentDesc :=  (Smalltalk at: #Component)].		].			^ pdDict.! !!ComponentBuilder methodsFor: 'helpers' stamp: 'PetrSpacek 11/23/2013 09:03'!getAttr: symb ofPortDesc: aPD	^ ((((self getPort: symb of: aPD) instVarNamed: #ports) at: #connectedPorts) at: 1) instVarNamed: #owner.! !!ComponentBuilder methodsFor: 'helpers' stamp: 'PetrSpacek 11/24/2013 19:56'!getInterfaceOfPortDescription: pd	^ ((((((pd instVarNamed: #ports) at: #interface) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts) at: 1) instVarNamed: #owner.	! !!ComponentBuilder methodsFor: 'helpers' stamp: 'PetrSpacek 11/23/2013 08:35'!getPort: nameSymb of: inst 	^ (inst instVarNamed: #ports) at: nameSymb .! !!ComponentBuilder methodsFor: 'helpers' stamp: 'FerrandAnthony 2/9/2015 10:01'!getPortTargetCollection: port on: comp forIntance: inst	|nodes tokens res connectedPorts|		res := OrderedCollection new.	((Smalltalk at: #PPCompoGrammar) matchesLiteral:  comp) 		ifTrue: [			res add: (LiteralAtomicPort newNamed: 'default' owner: comp role: #provided visibility: #external interface: #* isCollectionPort: false) ]		ifFalse: [				"argument [comp] might be either a symbol or expression, we have to parse it.	for now we support only these three forms Case1: identifier Case2: identifier[expr] Case3: (Printer new) like expressions"	nodes := (Smalltalk at: #PPCompoGrammar) parseExpression: comp.		tokens := (((((nodes at: 3) at:1) at:2) at:1) at: 1) at: 1.		(tokens isArray)		"Cases2&3"		ifTrue: [			(tokens first value = '(')				"Case3"				ifTrue: [					|expr errorStr defPortOfNewComp|					errorStr := 'For now, we support only simple create expression in connection statements, i.e. ''Component.new()''.'.					expr := tokens second second first first.					expr first isArray ifTrue: [self error: errorStr].					(expr second first value = 'new') ifFalse: [self error: errorStr].					"here we create an instance, new returns default port!!"					defPortOfNewComp := (Smalltalk at: (expr first value asSymbol)) newC.					"here we setup owner of the new component"					((defPortOfNewComp instVarNamed: #owner) isKindOf: (Smalltalk at: #Component))						ifTrue: [(defPortOfNewComp instVarNamed: #owner) instVarNamed: #owner put: inst]						ifFalse: [(defPortOfNewComp instVarNamed: #owner) owner: inst ].										res add: defPortOfNewComp .				]				"Case2"				ifFalse: [					|pOwner idx|					connectedPorts := (self getPort: (tokens first value asSymbol) of: inst).					idx := [(((tokens at: 3) at: 2) at: 1) value asNumber]								on: Error								do: [ self error: 'For now, we support only number literals in collection-port address in connection statements, i.e. ''portName[10]''.'].					.					(connectedPorts isKindOf: #AtomicPort)						ifTrue: [							connectedPorts := connectedPorts instVarNamed: #connectedPorts.							pOwner := (connectedPorts at: idx) instVarNamed: #owner.						]						ifFalse: [							connectedPorts := (self getPort: #connectedPorts of: connectedPorts) instVarNamed: #connectedPorts.							pOwner := ((connectedPorts at: idx) instVarNamed: #owner) instVarNamed: #owner.						].										res add: (self getPort: port of: pOwner).				].		]		"Case1"		ifFalse: [			((tokens value asSymbol) = #self)				ifTrue: [ res add: (self getPort: (port asSymbol) of: inst ) ]				ifFalse: [					connectedPorts := (self getPort: (tokens value asSymbol) of: inst).					(connectedPorts isKindOf: (Smalltalk at: #AtomicPort))						ifTrue: [ connectedPorts := connectedPorts instVarNamed: #connectedPorts ]						ifFalse: [							connectedPorts := (self getPort: #connectedPorts of: connectedPorts) instVarNamed: #connectedPorts.							connectedPorts := connectedPorts collect: [:p |												| tempOwner |												tempOwner := p instVarNamed: #owner.												(tempOwner isKindOf: (Smalltalk at: #Port)) ifTrue: [tempOwner] ifFalse: [p]].						].					connectedPorts do: [:p |						|pOwner|						pOwner := p instVarNamed: #owner.						res add: (self getPort: port of: pOwner ).					].			].		]		].			^ res asArray.! !!ComponentBuilder methodsFor: 'helpers' stamp: 'PetrSpacek 11/24/2013 17:40'!initPortInstance: p	| pports |	p instVarNamed: #ports put: (Dictionary new).	pports :=p instVarNamed: #ports.		pports at: #default put: (AtomicPort newNamed: #default owner: p 											role: #provided visibility: #external interface: #*											isCollectionPort: false).	pports at: #args put: (AtomicPort newNamed: #args owner: p 											role: #required visibility: #external interface: #*											isCollectionPort: true).	pports at: #self put: (AtomicPort newNamed: #self  owner: p 											role: #provided visibility: #internal interface: #*											isCollectionPort: false).	pports at: #super put: (AtomicPort newNamed: #super  owner: p 											role: #provided visibility: #internal interface: #*											isCollectionPort: false).	pports at: #owner put: (AtomicPort newNamed: #owner  owner: p 											role: #required visibility: #external interface: #*											isCollectionPort: false).	pports at: #connectedPorts put: (AtomicPort newNamed: #connectedPorts  owner: p 											role: #required visibility: #external interface: #*											isCollectionPort: true).	pports at: #delegatedPorts put: (AtomicPort newNamed: #delegatedPorts  owner: p 											role: #required visibility: #external interface: #*											isCollectionPort: true).	pports at: #name put: (AtomicPort newNamed: #name  owner: p 											role: #required visibility: #internal interface: #*											isCollectionPort: false).	pports at: #interface put: (AtomicPort newNamed: #interface  owner: p 											role: #required visibility: #internal interface: #*											isCollectionPort: false).	pports at: #visibility put: (AtomicPort newNamed: #visibility  owner: p 											role: #required visibility: #internal interface: #*											isCollectionPort: false).! !!ComponentBuilder methodsFor: 'helpers' stamp: 'PetrSpacek 11/24/2013 19:57'!setInterfaceOfPortDescription: pd interface: intf	((((((pd instVarNamed: #ports) at: #interface) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts) at: 1 put: (intf defaultPort) ).	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ComponentBuilder class	instanceVariableNames: ''!!ComponentBuilder class methodsFor: 'instance creation' stamp: 'PetrSpacek 11/24/2013 18:53'!newInstanceOf: desc 	^ self new createInstanceOf: desc.! !