Object subclass: #CompoMetaBootstrap	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Meta'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CompoMetaBootstrap class	instanceVariableNames: ''!!CompoMetaBootstrap class methodsFor: 'helpers' stamp: 'PetrSpacek 10/25/2012 17:21'!generateGetterOf: aNameSymb in: class	|sb|	sb := TextStream on: ''.		sb		nextPutAll: 'get';		nextPutAll: (aNameSymb asString capitalized);		lf; tab;		nextPutAll: '^ ';		nextPutAll: aNameSymb asString;		nextPutAll: ' invokeStd_selector: #copy'.		class compile: sb contents  classified: #'default-interface'.		! !!CompoMetaBootstrap class methodsFor: 'helpers' stamp: 'PetrSpacek 10/23/2012 15:47'!generateSetterOf: aNameSymb in: class	|sb|	sb := TextStream on: ''.		sb		nextPutAll: 'set';		nextPutAll: (aNameSymb asString capitalized);		nextPut: $:;		space;		nextPutAll: 'val';				lf; tab; 	nextPutAll: '|temp|';		lf; tab; 	nextPutAll: 'val ifNil: [^self].';		lf; tab; 	nextPutAll: 'temp:= val copy.';		lf; tab; 	nextPutAll: '"temp owner: (ObjectOwnerFake new owner: self)."';		lf; tab; 	nextPutAll: 'temp owner: (self).';		lf; tab;	nextPutAll: aNameSymb asString; nextPutAll: ' connectTo_port: (temp).'.		class compile: sb contents  classified: #'default-interface'.		! !!CompoMetaBootstrap class methodsFor: 'component-services-strings' stamp: 'PetrSpacek 11/5/2012 11:52'!component_getDescriptor_string^ 'getDescriptor	^ self class	"<primitive: 111>"	"self primitiveFailed."'! !!CompoMetaBootstrap class methodsFor: 'component-services-strings' stamp: 'PetrSpacek 10/25/2012 18:22'!component_getOwner_string^ 'getOwner	^ owner'.! !!CompoMetaBootstrap class methodsFor: 'component-services-strings' stamp: 'PetrSpacek 10/25/2012 18:23'!component_getPortNamed_string^ 'getPortNamed: aNameSymb	|p |	p := [self instVarAt: (self getDescriptor instVarIndexFor: aNameSymb)] on: Error do: [self error: (''I don''''t have port named '', aNameSymb asString)].	p isExternal ifFalse: [self error: (''I don''''t have port named '', aNameSymb asString)].	^ p.'! !!CompoMetaBootstrap class methodsFor: 'component-services-strings' stamp: 'PetrSpacek 10/25/2012 18:23'!component_getPorts_string^ 'getPorts	|ar|	ar := Array new: (self getDescriptor instSize).	1 to: (self getDescriptor instSize) do: [:i | ar at: i put: (self instVarAt: i)].	ar := ar reject: [:port | (port isInternal) or: [ ((port isKindOf: (Smalltalk at: #Port)) or: [port isKindOf: (Smalltalk at: #AtomicPort)]) not ]].	^ ar.'	! !!CompoMetaBootstrap class methodsFor: 'port-services-strings' stamp: 'PetrSpacek 10/29/2012 11:22'!externalProvidedPort_connectTo_port_string^ 'connectTo_port: aPort	"external provided port of a component can be coonected to the external provided port of an internal component of the component"	|errorMsg|	errorMsg := ''I can be connected to an external provided port of an internal component owned by my owner''.	"(aPort owner getOwner = self owner) ifFalse: [ self error: errorMsg]."	((aPort isExternal) and: [aPort isProvided ]) ifFalse: [ self error: errorMsg ].	(aPort isKindOf: (Smalltalk at: #ExternalProvidedPort))		ifTrue: [			connectedPorts connectTo_port: (aPort instVarNamed: #control).			(aPort instVarNamed: #connectedPorts) connectTo_port: control.		]		ifFalse: [			connectedPorts connectTo_port: aPort.		].'! !!CompoMetaBootstrap class methodsFor: 'port-services-strings' stamp: 'PetrSpacek 10/29/2012 11:24'!externalRequiredPort_connectTo_port_string^ 'connectTo_port: aPort	"external required port of a component can be coonected to the external provided port of another component, which is not an internal component of my owner"	| errorMsg |	errorMsg := ''I can be connected to an external provided port of a component, which is not an internal component of my owner''.	"(aPort owner getOwner = self owner) ifFalse: [ self error: errorMsg]."	((aPort isExternal) and: [aPort isProvided ]) ifFalse: [ self error: errorMsg ].	(aPort isKindOf: (Smalltalk at: #ExternalProvidedPort))		ifTrue: [			connectedPorts connectTo_port: (aPort instVarNamed: #control).			(aPort instVarNamed: #connectedPorts) connectTo_port: control.		]		ifFalse: [			connectedPorts connectTo_port: aPort.		].		.'! !!CompoMetaBootstrap class methodsFor: 'port-services-strings' stamp: 'PetrSpacek 10/29/2012 11:22'!internalProvidedPort_connectTo_port_string^ 'connectTo_port: aPort	"internal provided port of a component cannot be connected to any other port, other ports can be connected to me"	|errorMsg|	errorMsg := ''I cannot be connected to any port, only they can be connected to me''.	"(aPort owner getOwner = self owner) ifFalse: [ self error: errorMsg]."	self error: errorMsg .'! !!CompoMetaBootstrap class methodsFor: 'port-services-strings' stamp: 'PetrSpacek 10/29/2012 11:22'!internalRequiredPort_connectTo_port_string^ 'connectTo_port: aPort	"internal required port of a component can be coonected to the external provided port of an internal component of the component"	|errorMsg|	errorMsg := ''I can be connected to an external provided port of an internal component owned by my owner''.	"(aPort owner getOwner = self owner) ifFalse: [ self error: errorMsg]."	((aPort isExternal) and: [aPort isProvided ]) ifFalse: [ self error: errorMsg ].	(aPort isKindOf: (Smalltalk at: #ExternalProvidedPort))		ifTrue: [			connectedPorts connectTo_port: (aPort instVarNamed: #control).			(aPort instVarNamed: #connectedPorts) connectTo_port: control.		]		ifFalse: [			connectedPorts connectTo_port: aPort.		].		.'! !!CompoMetaBootstrap class methodsFor: 'port-services-strings' stamp: 'PetrSpacek 10/26/2012 19:38'!port_connectTo_port_string^ 'connectTo_port: aPort	self subclassResponsibility.'! !!CompoMetaBootstrap class methodsFor: 'port-services-strings' stamp: 'PetrSpacek 11/8/2012 18:28'!port_disconnect_string^ 'disconnect: idx	"performs bidirect disconnect"	|opositeIDX opositeOwner|
	"first we have to find to which index are we connected in port connected on index [idx]"	opositeOwner := ((connectedPorts instVarNamed: #connectedPorts) at: idx) instVarNamed: #owner.	(opositeOwner isKindOf: (Smalltalk at: #Port))		ifTrue: [			|cP|			cP := (opositeOwner instVarNamed: #connectedPorts) instVarNamed: #connectedPorts.			cP withIndexDo: [ :p :i | (p getOwner == self) ifTrue: [opositeIDX := i]]. 			cP := (opositeOwner instVarNamed: #connectedPorts).			cP disconnect: opositeIDX.			connectedPorts disconnect: idx.		]		ifFalse: [connectedPorts disconnect: idx]'.! !!CompoMetaBootstrap class methodsFor: 'port-services-strings' stamp: 'PetrSpacek 11/14/2012 22:37'!port_printOn_string
^ 'printOn: aStream

	|desc kind|
	desc := owner getDescriptor.
	kind := ''Unknown''.
	(desc inheritsFrom: (Smalltalk at: #ComponentDescriptor))
		ifTrue: [
			((desc printString findString: '' class'') = 0)
				ifTrue: [ kind := desc printString]
				ifFalse: [ kind := ''ComponentDescriptor''].
		]
		ifFalse: [
			(desc inheritsFrom: ((Smalltalk at: #ProtoObject) class))
				ifTrue: [ kind := ''AtomicComponent'']
				ifFalse: [ kind := desc printString]
		].

	aStream
		nextPut: $(;
		nextPutAll: ((self isExternal) ifTrue: [''ext''] ifFalse: [''int'']);
		nextPut: $-;
		nextPutAll: ((self isRequired) ifTrue: [''req''] ifFalse: [''prov'']);
		nextPutAll: '' port #'';
		nextPutAll: (self getName);
		nextPutAll: '' ownedBy anInstOf '''''';
		nextPutAll: kind.
	aStream
		nextPut: $'';
		nextPut: $).'.! !!CompoMetaBootstrap class methodsFor: 'port-services-strings' stamp: 'PetrSpacek 11/15/2012 00:49'!providedPort_invokeStd_string^ 'invokeStd_selector: aSelector args: args index: idx	| result sender selector wasMatch|	result := nil.	selector := aSelector.	wasMatch := false.		"checks if the <selector> service is accessible throught this port"	"respects the special interface <#*> (any service) "	(self getInterface isArray)		ifTrue: [			self getInterface do: [:sel | 				((selector asString , ''*'') match: (sel asString))					ifTrue: [						wasMatch := true.						args ifNotNil: [							(sel keywords size == args size)								ifTrue: [ selector := sel. ]						].					]. 			].		].		((self getInterface == #*) and: [wasMatch == false])		ifTrue: [ 			|defSels|			defSels := owner class allMethodsInCategory: ''default-interface''.			defSels do: [ :sel |			((selector asString , ''*'') match: (sel asString))					ifTrue: [						wasMatch := true.						((args isNil not) and: [args isEmpty not])							ifTrue: [								(sel keywords size == args size) ifTrue: [ selector := sel. ]						].					]. 			].		].		(wasMatch)		ifFalse: [ self error: (''Service '', selector , '' is not accessible through this port'')].		(owner respondsTo: selector)		ifTrue: [			(args isNil)				ifTrue: [result := owner perform: selector]				ifFalse: [result := owner perform: selector withArguments: args].		]		ifFalse: [			(self isConnected)				"Here comes the magic :D"				ifTrue: [					(idx isNil)						ifTrue: [							result := ServiceInvocationResult new: (connectedPorts connectedPortsCount).							connectedPorts withIndexDo: [ :port :i |								(port getOwner isKindOf: (Smalltalk at: #Port))									ifTrue: [										|conP size|										conP := port getOwner instVarNamed: #connectedPorts.										size := (conP select: [:p | (p instVarNamed: #owner) = self]) size.										(size > 0)											"magic is calling invokeStd_selector: #invokeStd_selector:.... !!!!!! "											ifTrue: [result at: i put: (port invokeStd_selector: #invokeStd_selector:args:index: args: { selector. args. idx. } index: nil sender: connectedPorts)]											ifFalse: [result at: i put: (port invokeStd_selector: selector args: args index: nil sender: connectedPorts)].									]									ifFalse: [ result at: i put: (port invokeStd_selector: selector args: args index: nil sender: connectedPorts)].							].						]						ifFalse: [							|port|							port := connectedPorts at: idx.							(port getOwner isKindOf: (Smalltalk at: #Port))								ifTrue: [									|conP|									conP := port getOwner instVarNamed: #connectedPorts.									(conP includes: self)										ifTrue: [result := (port invokeStd_selector: #invokeStd_selector:args:index args: { selector. args. idx. } index: nil sender: connectedPorts)]										ifFalse: [result := (port invokeStd_selector: selector args: args index: nil sender: connectedPorts)].								]								ifFalse: [ result := (port invokeStd_selector: selector args: args index: nil sender: connectedPorts)].						].				]				ifFalse: [ self error: ''Lookup failed and the port is not delegated!!''] .		].		"unwrap result if possible"	((result isServiceInvocationResult) and: [result size = 1]) ifTrue: [result := result at: 1].		"hack to prevent the escape of the component identity"	(result isServiceInvocationResult)		ifTrue: [ result withIndexDo: [:r :i | (r == self owner) ifTrue: [ result at: i put: self ]]]		ifFalse: [ (result == self owner) ifTrue: [ result := self ] ].			^ result.'.! !!CompoMetaBootstrap class methodsFor: 'port-services-strings' stamp: 'PetrSpacek 11/8/2012 23:19'!requiredPort_invokeStd_string^ 'invokeStd_selector: selector args: args index: idx	| result |	result := nil.	(self isConnected)		"Here comes the magic :D"		ifTrue: [			(idx isNil)				ifTrue: [					result := ServiceInvocationResult new: (connectedPorts connectedPortsCount).					(connectedPorts instVarNamed: #connectedPorts) withIndexDo: [ :port :i |						(port getOwner isKindOf: (Smalltalk at: #Port))							ifTrue: [								|conP size|								conP := (port getOwner instVarNamed: #connectedPorts) instVarNamed: #connectedPorts .								size := (conP select: [:p | (p instVarNamed: #owner) = self]) size.								(size > 0)									ifTrue: [result at: i put: (port invokeStd_selector: #invokeStd_selector:args:index: args: { selector. args. idx. } index: nil sender: connectedPorts)]									ifFalse: [result at: i put: (port invokeStd_selector: selector args: args index: nil sender: connectedPorts)].							]							ifFalse: [ result at: i put: (port invokeStd_selector: selector args: args index: nil sender: connectedPorts)].					].				]				ifFalse: [					|port|					port := (connectedPorts instVarNamed: #connectedPorts) at: idx.					(port getOwner isKindOf: (Smalltalk at: #Port))						ifTrue: [							|conP|							conP := port getOwner instVarNamed: #connectedPorts.							(conP includes: self)								ifTrue: [result := (port invokeStd_selector: #invokeStd_selector:args:index args: { selector. args. idx. } index: nil sender: connectedPorts ) ]								ifFalse: [result := (port invokeStd_selector: selector args: args index: nil sender: connectedPorts)].						]						ifFalse: [ result := (port invokeStd_selector: selector args: args index: nil sender: connectedPorts)].				].		]		ifFalse: [ self error: ''Port is not connected!!''] .			"unwrap result if possible"	((result isServiceInvocationResult) and: [result size = 1]) ifTrue: [result := result at: 1].		"hack to prevent the escape of the component identity"	(result isServiceInvocationResult)		ifTrue: [ result withIndexDo: [:r :i | (r == self owner) ifTrue: [ result at: i put: self ]]]		ifFalse: [ (result == self owner) ifTrue: [ result := self ] ].			^ result.'! !!CompoMetaBootstrap class methodsFor: 'bootstrap' stamp: 'PetrSpacek 11/3/2013 23:51'!cleanup	self		removeClasses:			#(#InternalRequiredPort #InternalProvidedPort #ExternalRequiredPort #ExternalProvidedPort #ProvidedPort #RequiredPort #Port #PortDescription #ConnectionDescription #Constraint).				! !!CompoMetaBootstrap class methodsFor: 'bootstrap' stamp: 'PetrSpacek 11/4/2013 00:02'!create_ConnectionDescription_descriptor	| temp clsComponent clsComponentDescriptor clsTemp |	clsComponentDescriptor := Smalltalk at: #Descriptor.	clsComponent := Smalltalk at: #Component.	"here we create the [ConnectionDescription] descriptor  necessary for creating other descriptors"	[ Smalltalk removeClassNamed: #ConnectionDescription ]		on: Error		do: [  ].	clsComponentDescriptor newNamed: #ConnectionDescription.	clsTemp := Smalltalk at: #ConnectionDescription.	clsTemp addInstVarNamed: #sourceComponent.	clsTemp addInstVarNamed: #sourcePort.	clsTemp addInstVarNamed: #destinationComponent.	clsTemp addInstVarNamed: #destinationPort.	clsTemp addInstVarNamed: #isDisconnection.	clsTemp addInstVarNamed: #kind.	clsTemp addInstVarNamed: #main.	self generateSetterOf: #sourceComponent in: clsTemp.	self generateSetterOf: #sourcePort in: clsTemp.	self generateSetterOf: #destinationComponent in: clsTemp.	self generateSetterOf: #destinationPort in: clsTemp.	self generateSetterOf: #isDisconnection in: clsTemp.	self generateSetterOf: #kind in: clsTemp.	self generateGetterOf: #sourceComponent in: clsTemp.	self generateGetterOf: #sourcePort in: clsTemp.	self generateGetterOf: #destinationComponent in: clsTemp.	self generateGetterOf: #destinationPort in: clsTemp.	self generateGetterOf: #isDisconnection in: clsTemp.	self generateGetterOf: #kind in: clsTemp.	clsTemp		addDescriptionOfPortNamed: #main		interface:			#(#getSourceComponent #getSourcePort #getDestinationComponent #getDestinationPort #getKind #setSourceComponent: #setSourcePort: #setDestinationComponent: #setDestinationPort: #setKind: #getIsDisconnection #setIsDisconnection:)		role: #provided		visibility: #external		injection: #NULL		kind: #AtomicPort		isCollectionPort: false.	clsTemp		addDescriptionOfPortNamed: #sourceComponent		interface: #*		role: #required		visibility: #internal		injection: #NULL		kind: #AtomicPort		isCollectionPort: false.	clsTemp		addDescriptionOfPortNamed: #sourcePort		interface: #*		role: #required		visibility: #internal		injection: #NULL		kind: #AtomicPort		isCollectionPort: false.	clsTemp		addDescriptionOfPortNamed: #destinationComponent		interface: #*		role: #required		visibility: #internal		injection: #NULL		kind: #AtomicPort		isCollectionPort: false.	clsTemp		addDescriptionOfPortNamed: #destinationPort		interface: #*		role: #required		visibility: #internal		injection: #NULL		kind: #AtomicPort		isCollectionPort: false.	clsTemp		addDescriptionOfPortNamed: #isDisconnection		interface: #*		role: #required		visibility: #internal		injection: #NULL		kind: #AtomicPort		isCollectionPort: false.	clsTemp		addDescriptionOfPortNamed: #kind		interface: #*		role: #required		visibility: #internal		injection: #NULL		kind: #AtomicPort		isCollectionPort: false.	clsTemp category: clsComponent category! !!CompoMetaBootstrap class methodsFor: 'bootstrap' stamp: 'PetrSpacek 11/4/2013 00:01'!create_PortDescription_descriptor	| temp clsComponent clsComponentDescriptor clsTemp |	clsComponentDescriptor := Smalltalk at: #Descriptor.	clsComponent := Smalltalk at: #Component.	"here we create the [PortDescription] descriptor  necessary for creating other descriptors"	[ Smalltalk removeClassNamed: #PortDescription ]		on: Error		do: [  ].	clsComponentDescriptor newNamed: #PortDescription.	clsTemp := Smalltalk at: #PortDescription.	clsTemp addInstVarNamed: #name.	clsTemp addInstVarNamed: #role.	clsTemp addInstVarNamed: #visibility.	clsTemp addInstVarNamed: #interface.	clsTemp addInstVarNamed: #injection.	clsTemp addInstVarNamed: #kind.	clsTemp addInstVarNamed: #main.	clsTemp addInstVarNamed: #isCollectionPort.	self generateSetterOf: #name in: clsTemp.	self generateSetterOf: #role in: clsTemp.	self generateSetterOf: #visibility in: clsTemp.	self generateSetterOf: #interface in: clsTemp.	self generateSetterOf: #injection in: clsTemp.	self generateSetterOf: #kind in: clsTemp.	self generateSetterOf: #isCollectionPort in: clsTemp.	self generateGetterOf: #name in: clsTemp.	self generateGetterOf: #role in: clsTemp.	self generateGetterOf: #visibility in: clsTemp.	self generateGetterOf: #interface in: clsTemp.	self generateGetterOf: #injection in: clsTemp.	self generateGetterOf: #kind in: clsTemp.	self generateGetterOf: #isCollectionPort in: clsTemp.	clsTemp		addDescriptionOfPortNamed: #main		interface:			#(#setName: #getName #setRole: #setKind: #getKind #getRole #setInterface: #getInterface #setVisibility: #getVisibility #getIsCollectionPort #setIsCollectionPort: #getInjection)		role: #provided		visibility: #external		injection: #NULL		kind: #AtomicPort		isCollectionPort: false.	clsTemp		addDescriptionOfPortNamed: #name		interface: #*		role: #required		visibility: #internal		injection: #NULL		kind: #AtomicPort		isCollectionPort: false.	clsTemp		addDescriptionOfPortNamed: #role		interface: #*		role: #required		visibility: #internal		injection: #NULL		kind: #AtomicPort		isCollectionPort: false.	clsTemp		addDescriptionOfPortNamed: #visibility		interface: #*		role: #required		visibility: #internal		injection: #NULL		kind: #AtomicPort		isCollectionPort: false.	clsTemp		addDescriptionOfPortNamed: #interface		interface: #*		role: #required		visibility: #internal		injection: #NULL		kind: #AtomicPort		isCollectionPort: false.	clsTemp		addDescriptionOfPortNamed: #kind		interface: #*		role: #required		visibility: #internal		injection: #NULL		kind: #AtomicPort		isCollectionPort: false.	clsTemp		addDescriptionOfPortNamed: #injection		interface: #*		role: #required		visibility: #internal		injection: #NULL		kind: #AtomicPort		isCollectionPort: false.	clsTemp		addDescriptionOfPortNamed: #isCollectionPort		interface: #*		role: #required		visibility: #internal		injection: #NULL		kind: #AtomicPort		isCollectionPort: false.	clsTemp category: clsComponent category! !!CompoMetaBootstrap class methodsFor: 'bootstrap' stamp: 'PetrSpacek 11/4/2013 00:02'!create_Port_descriptor
	| temp clsComponent clsComponentDescriptor clsTemp |
	clsComponentDescriptor := Smalltalk at: #Descriptor.
	clsComponent := Smalltalk at: #Component.	"here we create the [Port] descriptor, its instances will differ from other components to avoid circular definition of ports, i.e. port beign a clsComponent made from ports "
	[ Smalltalk removeClassNamed: #Port ]
		on: Error
		do: [  ].
	clsComponentDescriptor newNamed: #Port.
	clsTemp := Smalltalk at: #Port.
	clsTemp addInstVarNamed: #portName.
	clsTemp addInstVarNamed: #interface.
	clsTemp addInstVarNamed: #control.
	clsTemp addInstVarNamed: #myOwner.
	clsTemp addInstVarNamed: #connectedPorts.
	
	"[Port] inherits the default provided port from [Component]"
	clsTemp
		addDescriptionOfPortNamed: #myOwner
		interface: #(#getDescriptor #getPorts #getPortNamed:)
		role: #required
		visibility: #external
		injection: #NULL
		kind: #AtomicPort
		isCollectionPort: false.
		
	clsTemp
		addDescriptionOfPortNamed: #connectedPorts
		interface:
			#(#getName #getInterface #getOwner #connectTo_port: #isConnected #disconnect #disconnect: #isCollectionPort #isRequired #isProvided #isAtomic #isInternal #isExternal #invokeMeta_selector: #invokeMeta_selector:args: #invokeMeta_selector:args:index: #invokeStd_selector: #invokeStd_selector:args: #invokeStd_selector:args:index:)
		role: #required
		visibility: #external
		injection: #NULL
		kind: #AtomicPort
		isCollectionPort: true.
		
	clsTemp
		addDescriptionOfPortNamed: #control
		interface:
			#(#getName #getInterface #getOwner #connectTo_port: #isConnected #disconnect #disconnect: #isRequired #isProvided #isCollectionPort #isAtomic #isInternal #isExternal #invokeMeta_selector: #invokeMeta_selector:args: #invokeMeta_selector:args:index: #invokeStd_selector: #invokeStd_selector:args: #invokeStd_selector:args:index:)
		role: #provided
		visibility: #external
		injection: #NULL
		kind: #AtomicPort
		isCollectionPort: false.
		
	clsTemp
		addDescriptionOfPortNamed: #portName
		interface: #*
		role: #required
		visibility: #internal
		injection: #NULL
		kind: #AtomicPort
		isCollectionPort: false.
		
	clsTemp
		addDescriptionOfPortNamed: #interface
		interface: #*
		role: #required
		visibility: #internal
		injection: #NULL
		kind: #AtomicPort
		isCollectionPort: false.
		
	temp := Character lf asString , Character tab asString.
	clsTemp compile: 'getName' , temp , '^ portName invokeStd_selector: #copy.' classified: #'default-interface'.
	clsTemp compile: 'getInterface' , temp , '^ interface invokeStd_selector: #copy.' classified: #'default-interface'.
	clsTemp compile: 'getOwner' , temp , '^ owner' classified: #'default-interface'.
	clsTemp
		compile: 'invokeMeta_selector: selector' , temp , '^ self invokeMeta_selector: selector args: {} index: nil.'
		classified: #'default-interface'.
	clsTemp
		compile:
			'invokeMeta_selector: selector args: args' , temp , '^ self invokeMeta_selector: selector args: args index: nil.'
		classified: #'default-interface'.
	clsTemp
		compile:
			'invokeMeta_selector: selector args: args index: idx' , temp
				, '^ (myself invokeStd_selector: selector args: args index: idx).'
		classified: #'default-interface'.
	clsTemp
		compile: 'invokeStd_selector: selector' , temp , '^ self invokeStd_selector: selector args: {} index: nil.'
		classified: #'default-interface'.
	clsTemp
		compile:
			'invokeStd_selector: selector args: args' , temp , '^ self invokeStd_selector: selector args: args index: nil.'
		classified: #'default-interface'.
	clsTemp
		compile: 'invokeStd_selector: selector args: args index: idx' , temp , 'self subclassResponsibility'
		classified: #'default-interface'.
	clsTemp compile: self port_connectTo_port_string classified: #'default-interface'.
	clsTemp compile: 'isConnected' , temp , '^ connectedPorts isConnected.' classified: #'default-interface'.
	clsTemp compile: 'isCollectionPort' , temp , '^ connectedPorts isCollectionPort.' classified: #'default-interface'.
	clsTemp compile: 'isAtomic' , temp , '^ false.' classified: #'default-interface'.
	clsTemp
		compile: 'disconnect' , temp , '1 to: (connectedPorts connectedPortsCount) do: [:i | self disconnect: i].'
		classified: #'default-interface'.
	clsTemp compile: self port_disconnect_string classified: #'default-interface'.
	clsTemp compile: 'isRequired' , temp , 'self subclassResponsibility.' classified: #'default-interface'.
	clsTemp compile: 'isProvided' , temp , 'self subclassResponsibility.' classified: #'default-interface'.
	clsTemp compile: 'isInternal' , temp , 'self subclassResponsibility.' classified: #'default-interface'.
	clsTemp compile: 'isExternal' , temp , 'self subclassResponsibility.' classified: #'default-interface'.	
	clsTemp compile: (self port_printOn_string) classified: #'private'.	
	
	"a port should behave as a clsComponent, but we need to break the circle definiton, i.e. port is a clsComponent made of ports"	"clsTemp compile: ('getPorts' , temp , 'self error: ''Hack to break the circle definiton, i.e. port is a clsComponent made of ports'' ' ).
	clsTemp compile: ('getPortNamed: n' , temp , 'self error: ''Hack to break the circle definiton, i.e. port is a clsComponent made of ports'' ' ).
	"
	clsTemp category: clsComponent category! !!CompoMetaBootstrap class methodsFor: 'bootstrap' stamp: 'PetrSpacek 11/5/2012 11:48'!create_subdescriptors_of_Port	|clsTemp temp|		"[Port]'s subdescriptors"	clsTemp := (Smalltalk at: #Port).	clsTemp subdescriptor:  #ProvidedPort providedPorts: {} requiredPorts: {} internallyProvidedPorts: {} internallyRequiredPorts: {} architecture: {} category: (clsTemp category).	clsTemp subdescriptor:  #RequiredPort providedPorts: {} requiredPorts: {} internallyProvidedPorts: {} internallyRequiredPorts: {} architecture: {} category: (clsTemp category).		clsTemp := (Smalltalk at: #RequiredPort).	clsTemp subdescriptor:  #InternalRequiredPort providedPorts: {} requiredPorts: {} internallyProvidedPorts: {} internallyRequiredPorts: {} architecture: {} category: (clsTemp category).	clsTemp subdescriptor:  #ExternalRequiredPort providedPorts: {} requiredPorts: {} internallyProvidedPorts: {} internallyRequiredPorts: {} architecture: {} category: (clsTemp category).	temp := Character lf asString , Character tab asString.	clsTemp compile: (self requiredPort_invokeStd_string) classified: #'default-interface'.		clsTemp := (Smalltalk at: #InternalRequiredPort).	clsTemp compile: ('isRequired' , temp , '^ true.') classified: #'default-interface'.	clsTemp compile: ('isProvided' , temp , '^ false.') classified: #'default-interface'.	clsTemp compile: ('isInternal' , temp , '^ true.') classified: #'default-interface'.	clsTemp compile: ('isExternal' , temp , '^ false.') classified: #'default-interface'.	clsTemp compile: (self internalRequiredPort_connectTo_port_string) classified: #'default-interface'.		clsTemp := (Smalltalk at: #ExternalRequiredPort).	clsTemp compile: ('isRequired' , temp , '^ true.') classified: #'default-interface'.	clsTemp compile: ('isProvided' , temp , '^ false.') classified: #'default-interface'.	clsTemp compile: ('isInternal' , temp , '^ false.') classified: #'default-interface'.	clsTemp compile: ('isExternal' , temp , '^ true.') classified: #'default-interface'.	clsTemp compile: (self externalRequiredPort_connectTo_port_string) classified: #'default-interface'.		clsTemp := (Smalltalk at: #ProvidedPort).		clsTemp subdescriptor:  #InternalProvidedPort providedPorts: {} requiredPorts: {} internallyProvidedPorts: {} internallyRequiredPorts: {} architecture: {} category: (clsTemp category).	clsTemp subdescriptor:  #ExternalProvidedPort providedPorts: {} requiredPorts: {} internallyProvidedPorts: {} internallyRequiredPorts: {} architecture: {} category: (clsTemp category).		temp := Character lf asString , Character tab asString.	clsTemp compile: (self providedPort_invokeStd_string) classified: #'default-interface'.		clsTemp := (Smalltalk at: #InternalProvidedPort).	clsTemp compile: ('isRequired' , temp , '^ false.') classified: #'default-interface'.	clsTemp compile: ('isProvided' , temp , '^ true.') classified: #'default-interface'.	clsTemp compile: ('isInternal' , temp , '^ true.') classified: #'default-interface'.	clsTemp compile: ('isExternal' , temp , '^ false.') classified: #'default-interface'.	clsTemp compile: (self internalProvidedPort_connectTo_port_string) classified: #'default-interface'.		clsTemp := (Smalltalk at: #ExternalProvidedPort).	clsTemp compile: ('isRequired' , temp , '^ false.') classified: #'default-interface'.	clsTemp compile: ('isProvided' , temp , '^ true.') classified: #'default-interface'.	clsTemp compile: ('isInternal' , temp , '^ false.') classified: #'default-interface'.	clsTemp compile: ('isExternal' , temp , '^ true.') classified: #'default-interface'.	clsTemp compile: (self externalProvidedPort_connectTo_port_string) classified: #'default-interface'.! !!CompoMetaBootstrap class methodsFor: 'bootstrap' stamp: 'PetrSpacek 11/3/2013 23:53'!systemChanges
	| temp clsComponent clsComponentDescriptor clsTemp |
	"clear a bit"
	self cleanup.
		"remake class [Component]"	self removeClasses: #(#Component).	
	Object
		subclass: #Component
		instanceVariableNames: 'default myself ssuper owner ownedPrimitives'
		classVariableNames: ''
		poolDictionaries: ''
		category: 'Compo-Meta'.
		
	"the [Component class] inherits from [Object class] but we need a kind of multiple inheritace from [ComponentDescriptor] and [Object class], so we change superdescriptor of [Component class] to [ComponentDescriptor] and copy methods from [Object class] into the [Component class] "
	clsComponent := Smalltalk at: #Component.
	clsComponentDescriptor := Smalltalk at: #Descriptor.
	
	clsComponent class superclass: clsComponentDescriptor.
	clsComponent class setFormat: clsComponentDescriptor format.
	
	"following solves issue that in this line expression (Component isKindOf: clsComponentDescriptor) returns false"
	temp := clsComponent class.
	temp instVarAt: (temp class instVarIndexFor: #thisClass) put: (self createNewComponent: temp).
	"re-register new class in global dictionary"
	Smalltalk at: #Component put: temp soleInstance.
	clsComponent := temp soleInstance.
	temp := nil.	
		
	"and we copy methods from [Object class] to [Component class]"
	Object class methodDict do: [ :m | clsComponent class compile: m getSource classified: 'object class protocol' ].	
		
	"superclass for [ComponentDescriptor class] should be [Component class]"
	clsComponentDescriptor class superclass: clsComponent class.
	
	"here we create the [PortDescription] descriptor  necessary for creating other descriptors"
	self create_PortDescription_descriptor.
	
	"here we create the [ConnectionDescription] descriptor  necessary for creating other descriptors"
	self create_ConnectionDescription_descriptor.
	
	"here we define the structurer of the [Component] descriptor"
	clsComponent
		addDescriptionOfPortNamed: #default
		interface: #*
		role: #provided
		visibility: #external
		injection: #NULL
		kind: #Port
		isCollectionPort: false.
	clsComponent
		addDescriptionOfPortNamed: #myself
		interface: #*
		role: #provided
		visibility: #internal
		injection: #NULL
		kind: #Port
		isCollectionPort: false.
	clsComponent
		addDescriptionOfPortNamed: #ssuper
		interface: #*
		role: #provided
		visibility: #internal
		injection: #NULL
		kind: #Port
		isCollectionPort: false.
		
		
	clsComponent compile: self component_getPorts_string classified: 'default-interface'.
	clsComponent compile: self component_getPortNamed_string classified: 'default-interface'.
	clsComponent compile: self component_getDescriptor_string classified: 'default-interface'.
	clsComponent compile: self component_getOwner_string classified: 'default-interface'.
	
	"here we create the [Port] descriptor, its instances will differ from other components to avoid circular definition of ports, i.e. port beign a clsComponent made from ports "
	self create_Port_descriptor.
	self create_subdescriptors_of_Port.
	
	"setup [ComponentDescriptor]"
	clsComponentDescriptor setup.
	
	"create [Constraint]"
	clsComponent
		subdescriptor: #Constraint
		providedPorts: {}
		requiredPorts: {(#context -> #*)}
		internallyProvidedPorts: {}
		internallyRequiredPorts: {}
		architecture: {}
		category: 'Compo-Meta'! !!CompoMetaBootstrap class methodsFor: 'private' stamp: 'PetrSpacek 11/3/2013 23:55'!createNewComponent: metaClass	| new instSizeNew instSizeOld cd |	new := metaClass basicNew.	cd := Smalltalk at: #Descriptor.	instSizeNew := cd instSize.	instSizeOld := Object class instSize.	1 to: instSizeNew do: [ :i | 		i < (instSizeOld + 1)			ifTrue: [ new instVarAt: i put: ((Smalltalk at: #Component) instVarAt: i) ]			ifFalse: [ new instVarAt: i put: nil ] ].			new		instVarAt: (cd instVarIndexFor: #ports)		put:			(AtomicPort				newNamed: #ports				owner: new				role: #required				visibility: #internal				interface:					#(#setName: #getName #setRole: #getIsCollectionPort #setIsCollectionPort:  #setKind: #getKind #getRole #setInterface: #getInterface #setVisibility: #getVisibility #getInjection)				injection: #NULL				isCollectionPort: true).	new		instVarAt: (cd instVarIndexFor: #architecture)		put:			(AtomicPort				newNamed: #architecture				owner: new				role: #required				visibility: #internal				interface:					#(#getSourceComponent #getSourcePort #getDestinationComponent #getDestinationPort #getKind #setSourceComponent: #setSourcePort: #setDestinationComponent: #setDestinationPort: #setKind: #getIsDisconnection)				injection: #NULL				isCollectionPort: true).	new		instVarAt: (cd instVarIndexFor: #myself)		put:			(AtomicPort				newNamed: #myself				owner: new				role: #provided				visibility: #internal				interface: #(#getDescriptor #getPorts #getPortNamed:)				injection: #NULL				isCollectionPort: false).	new		instVarAt: (cd instVarIndexFor: #default)		put:			(AtomicPort				newNamed: #default				owner: new				role: #provided				visibility: #external				interface: #(#getDescriptor #getPorts #getPortNamed:)				injection: #NULL				isCollectionPort: false).	new		instVarAt: (cd instVarIndexFor: #ssuper)		put:			(AtomicPort				newNamed: #ssuper				owner: new				role: #provided				visibility: #internal				interface: #(#getDescriptor #getPorts #getPortNamed:)				injection: #NULL				isCollectionPort: false).	new		instVarAt: (cd instVarIndexFor: #services)		put:			(AtomicPort				newNamed: #services				owner: new				role: #required				visibility: #internal				interface: #(#getDescriptor #getPorts #getPortNamed:)				injection: #NULL				isCollectionPort: true).	new instVarAt: (cd instVarIndexFor: #sourceCode) put: #NULL.	new instVarAt: (cd instVarIndexFor: #owner) put: nil.	new instVarAt: (cd instVarIndexFor: #ownedPrimitives) put: IdentitySet new.	^ new	"return new class"! !!CompoMetaBootstrap class methodsFor: 'private' stamp: 'PetrSpacek 10/25/2012 16:41'!removeClasses: array	array do: [:symb | [Smalltalk removeClassNamed: symb] on: Error do: []].! !Object subclass: #AtomicPort	instanceVariableNames: 'connectedPorts delegatedPorts owner interface name role visibility isCollectionPort'	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Meta'!!AtomicPort methodsFor: 'default-interface' stamp: 'PetrSpacek 11/13/2012 21:04'!connectTo_port: aPort	((isCollectionPort not) and: [self isConnected])		ifTrue: [self error: 'Port is not a collection-port and it is already connected!!'].	"An atomic-provided-external port can only be connected to (delegated to) an atomic-provided-external port of an internal component"	(self isProvided and: [self isExternal]) ifTrue: [		(((aPort isProvided) and: [aPort isExternal]) "and: [self owner == aPort owner getOwner]")  ifFalse: [self error: 'An atomic-provided-external port can only be connected to (delegated to) an atomic-provided-external port of an internal component'].	].	"An atomic-provided-internal port cannot be connected to any other atomic port"	(self isProvided and: [self isInternal]) ifTrue: [		self error: 'An atomic-provided-internal port cannot be connected to any other atomic port'.	].	"An atomic-required-external port of a component can only be connected to an atomic-provided-external port of another component, which is not an internal component of any component"	"An atomic-required-external port of an internal component can only be connected to (delegated to) an atomic-required-external port or connected to atomic-internal-provided port of the owner of the internal component"	(self isRequired and: [self isExternal]) ifTrue: [				"am I an external-required-port of an internal component of the aPort's owner'"		"(self owner getOwner == aPort owner)			ifTrue: [				(((aPort isRequired) and: [aPort isExternal]) or: [(aPort isProvided) and: [aPort isInternal]])					ifFalse: [ self error: 'An atomic-required-external port of an internal component can only be connected to (delegated to) an atomic-required-external port or connected to atomic-internal-provided port of the owner of the internal component']			]			ifFalse: [				(self owner == aPort owner getOwner)					ifTrue: [ self error: 'An atomic-required-external port of a component can only be connected to an atomic-provided-external port of another component, which is not an internal component of any component' ]					ifFalse: [						((aPort isProvided) and: [aPort isExternal])							ifTrue: [ (aPort owner getOwner == self owner getOwner) ifFalse: [ self error: 'An atomic-required-external port of a component can only be connected to an atomic-provided-external port of another component, which is not an internal component of any component' ] ]							ifFalse: [ self error: 'An atomic-required-external port of a component can only be connected to an atomic-provided-external port of another component, which is not an internal component of any component' ]								]			]."	].	"An atomic-required-internal port of a component can only be connected to an atomic-provided-external port of an internal component of the component"	(self isRequired and: [self isInternal]) ifTrue: [		(((aPort isProvided) and: [aPort isExternal]) "and: [self owner == aPort owner getOwner]") ifFalse: [self error: 'An atomic-required-internal port of a component can only be connected to an atomic-provided-external port of an internal component of the component'].	].		(connectedPorts includes: aPort) ifFalse: [ connectedPorts add: aPort ].! !!AtomicPort methodsFor: 'default-interface' stamp: 'Fred 2/10/2015 22:44'!cs__connectTo__par01: anAtomicPort	(isCollectionPort not			and: [self isConnected])		ifTrue: [self error: 'Port is not a collection-port and it is already connected!!'].	(connectedPorts includes: anAtomicPort )				ifFalse: [connectedPorts add: anAtomicPort]			! !!AtomicPort methodsFor: 'default-interface' stamp: 'PetrSpacek 11/24/2013 18:50'!cs__disconnect	connectedPorts removeAll! !!AtomicPort methodsFor: 'default-interface' stamp: 'PetrSpacek 11/24/2013 18:50'!cs__disconnect_par01: idx	connectedPorts removeAt: idx.! !!AtomicPort methodsFor: 'default-interface' stamp: 'PetrSpacek 12/15/2013 22:03'!cs__invoke__par01: serviceInvoc par02: isMetaCall	|result|		"required port"	(self isRequired) ifTrue: [ 		(isMetaCall)		ifTrue: [			result := serviceInvoc sendTo: self.		]		ifFalse: [  		((serviceInvoc index isNil not ) and: [ serviceInvoc index  > 0 ])			ifTrue: [ result := (connectedPorts at: (serviceInvoc index)) cs__invoke__par01: serviceInvoc  par02: false.]			ifFalse: [				result := ServiceInvocationResult new: connectedPorts size.				connectedPorts withIndexDo: [ :port :idx | result at: idx put: (port cs__invoke__par01: serviceInvoc  par02: false) ].			].		].	].	"provided port"		(self isProvided ) ifTrue: [ 		(owner isKindOf: (Smalltalk at: #Component))			ifTrue: [ result := (serviceInvoc arguments at: 1) sendTo: owner  ]			ifFalse: [ 				(serviceInvoc selector = #new) ifTrue: [ serviceInvoc setSelector: #newC. ].				(delegatedPorts size =  0)					ifTrue: [						(isMetaCall)							ifTrue: [ self error: 'The & operator cannot be used on an atomic port!!' ]							ifFalse: [ result := serviceInvoc sendTo: owner ].					]					ifFalse: [						(serviceInvoc index isNil not)							ifTrue: [ result :=  (delegatedPorts at: (serviceInvoc index)) cs__invoke__par01: serviceInvoc par02: false.  ]							ifFalse: [ 								result := ServiceInvocationResult new: delegatedPorts size.								delegatedPorts withIndexDo: [ :port :idx | result at: idx put: (port cs__invoke__par01: serviceInvoc par02: false) ].							].					].			].					].		"unwrap result if possible"	((result isServiceInvocationResult) and: [result size = 1]) ifTrue: [result := result at: 1].	((result isServiceInvocationResult) and: [result size = 0]) ifTrue: [result := 0].	"hack to prevent the escape of the component identity"	(result isServiceInvocationResult)		ifTrue: [ result withIndexDo: [:r :i | (r == self owner) ifTrue: [ result at: i put: self ]]]		ifFalse: [ (result == self owner) ifTrue: [ result := self ] ].			^ result.		! !!AtomicPort methodsFor: 'default-interface' stamp: 'PetrSpacek 12/15/2013 22:08'!cs__isConnected	^ connectedPorts isEmpty not! !!AtomicPort methodsFor: 'default-interface' stamp: 'PetrSpacek 11/25/2013 01:37'!cs__size	^ connectedPorts size.! !!AtomicPort methodsFor: 'default-interface' stamp: 'PetrSpacek 10/20/2012 20:29'!disconnect	connectedPorts removeAll! !!AtomicPort methodsFor: 'default-interface' stamp: 'PetrSpacek 11/8/2012 17:40'!disconnect: idx	connectedPorts removeAt: idx.! !!AtomicPort methodsFor: 'default-interface' stamp: 'PetrSpacek 10/22/2012 15:28'!getInterface	^ interface.! !!AtomicPort methodsFor: 'default-interface' stamp: 'PetrSpacek 10/20/2012 20:27'!getName	^ name! !!AtomicPort methodsFor: 'default-interface' stamp: 'PetrSpacek 10/25/2012 18:10'!getOwner	^ owner! !!AtomicPort methodsFor: 'default-interface' stamp: 'PetrSpacek 10/25/2012 17:10'!invokeMeta_selector: selector	^ self invokeMeta_selector: selector args: {} index: nil.! !!AtomicPort methodsFor: 'default-interface' stamp: 'PetrSpacek 10/25/2012 17:10'!invokeMeta_selector: selector args: anArgsArray	^ self invokeMeta_selector: selector args: anArgsArray index: nil.! !!AtomicPort methodsFor: 'default-interface' stamp: 'PetrSpacek 10/25/2012 17:10'!invokeMeta_selector: selector args: anArgsArray index: indexOfConnectedPort 	^ self error: 'I am an atomic port, meta-calls on me are forbiden'.! !!AtomicPort methodsFor: 'default-interface' stamp: 'PetrSpacek 10/25/2012 17:09'!invokeStd_selector: aName	^ self invokeStd_selector: aName args: nil index: nil. ! !!AtomicPort methodsFor: 'default-interface' stamp: 'PetrSpacek 10/25/2012 17:09'!invokeStd_selector: aName args: anArgsArray	^ self invokeStd_selector: aName args: anArgsArray index: nil. ! !!AtomicPort methodsFor: 'default-interface' stamp: 'PetrSpacek 11/8/2012 22:51'!invokeStd_selector: selector args: anArgsArray index: indexOfConnectedPort 	^ self invokeStd_selector: selector args: anArgsArray  index: indexOfConnectedPort  sender: self.! !!AtomicPort methodsFor: 'default-interface' stamp: 'PetrSpacek 10/29/2012 15:20'!isAtomic	^ true.! !!AtomicPort methodsFor: 'default-interface' stamp: 'PetrSpacek 11/9/2012 15:41'!isCollectionPort	^ isCollectionPort.! !!AtomicPort methodsFor: 'default-interface' stamp: 'PetrSpacek 10/20/2012 20:27'!isConnected	^ connectedPorts isEmpty not! !!AtomicPort methodsFor: 'default-interface' stamp: 'PetrSpacek 10/20/2012 20:24'!isExternal	^ (visibility = #external)! !!AtomicPort methodsFor: 'default-interface' stamp: 'PetrSpacek 10/20/2012 20:24'!isInternal	^ (visibility = #internal)! !!AtomicPort methodsFor: 'default-interface' stamp: 'PetrSpacek 10/20/2012 20:24'!isProvided	^ (role = #provided)! !!AtomicPort methodsFor: 'default-interface' stamp: 'PetrSpacek 10/20/2012 20:25'!isRequired	^ (role == #required)! !!AtomicPort methodsFor: 'initialization' stamp: 'PetrSpacek 11/6/2013 22:03'!initialize	connectedPorts := OrderedCollection new.	delegatedPorts  := OrderedCollection new.	! !!AtomicPort methodsFor: 'helpers' stamp: 'PetrSpacek 10/24/2012 11:44'!connectedPortsCount	^ connectedPorts size.! !!AtomicPort methodsFor: 'private' stamp: 'PetrSpacek 11/15/2012 01:51'!invokeStd_selector: aSelector args: anArgsArray index: indexOfConnectedPort sender: sendP	|result wasMatch selector|		"IMPORTANT"	selector := aSelector.		"checks if the <selector> service is accessible throught this port"	"respects the special interface <#*> (any service) "	wasMatch := false.	(self getInterface isArray)		ifTrue: [			self getInterface do: [:sel | 				((selector asString , '*') match: (sel asString))					ifTrue: [						wasMatch := true.						anArgsArray ifNotNil: [							(sel keywords size == anArgsArray size)								ifTrue: [ selector := sel. ]						].					]. 			].		].		((self getInterface == #*) and: [wasMatch == false])		ifTrue: [			(self isProvided)				ifTrue: [ 					|defSels|					defSels := owner class allMethodsInCategory: 'default-interface'.					defSels do: [ :sel |					((selector asString , '*') match: (sel asString))						ifTrue: [							wasMatch := true.							((anArgsArray isNil not) and: [anArgsArray isEmpty not])								ifTrue: [									(sel keywords size == anArgsArray size) ifTrue: [ selector := sel. ]								].						]. 					].				].						(self isRequired) ifTrue: [ wasMatch := true ].		].		(wasMatch)		ifFalse: [ self error: ('Service ', selector , ' is not accessible through this port')].	result := nil.	"if we're disconnect required port then error, else invoke"	(self isRequired) ifTrue: [		(self isConnected)			ifTrue: [				(indexOfConnectedPort isNil)					"broadcast invocation"					ifTrue: [						result := ServiceInvocationResult new: connectedPorts size.						connectedPorts withIndexDo: [ :port :idx | result at: idx put: (port invokeStd_selector: selector args: anArgsArray index: nil sender: self)].					]					"concrete invocation"					ifFalse: [												result := (connectedPorts at: indexOfConnectedPort) invokeStd_selector: selector args: anArgsArray index: nil sender: self.					].			]			ifFalse: [ self error: 'Port not connected!!' ].						( result notNil and: [ result == connectedPorts ] )			ifTrue: [ result := nil. "prevent returning connector identity"] .	].	"if we're provided port then lookup the service or delegate"	(self isProvided) ifTrue: [		(owner respondsTo: (selector asSymbol))			ifTrue: [								((anArgsArray isNil) or: [anArgsArray isEmpty])					ifTrue: [						(self name == #ssuper)							ifTrue: [result:= (owner perform: (selector asSymbol)  withArguments: (Array new:0) inSuperclass: (owner superclass))]							ifFalse: [result := (owner perform: (selector asSymbol))].					]					ifFalse: [						"hack to deal with contraint and the specific behavior of the port [context]"						((sendP owner isKindOf: (Smalltalk at: #Port))						and: [(sendP owner instVarNamed: #owner) isKindOf: (Smalltalk at: #Constraint)])							ifTrue: [								((selector asSymbol) == #invokeStd_selector:args:index:)									ifTrue: [										((anArgsArray first) == #getPorts) ifTrue: [ anArgsArray at: 1 put: #getPortsEx ].										((anArgsArray first)  == #getPortNamed:) ifTrue: [ anArgsArray at: 1 put: #getPortNamedEx: ].									].							].																		(self name == #ssuper)							ifTrue: [result:= (owner perform: (selector asSymbol)  withArguments: anArgsArray inSuperclass: (owner superclass))]							ifFalse: [result := (owner perform: (selector asSymbol) withArguments: anArgsArray)].					].			]			ifFalse: [				(self isConnected)					ifTrue: [						"do broadcast invocation"						result := ServiceInvocationResult new: connectedPorts size.						connectedPorts withIndexDo: [ :port :idx | result at: idx put: (port invokeStd_selector: selector args: anArgsArray index: nil sender: self)].					]			ifFalse: [ self error: 'Lookup failed and the port is not delegated!!' ].			].	].	"unwrap result if possible"	((result isServiceInvocationResult) and: [result size = 1]) ifTrue: [result := result at: 1].	"hack to prevent the escape of the component identity"	(result isServiceInvocationResult)		ifTrue: [ result withIndexDo: [:r :i | (r == self owner) ifTrue: [ result at: i put: self ]]]		ifFalse: [ (result == self owner) ifTrue: [ result := self ] ].			^ result.! !!AtomicPort methodsFor: 'accessing' stamp: 'PetrSpacek 10/22/2012 15:28'!interface: anObject	interface := anObject! !!AtomicPort methodsFor: 'accessing' stamp: 'PetrSpacek 11/9/2012 15:58'!isCollectionPort: bool	isCollectionPort := bool.! !!AtomicPort methodsFor: 'accessing' stamp: 'PetrSpacek 10/20/2012 20:15'!name	^ name! !!AtomicPort methodsFor: 'accessing' stamp: 'PetrSpacek 10/20/2012 20:14'!name: anObject	name := anObject! !!AtomicPort methodsFor: 'accessing' stamp: 'PetrSpacek 10/20/2012 20:14'!owner	^ owner! !!AtomicPort methodsFor: 'accessing' stamp: 'PetrSpacek 10/20/2012 20:14'!owner: anObject	owner := anObject! !!AtomicPort methodsFor: 'accessing' stamp: 'PetrSpacek 10/20/2012 20:15'!role	^ role! !!AtomicPort methodsFor: 'accessing' stamp: 'PetrSpacek 10/20/2012 20:15'!role: anObject	role := anObject! !!AtomicPort methodsFor: 'accessing' stamp: 'PetrSpacek 10/20/2012 20:15'!visibility	^ visibility! !!AtomicPort methodsFor: 'accessing' stamp: 'PetrSpacek 10/20/2012 20:15'!visibility: anObject	visibility := anObject! !!AtomicPort methodsFor: 'printing' stamp: 'PetrSpacek 11/11/2013 13:41'!printOn: aStream	aStream		nextPutAll: 'an ';		nextPutAll: ((self isExternal) ifTrue: ['ext'] ifFalse: ['int']);		nextPut: $-;		nextPutAll: ((self isRequired) ifTrue: ['req'] ifFalse: ['prov']);		nextPutAll: ' AtomicPort named ';		nextPut: $';		nextPutAll: (self getName);		nextPut: $'.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AtomicPort class	instanceVariableNames: ''!!AtomicPort class methodsFor: 'as yet unclassified' stamp: 'PetrSpacek 10/20/2012 20:17'!new	self error: 'Use newNamed:owner:role:visibility:injection:'! !!AtomicPort class methodsFor: 'as yet unclassified' stamp: 'PetrSpacek 11/4/2013 01:38'!newNamed: aName owner: component role: r visibility: v interface: interf isCollectionPort: isC 	^ (self basicNew initialize)		name: aName;		owner: component;		role: r;		visibility: v;		interface: interf;		isCollectionPort: isC;		yourself.! !Object subclass: #ObjectOwnerFake	instanceVariableNames: 'ownedPrimitives owner'	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Meta'!!ObjectOwnerFake methodsFor: 'accessing' stamp: 'PetrSpacek 10/22/2012 21:58'!getOwner	^ owner! !!ObjectOwnerFake methodsFor: 'accessing' stamp: 'PetrSpacek 10/22/2012 21:12'!owner	^ owner! !!ObjectOwnerFake methodsFor: 'accessing' stamp: 'PetrSpacek 10/22/2012 21:13'!owner: o	owner := o.! !!ObjectOwnerFake methodsFor: 'as yet unclassified' stamp: 'PetrSpacek 10/22/2012 21:32'!initialize 	ownedPrimitives := IdentitySet new.! !Class subclass: #Descriptor	instanceVariableNames: 'ports owner code'	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Meta'!!Descriptor methodsFor: 'compo-private' stamp: 'PetrSpacek 11/25/2013 00:11'!isKindOf: cls	((cls == (Smalltalk at: #Component)) or: [ (cls == (Smalltalk at: #Descriptor)) ])		ifTrue: [ ^ true ]		ifFalse: [ ^ super isKindOf: cls ].! !!Descriptor methodsFor: 'compo-private' stamp: 'PetrSpacek 11/23/2013 08:02'!newC	^ ComponentBuilder 		newInstanceOf: self.! !!Descriptor methodsFor: 'default-interface' stamp: 'PetrSpacek 11/25/2013 00:11'!cs__addConnDescription__par01: cd	! !!Descriptor methodsFor: 'default-interface' stamp: 'PetrSpacek 11/25/2013 00:11'!cs__addPortDescription__par01: pd	! !!Descriptor methodsFor: 'default-interface' stamp: 'PetrSpacek 11/25/2013 00:11'!cs__addService	! !!Descriptor methodsFor: 'default-interface' stamp: 'PetrSpacek 11/25/2013 00:11'!cs__getDescribedConns	! !!Descriptor methodsFor: 'default-interface' stamp: 'PetrSpacek 11/25/2013 00:11'!cs__getDescribedPorts	! !!Descriptor methodsFor: 'default-interface' stamp: 'PetrSpacek 11/25/2013 00:11'!cs__getService__par01: selector par02: arity	! !!Descriptor methodsFor: 'default-interface' stamp: 'PetrSpacek 11/25/2013 00:11'!cs__new	^ ((self newC "compo vm primitive call")).! !!Descriptor methodsFor: 'default-interface' stamp: 'PetrSpacek 11/25/2013 00:11'!cs__newNamed__par01: name par02: superDesc	! !!Descriptor methodsFor: 'default-interface' stamp: 'PetrSpacek 11/25/2013 00:11'!cs__removeConnDescription__par01: cd	! !!Descriptor methodsFor: 'default-interface' stamp: 'PetrSpacek 11/25/2013 00:11'!cs__removePortDescription__par01: pd	! !!Descriptor methodsFor: 'default-interface' stamp: 'PetrSpacek 11/25/2013 00:11'!cs__removeService__par01: selector par02: arity	! !!Descriptor methodsFor: 'Component protocol' stamp: 'PetrSpacek 11/25/2013 00:10'!cs__getDescriptor	^ ((self primitive_getDescriptor "compo vm primitive call")).! !!Descriptor methodsFor: 'Component protocol' stamp: 'PetrSpacek 11/25/2013 00:10'!cs__getIdentityHash	^ ((self primitive_getIdentityHash "compo vm primitive call")).! !!Descriptor methodsFor: 'Component protocol' stamp: 'PetrSpacek 11/25/2013 00:10'!cs__getOwner	^ ((self primitive_getOwner "compo vm primitive call")).! !!Descriptor methodsFor: 'Component protocol' stamp: 'PetrSpacek 11/25/2013 00:45'!cs__getPortNamed__par01: nameS 	^ ((self primitive_getPortNamed: nameS "compo vm primitive call")).! !!Descriptor methodsFor: 'Component protocol' stamp: 'PetrSpacek 11/25/2013 00:10'!cs__getPorts	^ ((self primitive_getPorts "compo vm primitive call")).! !!Descriptor methodsFor: 'Component protocol' stamp: 'PetrSpacek 11/25/2013 00:10'!primitive_getDescriptor	^ (self class instVarNamed: #ports) at: #default.! !!Descriptor methodsFor: 'Component protocol' stamp: 'PetrSpacek 11/25/2013 00:10'!primitive_getIdentityHash	^ self identityHash .! !!Descriptor methodsFor: 'Component protocol' stamp: 'PetrSpacek 11/25/2013 00:10'!primitive_getOwner	((self instVarNamed: #owner) isKindOf: (Smalltalk at: #Component))		ifTrue: [ ^ ((self instVarNamed: #owner) instVarNamed: #ports) at: #default ]		ifFalse: [ ^ (self instVarNamed: #owner) defaultPort ].! !!Descriptor methodsFor: 'Component protocol' stamp: 'PetrSpacek 11/25/2013 00:10'!primitive_getPortNamed: name	^ (self instVarNamed: #ports) at: name.! !!Descriptor methodsFor: 'Component protocol' stamp: 'PetrSpacek 11/25/2013 00:10'!primitive_getPorts	^ (self instVarNamed: #ports).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Descriptor class	instanceVariableNames: 'ports owner code'!!Descriptor class methodsFor: 'compo-private' stamp: 'PetrSpacek 11/25/2013 00:11'!isKindOf: cls	((cls == (Smalltalk at: #Component)) or: [ (cls == (Smalltalk at: #Descriptor)) ])		ifTrue: [ ^ true ]		ifFalse: [ ^ super isKindOf: cls ].! !!Descriptor class methodsFor: 'Component protocol' stamp: 'PetrSpacek 11/25/2013 00:10'!cs__getDescriptor	^ ((self primitive_getDescriptor "compo vm primitive call")).! !!Descriptor class methodsFor: 'Component protocol' stamp: 'PetrSpacek 11/25/2013 00:10'!cs__getIdentityHash	^ ((self primitive_getIdentityHash "compo vm primitive call")).! !!Descriptor class methodsFor: 'Component protocol' stamp: 'PetrSpacek 11/25/2013 00:10'!cs__getOwner	^ ((self primitive_getOwner "compo vm primitive call")).! !!Descriptor class methodsFor: 'Component protocol' stamp: 'PetrSpacek 11/25/2013 00:45'!cs__getPortNamed__par01: nameS 	^ ((self primitive_getPortNamed: nameS "compo vm primitive call")).! !!Descriptor class methodsFor: 'Component protocol' stamp: 'PetrSpacek 11/25/2013 00:10'!cs__getPorts	^ ((self primitive_getPorts "compo vm primitive call")).! !!Descriptor class methodsFor: 'Component protocol' stamp: 'PetrSpacek 11/25/2013 00:10'!primitive_getDescriptor	^ (self class instVarNamed: #ports) at: #default.! !!Descriptor class methodsFor: 'Component protocol' stamp: 'PetrSpacek 11/25/2013 00:10'!primitive_getIdentityHash	^ self identityHash .! !!Descriptor class methodsFor: 'Component protocol' stamp: 'PetrSpacek 11/25/2013 00:10'!primitive_getOwner	((self instVarNamed: #owner) isKindOf: (Smalltalk at: #Component))		ifTrue: [ ^ ((self instVarNamed: #owner) instVarNamed: #ports) at: #default ]		ifFalse: [ ^ (self instVarNamed: #owner) defaultPort ].! !!Descriptor class methodsFor: 'Component protocol' stamp: 'PetrSpacek 11/25/2013 00:10'!primitive_getPortNamed: name	^ (self instVarNamed: #ports) at: name.! !!Descriptor class methodsFor: 'Component protocol' stamp: 'PetrSpacek 11/25/2013 00:10'!primitive_getPorts	^ (self instVarNamed: #ports).! !AtomicPort subclass: #LiteralAtomicPort	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Meta'!!LiteralAtomicPort methodsFor: 'as yet unclassified' stamp: 'Fred 2/9/2015 13:30'!owner: anObject	| grammar |	grammar := PPCompoGrammar new.	(grammar numberLiteral matches: anObject) 		ifTrue: [ owner := anObject asNumber. ]		ifFalse: [			(grammar stringLiteral matches: anObject) 				ifTrue: [ owner := anObject withoutQuoting. ]				ifFalse: [ 					(grammar charLiteral matches: anObject) 						ifTrue: [ owner := anObject asString. ]						ifFalse: [ 							(grammar byteLiteral matches: anObject) 								ifTrue: [ owner := anObject asByte. ]								ifFalse: [ 									(grammar nilLiteral matches: anObject) 										ifTrue: [ owner := anObject asSymbol. ]										ifFalse: [ 											(grammar trueLiteral matches: anObject) 												ifTrue: [ owner := true. ]												ifFalse: [ 													(grammar falseLiteral matches: anObject) 														ifTrue: [ owner := false. ]														ifFalse: [ 															owner := anObject.														]												]										]								]						]				]		 ]! !!LiteralAtomicPort methodsFor: 'as yet unclassified' stamp: 'Fred 2/11/2015 14:10'!printOn: aStream 	aStream nextPutAll: (owner asString)! !Object subclass: #ComponentBuilder	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Meta'!!ComponentBuilder methodsFor: 'instance creation' stamp: 'Fred 2/11/2015 14:55'!createInstanceOf: desc	|pdDict ports inst architecture connsColl disconnsColl|	"create new component instance"	inst := desc new.		"initialize owner"	inst instVarNamed: #owner put: nil.		"initialize ports"		inst		instVarNamed: #ports		put: Dictionary new.			pdDict := self getAllDeclaredPortDescriptionsFrom: desc.	ports := inst instVarNamed: #ports.		pdDict keysAndValuesDo: [ :pn :pdColl |		|pInst pKind pVisibility pd pInterface| 		"inheritance stuff"		pd := self applyPortInheritanceRulez: pdColl.				pKind := ((((((pd instVarNamed: #ports) at: #kind) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts) at: 1) instVarNamed: #owner.		pVisibility := ((((((pd instVarNamed: #ports) at: #visibility) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts) at: 1) instVarNamed: #owner.		pInterface := ((((((pd instVarNamed: #ports) at: #interface) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts) at: 1) instVarNamed: #owner.		pInst := (Smalltalk at: pKind) new.				self initPortInstance: pInst.		pInst instVarNamed: #owner put: inst.		((pInst instVarNamed: #ports) at: #name) cs__connectTo__par01: (pn defaultPort).		((pInst instVarNamed: #ports) at: #visibility) cs__connectTo__par01: (pVisibility defaultPort).		((pInst instVarNamed: #ports) at: #interface) cs__connectTo__par01: (pInterface defaultPort).		ports at: pn put: pInst.	].	"connect owner port of ports"	ports do: [ :p |		((p instVarNamed: #ports) at: #owner) cs__connectTo__par01: ((ports) at: #self).	].	"initialize connections"	"here we are going to create connections, we take into account INHERITANCE and first perform all disconnects and the connects, this way we specialize connections already created by super-descriptor of current descriptor."	connsColl := OrderedCollection new.	disconnsColl := OrderedCollection new.	architecture := self getAllDeclaredConnectionDescriptionsFrom:  desc.		architecture do: [ :cd | 		| array |		array := Array new: 5.		array at: 1 put: (((((((cd instVarNamed: #ports) at: #sourcePort) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts) at: 1) instVarNamed: #owner).		array at: 2 put: (((((((cd instVarNamed: #ports) at: #sourceComponent) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts) at: 1) instVarNamed: #owner).		array at: 3 put: (((((((cd instVarNamed: #ports) at: #destinationPort) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts) at: 1) instVarNamed: #owner).		array at: 4 put: (((((((cd instVarNamed: #ports) at: #destinationComponent) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts) at: 1) instVarNamed: #owner).		array at: 5 put: (((((((cd instVarNamed: #ports) at: #isDisconnection) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts) at: 1) instVarNamed: #owner).		(array at: 5)			ifTrue: [ disconnsColl add: array ]			ifFalse: [ 				"here we place first statements containing ''.new()'' as a substring"				(('*new()*' match: (array at: 2)) or: [ '*new()*' match: (array at: 4) ])					ifTrue: [ connsColl addFirst: array ]					ifFalse: [ connsColl addLast: array ] ] ].		"	disconnsColl		do: [ :conn | 			| srcP destP |			srcP := self getPortTargetCollection: (conn at: 1) on: (conn at: 2) forIntance: inst.				destP := self getPortTargetCollection: (conn at:3) on: (conn at: 4) forIntance: inst.			srcP do: [ :sp | sp cs__disconnect ] ].	"	connsColl		do: [ :conn | 			| srcP destP |			srcP := disconnsColl select: [ :disconn |				| b1 b2 b3 b4 |				b1 := ((disconn at: 1) = (conn at: 1)).				b2 := ((disconn at: 2) = (conn at: 2)).				b3 := ((disconn at: 3) = (conn at: 3)).				b4 := ((disconn at: 4) = (conn at: 4)).				((b1 and: [b2]) and: [b3]) and: b4.			].			(srcP size == 0) ifTrue: [ 				srcP := self getPortTargetCollection: (conn at: 1) on: (conn at: 2) forIntance: inst.				destP := self getPortTargetCollection: (conn at: 3) on: (conn at: 4) forIntance: inst.				srcP do: [ :sp | destP do: [ :dp | sp cs__connectTo__par01: dp ] ]			].	].	"return default port of the new instance"	^ (inst instVarNamed: #ports) at: #default. ! !!ComponentBuilder methodsFor: 'helpers' stamp: 'PetrSpacek 11/24/2013 20:22'!applyPortInheritanceRulez: aStackOfPortDescriptions 	"The argument [aStackOfPortDescriptions] contains a stack of PortDescriptions of the same port	as it was redefined in sub-descriptors. The top of the stack is the port description of the oldests parent.	This method applies the Compo-ports inheritance on the PortDescriptions given in the argument [aStackOfPortDescriptions]"	|res prev|	(aStackOfPortDescriptions size = 1)		ifTrue: [ res := aStackOfPortDescriptions pop. ]		ifFalse: [			res := aStackOfPortDescriptions pop.			prev := res.			[ aStackOfPortDescriptions isEmpty not ] whileTrue: [				|tr trIntf prevIntf|				tr := aStackOfPortDescriptions pop.				prev := tr.				trIntf := self getInterfaceOfPortDescription: tr.				prevIntf := self getInterfaceOfPortDescription: prev.				(prevIntf isArray) ifTrue: [					(trIntf isArray)						ifTrue: [ self setInterfaceOfPortDescription: res interface: ((Set withAll: (prevIntf,trIntf)) asArray).  ]						ifFalse: [  self shouldBeImplemented .  ]				].				"important"				prev := tr.			].		 ].		^ res.! !!ComponentBuilder methodsFor: 'helpers' stamp: 'Fred 2/12/2015 14:50'!getAllDeclaredConnectionDescriptionsFrom: aDesc	"returns a dictionary of connection descriptions"	| pdDict currentDesc cd |	(aDesc isKindOf: (Smalltalk at: #Descriptor))		ifFalse: [ self error: ((aDesc name asString) , ' has to be a descriptor') ].			"pdDict := OrderedCollection new."	pdDict := Dictionary new.	currentDesc := aDesc.		[ currentDesc ~= (Smalltalk at: #Object) ]		whileTrue: [ 						(((((currentDesc instVarNamed: #ports) at: #architecture) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts)				do: [ :atomicport |					cd := (atomicport  instVarNamed: #owner) instVarNamed: #owner. "get the current connection description"					"pdDict add: cd."					pdDict at: (cd  identityHash) put: cd				].						currentDesc := currentDesc superclass.			(currentDesc == (Smalltalk at: #Class))				ifTrue: [ currentDesc :=  (Smalltalk at: #Component)].		].			^ pdDict.! !!ComponentBuilder methodsFor: 'helpers' stamp: 'PetrSpacek 11/24/2013 17:37'!getAllDeclaredPortDescriptionsFrom: aDesc	"returns a dictionary of stacks"	|pdDict currentDesc pd pn|	(aDesc isKindOf: (Smalltalk at: #Descriptor))		ifFalse: [ self error: ((aDesc name asString) , ' has to be a descriptor') ].			pdDict := Dictionary new.		currentDesc := aDesc.		[ currentDesc ~= (Smalltalk at: #Object) ]		whileTrue: [ 						(((((currentDesc instVarNamed: #ports) at: #ports) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts)				do: [ :atomicport |					pd := (atomicport  instVarNamed: #owner) instVarNamed: #owner. "get the current port description"					pn := ((((((pd instVarNamed: #ports) at: #name) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts) at: 1) instVarNamed: #owner.					(pdDict includesKey: pn) ifFalse: [ pdDict at: pn put: (Stack new) ].					(pdDict at: pn) push: pd.				].			"cs__connectTo__par01: ((((pd instVarNamed: #ports) at: #default) instVarNamed: #ports) at: #default)"						currentDesc := currentDesc superclass.			(currentDesc == (Smalltalk at: #Class))				ifTrue: [ currentDesc :=  (Smalltalk at: #Component)].		].			^ pdDict.! !!ComponentBuilder methodsFor: 'helpers' stamp: 'PetrSpacek 11/23/2013 09:03'!getAttr: symb ofPortDesc: aPD	^ ((((self getPort: symb of: aPD) instVarNamed: #ports) at: #connectedPorts) at: 1) instVarNamed: #owner.! !!ComponentBuilder methodsFor: 'helpers' stamp: 'PetrSpacek 11/24/2013 19:56'!getInterfaceOfPortDescription: pd	^ ((((((pd instVarNamed: #ports) at: #interface) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts) at: 1) instVarNamed: #owner.	! !!ComponentBuilder methodsFor: 'helpers' stamp: 'PetrSpacek 11/23/2013 08:35'!getPort: nameSymb of: inst 	^ (inst instVarNamed: #ports) at: nameSymb .! !!ComponentBuilder methodsFor: 'helpers' stamp: 'FerrandAnthony 2/9/2015 10:01'!getPortTargetCollection: port on: comp forIntance: inst	|nodes tokens res connectedPorts|		res := OrderedCollection new.	((Smalltalk at: #PPCompoGrammar) matchesLiteral:  comp) 		ifTrue: [			res add: (LiteralAtomicPort newNamed: 'default' owner: comp role: #provided visibility: #external interface: #* isCollectionPort: false) ]		ifFalse: [				"argument [comp] might be either a symbol or expression, we have to parse it.	for now we support only these three forms Case1: identifier Case2: identifier[expr] Case3: (Printer new) like expressions"	nodes := (Smalltalk at: #PPCompoGrammar) parseExpression: comp.		tokens := (((((nodes at: 3) at:1) at:2) at:1) at: 1) at: 1.		(tokens isArray)		"Cases2&3"		ifTrue: [			(tokens first value = '(')				"Case3"				ifTrue: [					|expr errorStr defPortOfNewComp|					errorStr := 'For now, we support only simple create expression in connection statements, i.e. ''Component.new()''.'.					expr := tokens second second first first.					expr first isArray ifTrue: [self error: errorStr].					(expr second first value = 'new') ifFalse: [self error: errorStr].					"here we create an instance, new returns default port!!"					defPortOfNewComp := (Smalltalk at: (expr first value asSymbol)) newC.					"here we setup owner of the new component"					((defPortOfNewComp instVarNamed: #owner) isKindOf: (Smalltalk at: #Component))						ifTrue: [(defPortOfNewComp instVarNamed: #owner) instVarNamed: #owner put: inst]						ifFalse: [(defPortOfNewComp instVarNamed: #owner) owner: inst ].										res add: defPortOfNewComp .				]				"Case2"				ifFalse: [					|pOwner idx|					connectedPorts := (self getPort: (tokens first value asSymbol) of: inst).					idx := [(((tokens at: 3) at: 2) at: 1) value asNumber]								on: Error								do: [ self error: 'For now, we support only number literals in collection-port address in connection statements, i.e. ''portName[10]''.'].					.					(connectedPorts isKindOf: #AtomicPort)						ifTrue: [							connectedPorts := connectedPorts instVarNamed: #connectedPorts.							pOwner := (connectedPorts at: idx) instVarNamed: #owner.						]						ifFalse: [							connectedPorts := (self getPort: #connectedPorts of: connectedPorts) instVarNamed: #connectedPorts.							pOwner := ((connectedPorts at: idx) instVarNamed: #owner) instVarNamed: #owner.						].										res add: (self getPort: port of: pOwner).				].		]		"Case1"		ifFalse: [			((tokens value asSymbol) = #self)				ifTrue: [ res add: (self getPort: (port asSymbol) of: inst ) ]				ifFalse: [					connectedPorts := (self getPort: (tokens value asSymbol) of: inst).					(connectedPorts isKindOf: (Smalltalk at: #AtomicPort))						ifTrue: [ connectedPorts := connectedPorts instVarNamed: #connectedPorts ]						ifFalse: [							connectedPorts := (self getPort: #connectedPorts of: connectedPorts) instVarNamed: #connectedPorts.							connectedPorts := connectedPorts collect: [:p |												| tempOwner |												tempOwner := p instVarNamed: #owner.												(tempOwner isKindOf: (Smalltalk at: #Port)) ifTrue: [tempOwner] ifFalse: [p]].						].					connectedPorts do: [:p |						|pOwner|						pOwner := p instVarNamed: #owner.						res add: (self getPort: port of: pOwner ).					].			].		]		].			^ res asArray.! !!ComponentBuilder methodsFor: 'helpers' stamp: 'PetrSpacek 11/24/2013 17:40'!initPortInstance: p	| pports |	p instVarNamed: #ports put: (Dictionary new).	pports :=p instVarNamed: #ports.		pports at: #default put: (AtomicPort newNamed: #default owner: p 											role: #provided visibility: #external interface: #*											isCollectionPort: false).	pports at: #args put: (AtomicPort newNamed: #args owner: p 											role: #required visibility: #external interface: #*											isCollectionPort: true).	pports at: #self put: (AtomicPort newNamed: #self  owner: p 											role: #provided visibility: #internal interface: #*											isCollectionPort: false).	pports at: #super put: (AtomicPort newNamed: #super  owner: p 											role: #provided visibility: #internal interface: #*											isCollectionPort: false).	pports at: #owner put: (AtomicPort newNamed: #owner  owner: p 											role: #required visibility: #external interface: #*											isCollectionPort: false).	pports at: #connectedPorts put: (AtomicPort newNamed: #connectedPorts  owner: p 											role: #required visibility: #external interface: #*											isCollectionPort: true).	pports at: #delegatedPorts put: (AtomicPort newNamed: #delegatedPorts  owner: p 											role: #required visibility: #external interface: #*											isCollectionPort: true).	pports at: #name put: (AtomicPort newNamed: #name  owner: p 											role: #required visibility: #internal interface: #*											isCollectionPort: false).	pports at: #interface put: (AtomicPort newNamed: #interface  owner: p 											role: #required visibility: #internal interface: #*											isCollectionPort: false).	pports at: #visibility put: (AtomicPort newNamed: #visibility  owner: p 											role: #required visibility: #internal interface: #*											isCollectionPort: false).! !!ComponentBuilder methodsFor: 'helpers' stamp: 'PetrSpacek 11/24/2013 19:57'!setInterfaceOfPortDescription: pd interface: intf	((((((pd instVarNamed: #ports) at: #interface) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts) at: 1 put: (intf defaultPort) ).	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ComponentBuilder class	instanceVariableNames: ''!!ComponentBuilder class methodsFor: 'instance creation' stamp: 'PetrSpacek 11/24/2013 18:53'!newInstanceOf: desc 	^ self new createInstanceOf: desc.! !Array variableSubclass: #ServiceInvocationResult	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Meta'!!ServiceInvocationResult methodsFor: 'testing' stamp: 'PetrSpacek 10/21/2012 19:32'!isServiceInvocationResult	^ true.! !Object subclass: #CompoBootstrap	instanceVariableNames: 'default ssuper myself owner ownedPrimitives ports architecture services sourceCode'	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Meta'!!CompoBootstrap methodsFor: 'Descriptor protocol' stamp: 'PetrSpacek 11/4/2013 00:37'!addDescriptionOfConnectionWithSourceComponent: asc andPort: asp andDestinationComponent: adc andPort: adp kind: kind	| pd pp |	"we are creating [ConnectionDescription] instance in non-standart way,	because it is imposible to do so in standard way during bootstrap period"	pd := (Smalltalk at: #ConnectionDescription) basicNew.	pd instVarAt: (pd class instVarIndexFor: #owner) put: self.	"initialize ports"	pp := AtomicPort		newNamed: #sourceComponent		owner: pd		role: #required		visibility: #internal		interface: #*		injection: #NULL		isCollectionPort: false.	pd instVarAt: (pd class instVarIndexFor: #sourceComponent) put: pp.		pp := AtomicPort		newNamed: #sourcePort		owner: pd		role: #required		visibility: #internal		interface: #*		injection: #NULL		isCollectionPort: false.	pd instVarAt: (pd class instVarIndexFor: #sourcePort) put: pp.		pp := AtomicPort		newNamed: #destinationComponent		owner: pd		role: #required		visibility: #internal		interface: #*		injection: #NULL		isCollectionPort: false.	pd instVarAt: (pd class instVarIndexFor: #destinationComponent) put: pp.		pp := AtomicPort		newNamed: #destinationPort		owner: pd		role: #required		visibility: #internal		interface: #*		injection: #NULL		isCollectionPort: false.	pd instVarAt: (pd class instVarIndexFor: #destinationPort) put: pp.		pp := AtomicPort		newNamed: #isDisconnection		owner: pd		role: #required		visibility: #internal		interface: #*		injection: #NULL		isCollectionPort: false.	pd instVarAt: (pd class instVarIndexFor: #isDisconnection) put: pp.		pp := AtomicPort		newNamed: #kind		owner: pd		role: #required		visibility: #internal		interface: #*		injection: #NULL		isCollectionPort: false.	pd instVarAt: (pd class instVarIndexFor: #kind) put: pp.				"initiazlie ports defined by [Component]"	pp := AtomicPort		newNamed: #default		owner: pd		role: #provided		visibility: #external		interface: #*		injection: #NULL		isCollectionPort: false.	pd instVarAt: (pd class instVarIndexFor: #default) put: pp.		pp := AtomicPort		newNamed: #ssuper		owner: pd		role: #provided		visibility: #internal		interface: #*		injection: #NULL		isCollectionPort: false.	pd instVarAt: (pd class instVarIndexFor: #ssuper) put: pp.		pp := AtomicPort		newNamed: #myself		owner: pd		role: #provided		visibility: #internal		interface: #*		injection: #NULL		isCollectionPort: false.	pd instVarAt: (pd class instVarIndexFor: #myself) put: pp.		"intialize ownedPrimitives with IdentitySet, necessary for owning objects, object cannot have instance variable owner, so, we have to simulate this"	pd instVarAt: (pd class instVarIndexFor: #ownedPrimitives) put: IdentitySet new.	"we set (connect, see setters implementation) the target objects"	pd		setSourceComponent: asc;		setSourcePort: asp;		setDestinationComponent: adc;		setDestinationPort: adp;		setKind: kind;		setIsDisconnection: false.	"we initialize port main as the last one, and then we connect to it"	pp := AtomicPort		newNamed: #main		owner: pd		role: #provided		visibility: #external		interface:			#(#getSourceComponent #getSourcePort #getDestinationComponent #getDestinationPort #getKind #setSourceComponent: #setSourcePort: #setDestinationComponent: #setDestinationPort: #setKind: #getIsDisconnection #setIsDisconnection:)		injection: #NULL		isCollectionPort: false.	pd instVarAt: (pd class instVarIndexFor: #main) put: pp.	"and we connect architecture and main"	architecture connectTo_port: pp! !!CompoBootstrap methodsFor: 'Descriptor protocol' stamp: 'PetrSpacek 11/4/2013 00:37'!addDescriptionOfDisconnectionWithSourceComponent: asc andPort: asp andDestinationComponent: adc andPort: adp kind: kind	| pd pp |	"we are creating [ConnectionDescription] instance in non-standart way,	because it is imposible to do so in standard way during bootstrap period"	pd := (Smalltalk at: #ConnectionDescription) basicNew.	pd instVarAt: (pd class instVarIndexFor: #owner) put: self.	"initialize ports"	pp := AtomicPort		newNamed: #sourceComponent		owner: pd		role: #required		visibility: #internal		interface: #*		injection: #NULL		isCollectionPort: false.	pd instVarAt: (pd class instVarIndexFor: #sourceComponent) put: pp.	pp := AtomicPort		newNamed: #sourcePort		owner: pd		role: #required		visibility: #internal		interface: #*		injection: #NULL		isCollectionPort: false.	pd instVarAt: (pd class instVarIndexFor: #sourcePort) put: pp.	pp := AtomicPort		newNamed: #destinationComponent		owner: pd		role: #required		visibility: #internal		interface: #*		injection: #NULL		isCollectionPort: false.	pd instVarAt: (pd class instVarIndexFor: #destinationComponent) put: pp.	pp := AtomicPort		newNamed: #destinationPort		owner: pd		role: #required		visibility: #internal		interface: #*		injection: #NULL		isCollectionPort: false.	pd instVarAt: (pd class instVarIndexFor: #destinationPort) put: pp.	pp := AtomicPort		newNamed: #isDisconnection		owner: pd		role: #required		visibility: #internal		interface: #*		injection: #NULL		isCollectionPort: false.	pd instVarAt: (pd class instVarIndexFor: #isDisconnection) put: pp.	pp := AtomicPort		newNamed: #kind		owner: pd		role: #required		visibility: #internal		interface: #*		injection: #NULL		isCollectionPort: false.	pd instVarAt: (pd class instVarIndexFor: #kind) put: pp.				"initiazlie ports defined by [Component]"	pp := AtomicPort		newNamed: #default		owner: pd		role: #provided		visibility: #external		interface: #*		injection: #NULL		isCollectionPort: false.	pd instVarAt: (pd class instVarIndexFor: #default) put: pp.		pp := AtomicPort		newNamed: #ssuper		owner: pd		role: #provided		visibility: #internal		interface: #*		injection: #NULL		isCollectionPort: false.	pd instVarAt: (pd class instVarIndexFor: #ssuper) put: pp.		pp := AtomicPort		newNamed: #myself		owner: pd		role: #provided		visibility: #internal		interface: #*		injection: #NULL		isCollectionPort: false.	pd instVarAt: (pd class instVarIndexFor: #myself) put: pp.		"intialize ownedPrimitives with IdentitySet, necessary for owning objects, object cannot have instance variable owner, so, we have to simulate this"	pd instVarAt: (pd class instVarIndexFor: #ownedPrimitives) put: IdentitySet new.	"we set (connect, see setters implementation) the target objects"	pd		setSourceComponent: asc;		setSourcePort: asp;		setDestinationComponent: adc;		setDestinationPort: adp;		setKind: kind;		setIsDisconnection: true.	"we initialize port main as the last one, and then we connect to it"	pp := AtomicPort		newNamed: #main		owner: pd		role: #provided		visibility: #external		interface:			#(#getSourceComponent #getSourcePort #getDestinationComponent #getDestinationPort #getKind #setSourceComponent: #setSourcePort: #setDestinationComponent: #setDestinationPort: #setKind: #getIsDisconnection #setIsDisconnection:)		injection: #NULL		isCollectionPort: false.	pd instVarAt: (pd class instVarIndexFor: #main) put: pp.	"and we connect architecture and main"	architecture connectTo_port: pp! !!CompoBootstrap methodsFor: 'Descriptor protocol' stamp: 'PetrSpacek 11/4/2013 00:37'!addDescriptionOfPortNamed: aName interface: anInterface role: aRole visibility: aVisibility injection: in kind: kind isCollectionPort: isCP	| pd pp|	"we are creating [PortDescription] instance in non-standard way,	because it is imposible to do so in standard way during bootstrap period"	pd := (Smalltalk at: #PortDescription) basicNew.	pd instVarAt: (pd class instVarIndexFor: #owner) put: self.		"initialize ports"	pp := AtomicPort		newNamed: #name		owner: pd		role: #required		visibility: #internal		interface: #*		injection: #NULL		isCollectionPort: false.	pd instVarAt: (pd class instVarIndexFor: #name) put: pp.		pp := AtomicPort		newNamed: #role		owner: pd		role: #required		visibility: #internal		interface: #*		injection: #NULL		isCollectionPort: false.	pd instVarAt: (pd class instVarIndexFor: #role) put: pp.		pp := AtomicPort		newNamed: #visibility		owner: pd		role: #required		visibility: #internal		interface: #*		injection: #NULL		isCollectionPort: false.	pd instVarAt: (pd class instVarIndexFor: #visibility) put: pp.		pp := AtomicPort		newNamed: #interface		owner: pd		role: #required		visibility: #internal		interface: #*		injection: #NULL		isCollectionPort: false.	pd instVarAt: (pd class instVarIndexFor: #interface) put: pp.		pp := AtomicPort		newNamed: #kind		owner: pd		role: #required		visibility: #internal		interface: #*		injection: #NULL		isCollectionPort: false.	pd instVarAt: (pd class instVarIndexFor: #kind) put: pp.		pp := AtomicPort		newNamed: #injection		owner: pd		role: #required		visibility: #internal		interface: #*		injection: #NULL		isCollectionPort: false.	pd instVarAt: (pd class instVarIndexFor: #injection) put: pp.		pp := AtomicPort		newNamed: #isCollectionPort		owner: pd		role: #required		visibility: #internal		interface: #*		injection: #NULL		isCollectionPort: false.	pd instVarAt: (pd class instVarIndexFor: #isCollectionPort) put: pp.		"initiazlie ports defined by [Component]"	pp := AtomicPort		newNamed: #default		owner: pd		role: #provided		visibility: #external		interface: #*		injection: #NULL		isCollectionPort: false.	pd instVarAt: (pd class instVarIndexFor: #default) put: pp.		pp := AtomicPort		newNamed: #ssuper		owner: pd		role: #provided		visibility: #internal		interface: #*		injection: #NULL		isCollectionPort: false.	pd instVarAt: (pd class instVarIndexFor: #ssuper) put: pp.		pp := AtomicPort		newNamed: #myself		owner: pd		role: #provided		visibility: #internal		interface: #*		injection: #NULL		isCollectionPort: false.	pd instVarAt: (pd class instVarIndexFor: #myself) put: pp.		"intialize ownedPrimitives with IdentitySet, necessary for owning objects,	object cannot have instance variable owner, so, we have to simulate this"	pd instVarAt: (pd class instVarIndexFor: #ownedPrimitives) put: IdentitySet new.	"we set (connect, see setters implementation) the target objects"	pd		setName: aName;		setInterface: anInterface;		setRole: aRole;		setVisibility: aVisibility;		setInjection: in;		setIsCollectionPort: isCP;		setKind: kind.			"we initialize port main as the last one, and then we connect to it"	pp := AtomicPort		newNamed: #main		owner: pd		role: #provided		visibility: #external		interface:			#(#setName: #getName #setRole: #setKind: #getKind #getRole #getIsCollectionPort #setIsCollectionPort: #setInterface: #getInterface #setVisibility: #getVisibility #getInjection)		injection: #NULL		isCollectionPort: false.	pd instVarAt: (pd class instVarIndexFor: #main) put: pp.		"and we connect ports and main"	ports connectTo_port: pp		"self verifyInstVars."! !!CompoBootstrap methodsFor: 'Descriptor protocol' stamp: 'PetrSpacek 11/4/2013 00:37'!architectureDeclaration	|coll res|	(architecture) ifNil: [^Array new].	(architecture isConnected) ifFalse: [^Array new].	coll := OrderedCollection new.	"architecture is an atomic-port connected to many instances of ConnectionDescription "	res := architecture invokeStd_selector: #getIsDisconnection.	(res isServiceInvocationResult) ifFalse: [res := ServiceInvocationResult with: res].	res withIndexDo: [:isDisconn :i |		| srcC srcP destC destP |		srcC := architecture invokeStd_selector: #getSourceComponent args: nil index: i.		srcP := architecture invokeStd_selector: #getSourcePort args: nil index: i.		destC := architecture invokeStd_selector: #getDestinationComponent args: nil index: i.		destP := architecture invokeStd_selector: #getDestinationPort args: nil index: i.				(isDisconn)			ifTrue: [ coll add: ('disconnect ' , srcP , '@' , srcC  , ' from ',  destP  , '@' , destC ) ]			ifFalse: [ coll add: ('connect ' , srcP , '@' , srcC  , ' to ',  destP  , '@' , destC ) ].	].		^ coll asArray.! !!CompoBootstrap methodsFor: 'Descriptor protocol' stamp: 'PetrSpacek 11/4/2013 00:37'!compoInspect	super compoInspect.! !!CompoBootstrap methodsFor: 'Descriptor protocol' stamp: 'PetrSpacek 11/4/2013 00:37'!definition	"Answer a String that defines the receiver."	| aStream |	"(self = Component) ifTrue: [^ super definition]."	aStream := WriteStream on: (String new: 300).	self printExternalComponentDescriptorDefinitionOn: aStream.	self printInternalComponentDescriptorDefinitionOn: aStream.	aStream crtab;		 nextPutAll: 'category: ';		 store: self category asString.	^ aStream contents.! !!CompoBootstrap methodsFor: 'Descriptor protocol' stamp: 'PetrSpacek 11/4/2013 00:37'!definitionX	"Answer a String that defines the receiver."	| aStream |	"(self = Component) ifTrue: [^ super definition]."	aStream := WriteStream on: (String new: 300).	self printExternalComponentDescriptorDefinitionOn: aStream.	self printInternalComponentDescriptorDefinitionOn: aStream.	aStream crtab;		 nextPutAll: 'category: ';		 store: self category asString.	^ aStream contents.! !!CompoBootstrap methodsFor: 'Descriptor protocol' stamp: 'PetrSpacek 11/4/2013 00:37'!establishInstance: inst forceAtomicPorts: forceAtomicPorts	"follow inheritance to correctly establish instance, but make a little hack for [Port] to break Port-made-of-Ports definition loop"	| newInst connsColl disconnsColl |	self == (Smalltalk at: #Component)		ifTrue: [ newInst := inst ]		ifFalse: [ 			self == (Smalltalk at: #Port)				ifTrue: [ 					"[Component] defines 2 ports - [default] and [myself], normaly they are instances of [Port]					but in case when we are creating an instance of [Port] those have to be initializet as instances of [AtomicPort]"					newInst := self superclass establishInstance: inst forceAtomicPorts: true.				]				ifFalse: [ 					self == (Smalltalk at: #Descriptor)						ifTrue: [ newInst := (Smalltalk at: #Component) establishInstance: inst forceAtomicPorts: forceAtomicPorts ]						ifFalse: [ newInst := self superclass establishInstance: inst forceAtomicPorts: forceAtomicPorts ] ]				].		"we inject ports created according to instances of PortDescription connected to port [ports]"	1 to: ports connectedPortsCount do: [ :idx | 		| pRole pVisibility pName pInterface pKind pInjection pIsCollectionPort portClass newPort |		pRole := ports invokeStd_selector: #getRole args: nil index: idx.		pVisibility := ports invokeStd_selector: #getVisibility args: nil index: idx.		pName := ports invokeStd_selector: #getName args: nil index: idx.		pInterface := ports invokeStd_selector: #getInterface args: nil index: idx.		pKind := ports invokeStd_selector: #getKind args: nil index: idx.		pInjection := ports invokeStd_selector: #getInjection args: nil index: idx.		pIsCollectionPort := ports invokeStd_selector: #getIsCollectionPort args: nil index: idx.		(pKind = #AtomicPort or: [ forceAtomicPorts = true ])			ifTrue: [ 				portClass := Smalltalk at: #AtomicPort.				newPort := portClass					newNamed: pName					owner: inst					role: pRole					visibility: pVisibility					interface: pInterface					injection: pInjection					isCollectionPort: pIsCollectionPort ]			ifFalse: [ 				((Smalltalk at: pKind) isKindOf: (Smalltalk at: #Port) class)					ifTrue: [ 						| tempObj |						"a test if [pKind] matches with role and visibility"												(pRole = #required and: [ pVisibility = #external ])							ifTrue: [								(pKind == #Port)									ifTrue: [portClass := Smalltalk at: #ExternalRequiredPort ]									ifFalse: [ portClass := Smalltalk at: pKind ]							].						(pRole = #required and: [ pVisibility = #internal ])							ifTrue: [								(pKind == #Port)									ifTrue: [portClass := Smalltalk at: #InternalRequiredPort ]									ifFalse: [ portClass := Smalltalk at: pKind ]							].						(pRole = #provided and: [ pVisibility = #external ])							ifTrue: [								(pKind == #Port)									ifTrue: [portClass := Smalltalk at: #ExternalProvidedPort ]									ifFalse: [ portClass := Smalltalk at: pKind ]							].						(pRole = #provided and: [ pVisibility = #internal ])							ifTrue: [								(pKind == #Port)									ifTrue: [portClass := Smalltalk at: #InternalProvidedPort ]									ifFalse: [ portClass := Smalltalk at: pKind ]							].													newPort := portClass new.	"this returns [default] port of the newPort"						newPort := newPort owner.						newPort instVarNamed: #owner put: inst.												"deal with portName"						tempObj := pName copy.						tempObj owner: newPort.						(newPort instVarNamed: #portName) connectTo_port: tempObj.												"deal with interface"						tempObj := pInterface copy.						tempObj owner: newPort.						(newPort instVarNamed: #interface) connectTo_port: tempObj.												"deal with isCollectionPort"						(pIsCollectionPort not) ifTrue: [(newPort instVarNamed: #connectedPorts) instVarNamed: #isCollectionPort put: false.]					]					ifFalse: [ self error: pKind asString , ' is not sub-descriptor of the ''Port'' descriptor' ] ].						"here goes INHERITANCE stuff, the port we are creating might be already created in one of the super-descriptors,		in the case, we have to combine its interface with current one"		(newInst instVarNamed: pName)			ifNotNil: [ 				| oldPort oldInterface newInterface |				oldPort := newInst instVarNamed: pName.				(oldPort isKindOf: (Smalltalk at: #AtomicPort))					ifTrue: [ oldInterface := oldPort instVarNamed: #interface ]					ifFalse: [ oldInterface := oldPort getInterface ].				(oldInterface isSymbol or: [ pInterface isSymbol ])					ifTrue: [ 						(oldInterface isSymbol not and: [ pInterface isSymbol ])							ifTrue: [ self shouldBeImplemented ].						(oldInterface isSymbol and: [ pInterface isSymbol not ])							ifTrue: [								(oldInterface == #*)									ifTrue: [ newInterface := pInterface]									ifFalse: [ self shouldBeImplemented ].							].						(oldInterface isSymbol and: [ pInterface isSymbol ])							ifTrue: [ 								oldInterface = pInterface									ifTrue: [ newInterface := pInterface ]									ifFalse: [ self shouldBeImplemented ] ] ]					ifFalse: [ newInterface := (oldInterface , pInterface) asSet asArray ].				(newPort isKindOf: (Smalltalk at: #AtomicPort))					ifTrue: [ newPort interface: newInterface ]					ifFalse: [ 						newInterface := newInterface copy.						newInterface owner: newPort.						(newPort instVarNamed: #interface) disconnect.						(newPort instVarNamed: #interface) connectTo_port: newInterface ] ].	"we finaly inject newPort into the instance variable named pName of the new component"		newInst instVarNamed: pName put: newPort ].	"architecture do: [:conn | |sc sp dc dp|		sc := (inst getPortNamed: (conn getSourceComponent)) instVarAt: (inst class instVarIndexFor: (#component)).		sp := sc instVarAt: (inst class instVarIndexFor: (conn getSourcePort)).		dc := (inst getPortNamed: (conn getDestinationComponent)) instVarAt: (inst class instVarIndexFor: (#component)).		dp := sc instVarAt: (inst class instVarIndexFor: (conn getDestinationPort)).		sp connectTo: dp.		]."	"here we are going to create connections, we take into account INHERITANCE and first perform all disconnects and the connects, this way we specialize connections already created by super-descriptor of current descriptor."	connsColl := OrderedCollection new.	disconnsColl := OrderedCollection new.	1 to: architecture connectedPortsCount do: [ :idx | 		| array |		array := Array new: 6.		array at: 1 put: (architecture invokeStd_selector: #getSourcePort args: nil index: idx).		array at: 2 put: (architecture invokeStd_selector: #getSourceComponent args: nil index: idx).		array at: 3 put: (architecture invokeStd_selector: #getDestinationPort args: nil index: idx).		array at: 4 put: (architecture invokeStd_selector: #getDestinationComponent args: nil index: idx).		array at: 5 put: (architecture invokeStd_selector: #getKind args: nil index: idx).		array at: 6 put: (architecture invokeStd_selector: #getIsDisconnection args: nil index: idx).		(array at: 6)			ifTrue: [ disconnsColl add: array ]			ifFalse: [ 				"here we place first statements containing ''.new()'' as a substring"				(('*new()' match: (array at: 2)) or: [ '*new()' match: (array at: 4) ])					ifTrue: [ connsColl addFirst: array ]					ifFalse: [ connsColl addLast: array ] ] ].	disconnsColl		do: [ :conn | 			| srcP "destP" |			srcP := self getPortTargetCollection: (conn at: 1) on: (conn at: 2) forIntance: newInst.	"destP := self getPortTargetCollection: (conn at:3) on: (conn at: 4) forIntance: newInst."			srcP do: [ :sp | sp disconnect ] ].	connsColl		do: [ :conn | 			| srcP destP |			srcP := self getPortTargetCollection: (conn at: 1) on: (conn at: 2) forIntance: newInst.			destP := self getPortTargetCollection: (conn at: 3) on: (conn at: 4) forIntance: newInst.			srcP do: [ :sp | destP do: [ :dp | sp connectTo_port: dp ] ] ].	^ newInst! !!CompoBootstrap methodsFor: 'Descriptor protocol' stamp: 'PetrSpacek 11/4/2013 00:37'!establishMyOwnerPortsOfPortsOf: inst	"for each port of the [inst], we connect its [myOwner] required port to [myself] port of the [inst]"	|pMyself ar|		pMyself := inst instVarNamed: #myself.		ar := Array new: (inst getDescriptor instSize).	1 to: (inst getDescriptor instSize) do: [:i | ar at: i put: (inst instVarAt: i)].	ar := ar reject: [:port | (port isKindOf: (Smalltalk at: #Port)) not].	ar do: [ :port |		|pMyOwner|		pMyOwner := port getPortNamed: #myOwner.		pMyOwner connectTo_port: pMyself.	].		^ inst.		! !!CompoBootstrap methodsFor: 'Descriptor protocol' stamp: 'PetrSpacek 11/4/2013 00:37'!getDescribedConnections	|res|	res := ServiceInvocationResult new: (ports connectedPortsCount).	(architecture instVarNamed: #connectedPorts) withIndexDo: [:p :i | res at: i put: p copy ].	^ res.! !!CompoBootstrap methodsFor: 'Descriptor protocol' stamp: 'PetrSpacek 11/4/2013 00:37'!getDescribedPorts	|res|	res := ServiceInvocationResult new: (ports connectedPortsCount).	(ports instVarNamed: #connectedPorts) withIndexDo: [:p :i | res at: i put: p copy ].	^ res.! !!CompoBootstrap methodsFor: 'Descriptor protocol' stamp: 'PetrSpacek 11/4/2013 00:37'!getDescribedPortsNames	^ ports invokeStd_selector: #getName! !!CompoBootstrap methodsFor: 'Descriptor protocol' stamp: 'PetrSpacek 11/4/2013 00:37'!getDescriptor	"self class"	<primitive: 111>	self primitiveFailed.! !!CompoBootstrap methodsFor: 'Descriptor protocol' stamp: 'PetrSpacek 11/4/2013 00:37'!getName	^ self name copy.! !!CompoBootstrap methodsFor: 'Descriptor protocol' stamp: 'PetrSpacek 11/4/2013 00:37'!getOwner	^ owner.! !!CompoBootstrap methodsFor: 'Descriptor protocol' stamp: 'PetrSpacek 11/4/2013 00:37'!getPortNamed: aNameSymb	|p |	p := [self instVarAt: (self getDescriptor instVarIndexFor: aNameSymb)] on: Error do: [self error: ('I don''t have port named ', aNameSymb asString)].	p isExternal ifFalse: [self error: ('I don''t have port named ', aNameSymb asString)].	^ p.! !!CompoBootstrap methodsFor: 'Descriptor protocol' stamp: 'PetrSpacek 11/4/2013 00:37'!getPortTargetCollection: port on: comp forIntance: inst	|nodes tokens res connectedPorts|	"argument [comp] might be either a symbol or expression, we have to parse it.	for now we support only these three forms Case1: identifier Case2: identifier[expr] Case3: (Printer new) like expressions"	nodes := (Smalltalk at: #PPCompoGrammar) parseExpression: comp.	tokens := (((((nodes at: 3) at:1) at:2) at:1) at: 1) at: 1.	res := OrderedCollection new.	(tokens isArray)		"Cases2&3"		ifTrue: [			(tokens first value = '(')				"Case3"				ifTrue: [					|expr errorStr defPortOfNewComp|					errorStr := 'For now, we support only simple create expression in connection statements, i.e. ''Component.new()''.'.					expr := tokens second second first first.					expr first isArray ifTrue: [self error: errorStr].					(expr second first value = 'new') ifFalse: [self error: errorStr].					"here we create an instance, new returns default port!!"					defPortOfNewComp := (Smalltalk at: (expr first value asSymbol)) new.					"here we setup owner of the new component"					((defPortOfNewComp instVarNamed: #owner) isKindOf: (Smalltalk at: #Component))						ifTrue: [(defPortOfNewComp instVarNamed: #owner) instVarNamed: #owner put: inst]						ifFalse: [(defPortOfNewComp instVarNamed: #owner) owner: inst ].										res add: defPortOfNewComp .				]				"Case2"				ifFalse: [					|pOwner idx|					connectedPorts := (inst instVarNamed: (tokens first value asSymbol)) instVarNamed: #connectedPorts.					idx := [(((tokens at: 3) at: 2) at: 1) value asNumber]								on: Error								do: [ self error: 'For now, we support only number literals in collection-port address in connection statements, i.e. ''portName[10]''.'].					.					pOwner := (connectedPorts at: idx) instVarNamed: #owner.					res add: (pOwner getPortNamed: port).				].		]		"Case1"		ifFalse: [			((tokens value asSymbol) = #myself)				ifTrue: [ res add: (inst instVarNamed: port) ]				ifFalse: [					connectedPorts := (inst instVarNamed: (tokens value asSymbol)).					(connectedPorts isKindOf: (Smalltalk at: #AtomicPort))						ifTrue: [ connectedPorts := connectedPorts instVarNamed: #connectedPorts ]						ifFalse: [							connectedPorts := (connectedPorts getPortNamed: #connectedPorts) instVarNamed: #connectedPorts.							connectedPorts := connectedPorts collect: [:p |												| tempOwner |												tempOwner := p instVarNamed: #owner.												(tempOwner isKindOf: (Smalltalk at: #Port)) ifTrue: [tempOwner] ifFalse: [p]].						].					connectedPorts do: [:p |						|pOwner|						pOwner := p instVarNamed: #owner.						res add: (pOwner getPortNamed: port).					].				].		].			^ res asArray.! !!CompoBootstrap methodsFor: 'Descriptor protocol' stamp: 'PetrSpacek 11/4/2013 00:37'!getPorts	|ar|	ar := Array new: (self getDescriptor instSize).	1 to: (self getDescriptor instSize) do: [:i | ar at: i put: (self instVarAt: i)].	ar := ar reject: [:port | (port isInternal) or: [ ((port isKindOf: (Smalltalk at: #Port)) or: [port isKindOf: (Smalltalk at: #AtomicPort)]) not ]].	^ ar.! !!CompoBootstrap methodsFor: 'Descriptor protocol' stamp: 'PetrSpacek 11/4/2013 00:37'!initDescriptor	ports := AtomicPort		newNamed: #ports		owner: self		role: #required		visibility: #internal		interface:			#(#setName: #getName #setRole: #setKind: #getKind #getIsCollectionPort #setIsCollectionPort: #getRole #setInterface: #getInterface #setVisibility: #getVisibility #getInjection)		injection: nil		isCollectionPort: true.			architecture := AtomicPort		newNamed: #architecture		owner: self		role: #required		visibility: #internal		interface:			#(#getSourceComponent #getSourcePort #getDestinationComponent #getDestinationPort #getKind #setSourceComponent: #setSourcePort: #setDestinationComponent: #setDestinationPort: #setKind: #getIsDisconnection)		injection: nil		isCollectionPort: true.			myself := AtomicPort		newNamed: #myself		owner: self		role: #provided		visibility: #internal		interface: #*		injection: nil		isCollectionPort: false.			default := AtomicPort		newNamed: #default		owner: self		role: #provided		visibility: #external		interface: #*		injection: nil		isCollectionPort: false.			ssuper := AtomicPort		newNamed: #ssuper		owner: self		role: #provided		visibility: #internal		interface: #*		injection: nil		isCollectionPort: false.			services := AtomicPort		newNamed: #services		owner: self		role: #required		visibility: #internal		interface: #*		injection: nil		isCollectionPort: true.	sourceCode := nil.	owner := nil.	ownedPrimitives := IdentitySet new! !!CompoBootstrap methodsFor: 'Descriptor protocol' stamp: 'PetrSpacek 11/4/2013 00:37'!internalProvidedPortsDeclaration	^ self portsDeclarationHelper_visibility: #internal role: #provided.! !!CompoBootstrap methodsFor: 'Descriptor protocol' stamp: 'PetrSpacek 11/4/2013 00:37'!internalRequiredPortsDeclaration	^ self portsDeclarationHelper_visibility: #internal role: #required.! !!CompoBootstrap methodsFor: 'Descriptor protocol' stamp: 'PetrSpacek 11/4/2013 00:37'!isKindOf: class	(class == (Smalltalk at: #Component)) ifTrue: [^ true] ifFalse: [^ super isKindOf: class]! !!CompoBootstrap methodsFor: 'Descriptor protocol' stamp: 'PetrSpacek 11/4/2013 00:37'!new	^ self primitive_new! !!CompoBootstrap methodsFor: 'Descriptor protocol' stamp: 'PetrSpacek 11/4/2013 00:37'!newDescNamed: aNameSymb	^ self primitive_newDescNamed: aNameSymb withSuper: (self super).! !!CompoBootstrap methodsFor: 'Descriptor protocol' stamp: 'PetrSpacek 11/4/2013 00:37'!newDescNamed: aNameSymb withSuper: aSuperDesc	^ self primitive_newDescNamed: aNameSymb  withSuper: aSuperDesc ! !!CompoBootstrap methodsFor: 'Descriptor protocol' stamp: 'PetrSpacek 11/4/2013 00:37'!portsDeclarationHelper_visibility: aVisibility role: aRole	|coll res|	ports ifNil: [^Array new].	(ports isConnected) ifFalse: [^ Array new].	coll := OrderedCollection new.	"ports is an atomic port connected to many instances of PortDescription"	res := ports invokeStd_selector: #getVisibility args: nil. 	(res isServiceInvocationResult) ifFalse: [res := ServiceInvocationResult with: res].	res withIndexDo: [:visib :i |		(visib == aVisibility) ifTrue: [			| pname interface prole|			prole := ports invokeStd_selector: #getRole args: nil index: i.			(prole == aRole) ifTrue: [				pname := ports invokeStd_selector: #getName args: nil index: i.				interface := ports invokeStd_selector: #getInterface args: nil index: i.				coll add: (Association key: pname value: interface).			].		].	].		^ coll asArray.! !!CompoBootstrap methodsFor: 'Descriptor protocol' stamp: 'PetrSpacek 11/4/2013 00:37'!primitive_new	|inst|	"we create an instance"	inst := super new.		inst := self establishInstance: inst forceAtomicPorts: false.		"connect [myOwner] req-port of ports of [inst] to [myself] port of [inst]"	inst := self establishMyOwnerPortsOfPortsOf: inst.		"[ownedPrimitives] is a kind of hack which allows standart objects to be owned by a component"	inst instVarAt: (inst class instVarIndexFor:#ownedPrimitives ) put: (IdentitySet new).	"and we return default port"	^ inst getPortNamed: #default.	! !!CompoBootstrap methodsFor: 'Descriptor protocol' stamp: 'PetrSpacek 11/4/2013 00:37'!primitive_newDescNamed: aNameSymb withSuper: aSuperDesc	|cb instVarArray oldClass newFormat usedNames newClass cat newMeta|		(self inheritsFrom: (Smalltalk at: #Descriptor))		ifFalse: [ self error: 'Descriptor>>newNamed: can be applied on instances of sub-descriptors of [Descriptor]'].	"we create an instance"	newClass := super new.		"establish newClass"	newClass := self establishInstance: newClass forceAtomicPorts: false.		"connect [myOwner] req-port of ports of [newClass] to [myself] port of [newClass]"	newClass := self establishMyOwnerPortsOfPortsOf: newClass.		"[ownedPrimitives] is a kind of hack which allows standart objects to be owned by a component"	newClass instVarAt: (newClass class instVarIndexFor:#ownedPrimitives ) put: (IdentitySet new).	cat := aSuperDesc category.		instVarArray := {}.	instVarArray := instVarArray collect: [:assoc | assoc key asString].	usedNames := aSuperDesc allInstVarNames asSet.	instVarArray := instVarArray reject: [:iv | usedNames includes: iv ].		oldClass := (aSuperDesc environment) at: aNameSymb  ifAbsent: [ nil ].	oldClass isBehavior ifFalse: [ oldClass := nil ].		cb := ClassBuilder new.	cb validateInstvars: instVarArray from: oldClass forSuper: aSuperDesc.	newFormat := cb computeFormat: (aSuperDesc typeOfClass) instSize: (instVarArray size) forSuper: aSuperDesc ccIndex: (oldClass ifNil:[0] ifNotNil:[oldClass indexIfCompact]).		"we set up the newClass"	newClass 		superclass: aSuperDesc		methodDictionary: MethodDictionary new		format: newFormat.	newClass setInstVarNames: instVarArray.	newClass setName: aNameSymb.	newClass initDescriptor.	newClass category: cat.	newClass environment: aSuperDesc environment.	organization := aSuperDesc environment ifNotNil: [ aSuperDesc environment organization ].	organization classify: newClass name under: cat.					Smalltalk globals flushClassNameCache.	Smalltalk at: aNameSymb put: newClass.	SystemChangeNotifier uniqueInstance classAdded: newClass inCategory: cat.		"and we return default port"	^ newClass getPortNamed: #default.! !!CompoBootstrap methodsFor: 'Descriptor protocol' stamp: 'PetrSpacek 11/4/2013 00:37'!printExternalComponentDescriptorDefinitionOn: aStream 	|temp|	aStream		 nextPutAll: (self superclass name) , ' subdescriptor: ';		 store: self name;		 crtab;		 nextPutAll: 'providedPorts: '.			temp := self providedPortsDeclaration.		 (temp isEmpty)		 	ifTrue: [ aStream nextPutAll: '{}' ]			ifFalse: [				aStream nextPut: ${; crlf.				temp do: [:d | aStream tab; tab. d printOn: aStream. aStream nextPut: $.; crlf. ].				aStream tab; nextPut: $}			].	aStream		 crtab;		 nextPutAll: 'requiredPorts: '.			temp := self requiredPortsDeclaration.		 (temp isEmpty)		 	ifTrue: [ aStream nextPutAll: '{}' ]			ifFalse: [				aStream nextPut: ${; crlf.				temp do: [:d | aStream tab; tab. d printOn: aStream. aStream nextPut: $.; crlf. ].				aStream tab; nextPut: $}			].! !!CompoBootstrap methodsFor: 'Descriptor protocol' stamp: 'PetrSpacek 11/4/2013 00:37'!printInternalComponentDescriptorDefinitionOn: aStream	|temp|	aStream		crtab;		nextPutAll: 'internallyProvidedPorts: '.		temp := self internalProvidedPortsDeclaration.	(temp isEmpty)		 	ifTrue: [ aStream nextPutAll: '{}' ]			ifFalse: [				aStream nextPut: ${; crlf.				temp do: [:d | aStream tab; tab. d printOn: aStream. aStream nextPut: $.; crlf. ].				aStream tab; nextPut: $}			].	aStream		crtab;		nextPutAll: 'internallyRequiredPorts: '.	temp := self internalRequiredPortsDeclaration .	(temp isEmpty)		 	ifTrue: [ aStream nextPutAll: '{}' ]			ifFalse: [				aStream nextPut: ${; crlf.				temp do: [:d | aStream tab; tab. d printOn: aStream. aStream nextPut: $.; crlf. ].				aStream tab; nextPut: $}			].			aStream		crtab;		nextPutAll: 'architecture: '.	temp := self architectureDeclaration.	(temp isEmpty)		ifTrue: [ aStream nextPutAll: '{}' ]		ifFalse: [			aStream nextPut: ${; crlf.			temp do: [:d | aStream tab; tab. d printOn: aStream. aStream nextPut: $.; crlf. ].			aStream tab; nextPut: $}		].! !!CompoBootstrap methodsFor: 'Descriptor protocol' stamp: 'PetrSpacek 11/4/2013 00:37'!providedPortsDeclaration	^ self portsDeclarationHelper_visibility: #external role: #provided.! !!CompoBootstrap methodsFor: 'Descriptor protocol' stamp: 'PetrSpacek 11/4/2013 00:37'!requiredPortsDeclaration	^ self portsDeclarationHelper_visibility: #external role: #required.! !!CompoBootstrap methodsFor: 'Descriptor protocol' stamp: 'PetrSpacek 11/4/2013 00:37'!sourceCode	^ sourceCode.! !!CompoBootstrap methodsFor: 'Descriptor protocol' stamp: 'PetrSpacek 11/4/2013 00:37'!sourceCode: aStr	sourceCode := aStr.! !!CompoBootstrap methodsFor: 'Descriptor protocol' stamp: 'PetrSpacek 11/4/2013 00:37'!subclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s category: cat 	self error: 'For creating descriptors, use subdescriptor:providedPorts:requiredPorts:internallyRequiredPorts:architecture:category: method'.! !!CompoBootstrap methodsFor: 'Descriptor protocol' stamp: 'PetrSpacek 11/4/2013 00:37'!subdescriptor: aName providedPorts: pp requiredPorts: rp internallyProvidedPorts: ipp internallyRequiredPorts: irp architecture: arch category: cat	^ (DescriptorBuilder new)		superdescriptor: self		subdescriptor: aName asSymbol		providedPorts: pp		requiredPorts: rp		internallyProvidedPorts: ipp		internallyRequiredPorts: irp		architecture: arch		category: cat.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CompoBootstrap class	instanceVariableNames: ''!!CompoBootstrap class methodsFor: 'helpers' stamp: 'PetrSpacek 11/4/2013 00:33'!copyMethodsFromCls: srcCls toCls: destCls 	srcCls methodDict do: [ :m | destCls compile: m getSource classified: (srcCls name asString , ' protocol') ].	! !!CompoBootstrap class methodsFor: 'helpers' stamp: 'PetrSpacek 11/4/2013 00:31'!removeClasses: array	array do: [:symb | [Smalltalk removeClassNamed: symb] on: Error do: []].! !!CompoBootstrap class methodsFor: 'bootstraping' stamp: 'PetrSpacek 11/8/2013 18:26'!systemChanges	| clsComponent clsComponentDescriptor temp |	self cleanup.		"the [Component class] inherits from [Object class] but we need a kind of multiple inheritace from [ComponentDescriptor] and [Object class], so we change superdescriptor of [Component class] to [ComponentDescriptor] and copy methods from [Object class] into the [Component class] "	clsComponent := Smalltalk at: #Component.	clsComponentDescriptor := Smalltalk at: #Descriptor.		clsComponent class superclass: clsComponentDescriptor.	clsComponent class setFormat: clsComponentDescriptor format.		"following solves issue that in this line expression (Component isKindOf: clsComponentDescriptor) returns false"	temp := clsComponent class.	temp		instVarAt: (temp class instVarIndexFor: #thisClass)		put: (self createNewClsComponent: temp).		"re-register new class in global dictionary"	Smalltalk at: #Component put: temp soleInstance.	clsComponent := temp soleInstance.	temp := nil.		"and we copy methods from [Object class] to [Component class]"	self copyMethodsFromCls: Object class toCls: clsComponent class.		"here we create the [PortDescription] descriptor  necessary for creating other descriptors"	self createClsPortDescription.	"here we create the [ConnectionDescription] descriptor  necessary for creating other descriptors"	self createClsConnectionDescription.		"here we create the [Port] descriptor, its instances will differ from other components to avoid circular definition of ports, i.e. port beign a clsComponent made from ports "	self createClsPort.	self createSubclassesOfPort.		"here we create the [Service] and [ServiceSign] descriptors"	self createClsServiceSign.	self createClsService.		"init the created classes"	self initClsPort.	self initSubclassesOfPort.	self initClsPortDescription.	self initClsConnectionDescription.	self initClsServiceSign.	self initClsService.	self initClsComponent.	self initClsDescriptor.	! !!CompoBootstrap class methodsFor: 'cleanup' stamp: 'PetrSpacek 11/8/2013 18:26'!cleanup	self cleanupComponentSubclasses.	self removeClasses: #(#Component #Descriptor).		self createClsComponent.	self createClsDescriptor.! !!CompoBootstrap class methodsFor: 'cleanup' stamp: 'PetrSpacek 11/8/2013 18:25'!cleanupComponentSubclasses	self		removeClasses:			#(#Port #CollectionPort #CRequiredPort #CProvidedPort #SinglePort #SRequiredPort #SProvidedPort #DefaultPort #SelfPort #SuperPort #PortDescription #ConnectionDescription #Constraint #Service #ServiceSign).			! !!CompoBootstrap class methodsFor: 'private' stamp: 'PetrSpacek 11/4/2013 00:40'!createClsComponent		Object		subclass: #Component		instanceVariableNames: 'ports owner'		classVariableNames: ''		poolDictionaries: ''		category: 'Compo-Meta'.! !!CompoBootstrap class methodsFor: 'private' stamp: 'PetrSpacek 11/6/2013 07:40'!createClsConnectionDescription	(Smalltalk at: #Component)		subclass: #ConnectionDescription		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'Compo-Meta'.	(Smalltalk at: #ConnectionDescription)		instVarNamed: #ports		put: Dictionary new.	(Smalltalk at: #ConnectionDescription)		instVarNamed: #owner		put: nil.! !!CompoBootstrap class methodsFor: 'private' stamp: 'PetrSpacek 11/22/2013 02:00'!createClsDescriptor	Class		subclass: #Descriptor		instanceVariableNames: 'ports owner code'		classVariableNames: ''		poolDictionaries: ''		category: 'Compo-Meta'.	(Smalltalk at: #Descriptor) class instanceVariableNames: 'ports owner code'.	(Smalltalk at: #Descriptor)		instVarNamed: #ports		put: Dictionary new.	(Smalltalk at: #Descriptor)		instVarNamed: #owner		put: nil.! !!CompoBootstrap class methodsFor: 'private' stamp: 'PetrSpacek 11/6/2013 07:40'!createClsPort	(Smalltalk at: #Component)		subclass: #Port		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'Compo-Meta'.	(Smalltalk at: #Port)		instVarNamed: #ports		put: Dictionary new.	(Smalltalk at: #Port)		instVarNamed: #owner		put: nil.! !!CompoBootstrap class methodsFor: 'private' stamp: 'PetrSpacek 11/6/2013 07:42'!createClsPortDescription	(Smalltalk at: #Component)		subclass: #PortDescription		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'Compo-Meta'.	(Smalltalk at: #PortDescription)		instVarNamed: #ports		put: Dictionary new.	(Smalltalk at: #PortDescription)		instVarNamed: #owner		put: nil.! !!CompoBootstrap class methodsFor: 'private' stamp: 'PetrSpacek 11/7/2013 00:00'!createClsService	(Smalltalk at: #Component)		subclass: #Service		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'Compo-Meta'.	(Smalltalk at: #Service)		instVarNamed: #ports		put: Dictionary new.	(Smalltalk at: #Service)		instVarNamed: #owner		put: nil.! !!CompoBootstrap class methodsFor: 'private' stamp: 'PetrSpacek 11/8/2013 17:34'!createClsServiceSign	(Smalltalk at: #Component)		subclass: #ServiceSign		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'Compo-Meta'.	(Smalltalk at: #ServiceSign)		instVarNamed: #ports		put: Dictionary new.	(Smalltalk at: #ServiceSign)		instVarNamed: #owner		put: nil.! !!CompoBootstrap class methodsFor: 'private' stamp: 'PetrSpacek 11/4/2013 02:29'!createNewClsComponent: metaClass	| new instSizeNew instSizeOld cd ports|	new := metaClass basicNew.	cd := Smalltalk at: #Descriptor.	instSizeNew := cd instSize.	instSizeOld := Object class instSize.	1 to: instSizeNew do: [ :i | 		i < (instSizeOld + 1)			ifTrue: [ new instVarAt: i put: ((Smalltalk at: #Component) instVarAt: i) ]			ifFalse: [ new instVarAt: i put: nil ] ].			new		instVarAt: (cd instVarIndexFor: #ports)		put: (Dictionary new).							ports := new instVarAt: (cd instVarIndexFor: #ports).			ports at: #default put: nil.	ports at: #args put: nil.	ports at: #self put: nil.	ports at: #super put: nil.		ports at: #name put: nil.	ports at: #ports  put: nil.	ports at: #architecture put: nil.	ports at: #services put: nil.		"	ports		at: #ports 		put:			(AtomicPort				newNamed: #ports				owner: new				role: #required				visibility: #internal				interface:					#(#setName: #getName #setRole: #getIsCollectionPort #setIsCollectionPort:  #setKind: #getKind #getRole #setInterface: #getInterface #setVisibility: #getVisibility #getInjection)				isCollectionPort: true).			ports		at: #architecture		put:			(AtomicPort				newNamed: #architecture				owner: new				role: #required				visibility: #internal				interface:					#(#getSourceComponent #getSourcePort #getDestinationComponent #getDestinationPort #getKind #setSourceComponent: #setSourcePort: #setDestinationComponent: #setDestinationPort: #setKind: #getIsDisconnection)				isCollectionPort: true).	ports		at: #self		put:			(AtomicPort				newNamed: #self				owner: new				role: #provided				visibility: #internal				interface: #(#getDescriptor #getPorts #getPortNamed:)				isCollectionPort: false).					ports		at: #default		put:			(AtomicPort				newNamed: #default				owner: new				role: #provided				visibility: #external				interface: #(#getDescriptor #getPorts #getPortNamed:)				isCollectionPort: false).					ports		at: #args		put:			(AtomicPort				newNamed: #args				owner: new				role: #required				visibility: #external				interface: #(#getDescriptor #getPorts #getPortNamed:)				isCollectionPort: true).					ports		at: #super		put:			(AtomicPort				newNamed: #super				owner: new				role: #provided				visibility: #internal				interface: #(#getDescriptor #getPorts #getPortNamed:)				isCollectionPort: false).					ports		at: #services		put:			(AtomicPort				newNamed: #services				owner: new				role: #required				visibility: #internal				interface: #(#getDescriptor #getPorts #getPortNamed:)				isCollectionPort: true).					ports at: #sourceCode put: #NULL.	ports at: #owner put: nil.	ports at: #ownedPrimitives put: IdentitySet new.	"		^ new	"return new class"! !!CompoBootstrap class methodsFor: 'private' stamp: 'PetrSpacek 11/6/2013 07:41'!createSubclassesOfPort	| tree parent child |	tree  := Array new: 9.	tree at: 1 put: #Port -> #SinglePort.	tree at: 2 put: #Port -> #CollectionPort.	tree at: 3 put: #CollectionPort -> #CRequiredPort.	tree at: 4 put: #CollectionPort -> #CProvidedPort.	tree at: 5 put: #SinglePort -> #SRequiredPort.	tree at: 6 put: #SinglePort -> #SProvidedPort.	tree at: 7 put: #SProvidedPort -> #DefaultPort.	tree at: 8 put: #SProvidedPort -> #SelfPort.	tree at: 9 put: #SProvidedPort -> #SuperPort.	tree		do: [:pair | 			parent := pair key.			child := pair value.			(Smalltalk at: parent )				subclass: child				instanceVariableNames: ''				classVariableNames: ''				poolDictionaries: ''				category: 'Compo-Meta'.			(Smalltalk at: child)				instVarNamed: #ports				put: Dictionary new.			(Smalltalk at: child)				instVarNamed: #owner				put: nil.		]! !!CompoBootstrap class methodsFor: 'private' stamp: 'PetrSpacek 11/7/2013 01:18'!getPortDescriptionInstance_name: aName role: aRole visibility: aVisibility interface: anInterface kind: aKind isCollection: isCollectionPort 	| inst pports  |		inst := (Smalltalk at: #PortDescription) new.		inst instVarNamed: #ports put: (Dictionary new).	pports := inst instVarNamed: #ports.		pports at: #default put: (Smalltalk at: #DefaultPort) new.	pports at: #args put: (Smalltalk at: #CRequiredPort) new.	pports at: #self put: (Smalltalk at: #SelfPort) new.	pports at: #super put: (Smalltalk at: #SuperPort) new.		pports at: #name put: (Smalltalk at: #SRequiredPort) new.	pports at: #role put: (Smalltalk at: #SRequiredPort) new.	pports at: #visibility put: (Smalltalk at: #SRequiredPort) new.	pports at: #interface put: (Smalltalk at: #SRequiredPort) new.	pports at: #kind put: (Smalltalk at: #SRequiredPort) new.	pports at: #isCollectionPort put: (Smalltalk at: #SRequiredPort) new.		pports keysAndValuesDo: [ :n :p |		self initPortInstance: p.		p instVarNamed: #owner put: inst.		((p instVarNamed: #ports) at: #name) cs__connectTo__par01: (n defaultPort).	].		(((pports at: #name) instVarNamed: #ports) at: #connectedPorts) cs__connectTo__par01: (aName defaultPort).	(((pports at: #role) instVarNamed: #ports) at: #connectedPorts) cs__connectTo__par01: (aRole defaultPort).	(((pports at: #visibility) instVarNamed: #ports) at: #connectedPorts) cs__connectTo__par01: (aVisibility defaultPort).	(((pports at: #interface) instVarNamed: #ports) at: #connectedPorts) cs__connectTo__par01: (anInterface defaultPort).	(((pports at: #kind) instVarNamed: #ports) at: #connectedPorts) cs__connectTo__par01: (aKind defaultPort).	(((pports at: #isCollectionPort) instVarNamed: #ports) at: #connectedPorts) cs__connectTo__par01: (isCollectionPort defaultPort).			^ inst.		! !!CompoBootstrap class methodsFor: 'private' stamp: 'PetrSpacek 11/8/2013 17:57'!getServiceInstance_name: aName paramNames: aParamNamesArray tempsNames: aTempsNamesArray code: code	| inst pports servicesign |		inst := (Smalltalk at: #Service) new.		inst instVarNamed: #ports put: (Dictionary new).	pports := inst instVarNamed: #ports.		pports at: #default put: (Smalltalk at: #DefaultPort) new.	pports at: #args put: (Smalltalk at: #CRequiredPort) new.	pports at: #self put: (Smalltalk at: #SelfPort) new.	pports at: #super put: (Smalltalk at: #SuperPort) new.		pports at: #context put: (Smalltalk at: #SRequiredPort) new.	pports at: #serviceSign put: (Smalltalk at: #SRequiredPort) new.	pports at: #tempsN put: (Smalltalk at: #CRequiredPort) new.	pports at: #tempsV put: (Smalltalk at: #CRequiredPort) new.	pports at: #code put: (Smalltalk at: #SRequiredPort) new.		pports keysAndValuesDo: [ :n :p |		self initPortInstance: p.		p instVarNamed: #owner put: inst.		((p instVarNamed: #ports) at: #name) cs__connectTo__par01: (n defaultPort).	].		servicesign := self getServiceSignInstance_name: aName paramNames:  aParamNamesArray.	(((pports at: #serviceSign) instVarNamed: #ports) at: #connectedPorts)		cs__connectTo__par01: ((((servicesign instVarNamed: #ports) at: #default) instVarNamed: #ports) at: #default).			aTempsNamesArray do: [  :n | 			(((pports at: #tempsN) instVarNamed: #ports) at: #connectedPorts)			cs__connectTo__par01: (n defaultPort).	].	(((pports at: #code) instVarNamed: #ports) at: #connectedPorts) cs__connectTo__par01: (code defaultPort).			^ inst.		! !!CompoBootstrap class methodsFor: 'private' stamp: 'PetrSpacek 11/8/2013 17:51'!getServiceSignInstance_name: aName paramNames: aParamNamesArray	| inst pports  |		inst := (Smalltalk at: #ServiceSign) new.		inst instVarNamed: #ports put: (Dictionary new).	pports := inst instVarNamed: #ports.		pports at: #default put: (Smalltalk at: #DefaultPort) new.	pports at: #args put: (Smalltalk at: #CRequiredPort) new.	pports at: #self put: (Smalltalk at: #SelfPort) new.	pports at: #super put: (Smalltalk at: #SuperPort) new.		pports at: #name put: (Smalltalk at: #SRequiredPort) new.	pports at: #paramNames put: (Smalltalk at: #SRequiredPort) new.		pports keysAndValuesDo: [ :n :p |		self initPortInstance: p.		p instVarNamed: #owner put: inst.		((p instVarNamed: #ports) at: #name) cs__connectTo__par01: (n defaultPort).	].		(((pports at: #name) instVarNamed: #ports) at: #connectedPorts) cs__connectTo__par01: (aName defaultPort).	aParamNamesArray do: [ :n |		(((pports at: #paramNames) instVarNamed: #ports) at: #connectedPorts)			cs__connectTo__par01: (n defaultPort).	].			^ inst.		! !!CompoBootstrap class methodsFor: 'private' stamp: 'PetrSpacek 11/22/2013 14:25'!initClsComponent	| ports portDescriptions serv |		ports := (Smalltalk at: #Component) instVarNamed: #ports.	ports at: #default put: (Smalltalk at: #DefaultPort) new.	ports at: #args put: (Smalltalk at: #CRequiredPort) new.	ports at: #self put: (Smalltalk at: #SelfPort) new.	ports at: #super put: (Smalltalk at: #SuperPort) new.	ports at: #name put: (Smalltalk at: #SRequiredPort) new.	ports at: #ports put: (Smalltalk at: #CRequiredPort) new.	ports at: #architecture put: (Smalltalk at: #CRequiredPort) new.	ports at: #services put: (Smalltalk at: #CRequiredPort) new.		ports keysAndValuesDo: [ :n :p |		self initPortInstance: p.		p instVarNamed: #owner put: (Smalltalk at: #Component).		((p instVarNamed: #ports) at: #name) cs__connectTo__par01: (n defaultPort).	].	portDescriptions := Dictionary new.		portDescriptions at: #default put: (self getPortDescriptionInstance_name: #default role: #provided visibility: #external interface: #* kind: #DefaultPort isCollection: false ).	portDescriptions at: #args put: (self getPortDescriptionInstance_name: #args role: #required visibility: #external interface: #* kind: #CRequiredPort isCollection: true ).	portDescriptions at: #super put: (self getPortDescriptionInstance_name: #super role: #required visibility: #internal interface: #* kind: #SuperPort isCollection: false ).	portDescriptions at: #self put: (self getPortDescriptionInstance_name: #self role: #required visibility: #internal interface: #* kind: #SelfPort isCollection: false ).		portDescriptions do: [ :pd |		(((ports at: #ports) instVarNamed: #ports) at: #connectedPorts)			cs__connectTo__par01: ((((pd instVarNamed: #ports) at: #default) instVarNamed: #ports) at: #default).	].	"set descriptor's name"	(((ports at: #name) instVarNamed: #ports) at: #connectedPorts)		cs__connectTo__par01: (Smalltalk at: #Component) name defaultPort.			serv := self getServiceInstance_name: #getPorts paramNames: #( ) tempsNames: #() code: ''.	(((ports at: #services) instVarNamed: #ports) at: #connectedPorts)			cs__connectTo__par01: ((((serv instVarNamed: #ports) at: #default) instVarNamed: #ports) at: #default).	(Smalltalk at: #Component) compile: ('cs__getPorts	') classified: 'default-interface'.	serv := self getServiceInstance_name: #getPortNamed paramNames: #( #name ) tempsNames: #() code: ' '.	(((ports at: #services) instVarNamed: #ports) at: #connectedPorts)			cs__connectTo__par01: ((((serv instVarNamed: #ports) at: #default) instVarNamed: #ports) at: #default).	(Smalltalk at: #Component) compile: ('cs__getPortNamed__par01: name		') classified: 'default-interface'.	serv := self getServiceInstance_name: #getDescriptor paramNames: #( ) tempsNames: #() code: ' '.	(((ports at: #services) instVarNamed: #ports) at: #connectedPorts)				cs__connectTo__par01: ((((serv instVarNamed: #ports) at: #default) instVarNamed: #ports) at: #default).	(Smalltalk at: #Component) compile: ('cs__getDescriptor	') classified: 'default-interface'.	serv := self getServiceInstance_name: #getOwner paramNames: #( ) tempsNames: #() code: ' '.	(((ports at: #services) instVarNamed: #ports) at: #connectedPorts)			cs__connectTo__par01: ((((serv instVarNamed: #ports) at: #default) instVarNamed: #ports) at: #default).	(Smalltalk at: #Component) compile: ('cs__getOwner		') classified: 'default-interface'.	serv := self getServiceInstance_name: #getIdentityHash paramNames: #( ) tempsNames: #() code: ' '.	(((ports at: #services) instVarNamed: #ports) at: #connectedPorts)			cs__connectTo__par01: ((((serv instVarNamed: #ports) at: #default) instVarNamed: #ports) at: #default).	(Smalltalk at: #Component) compile: ('cs__getIdentityHash		') classified: 'default-interface'.	(Smalltalk at: #Component) instVarNamed: #code put: ('Descriptor Component {  provides {  	default : { getPorts(); getPortNamed(name);  				getDescriptor(); getOwner();  				getIdentityHash();  			  }  }  requires { args[] : * }  internally requires {    super : * ofKind SuperPort;    self : * ofKind SelfPort;  }  service getPorts() { }  service getPortNamed(name) { }  service getDescriptor() { }  service getOwner() { }  service getIdentityHash() { }}').! !!CompoBootstrap class methodsFor: 'private' stamp: 'PetrSpacek 11/22/2013 01:36'!initClsConnectionDescription	| ports portDescriptions |		ports := (Smalltalk at: #ConnectionDescription) instVarNamed: #ports.	ports at: #default put: (Smalltalk at: #DefaultPort)  new.	ports at: #args put: (Smalltalk at: #CRequiredPort) new.	ports at: #self put: (Smalltalk at: #SelfPort) new.	ports at: #super put: (Smalltalk at: #SuperPort) new.	ports at: #name put: (Smalltalk at: #SRequiredPort) new.	ports at: #ports put: (Smalltalk at: #CRequiredPort) new.	ports at: #architecture put: (Smalltalk at: #CRequiredPort) new.	ports at: #services put: (Smalltalk at: #CRequiredPort) new.		ports keysAndValuesDo: [ :n :p |		self initPortInstance: p.		p instVarNamed: #owner put: (Smalltalk at: #ConnectionDescription).		((p instVarNamed: #ports) at: #name) cs__connectTo__par01: (n defaultPort).	].		portDescriptions := Dictionary new.		portDescriptions at: #sourceComponent put: (self getPortDescriptionInstance_name: #sourceComponent role: #required visibility: #internal interface: #* kind: #SRequiredPort isCollection: false ).	portDescriptions at: #sourcePort put: (self getPortDescriptionInstance_name: #sourcePort role: #required visibility: #internal interface: #* kind: #SRequiredPort isCollection: false ).	portDescriptions at: #destinationComponent put: (self getPortDescriptionInstance_name: #destinationComponent role: #required visibility: #internal interface: #* kind: #SRequiredPort isCollection: false ).	portDescriptions at: #destinationPort put: (self getPortDescriptionInstance_name: #destinationPort role: #required visibility: #internal interface: #* kind: #SRequiredPort isCollection: false ).	portDescriptions at: #isDisconnection put: (self getPortDescriptionInstance_name: #isDisconnection role: #required visibility: #internal interface: #* kind: #SRequiredPort isCollection: false ).		portDescriptions do: [ :pd |		(((ports at: #ports) instVarNamed: #ports) at: #connectedPorts)			cs__connectTo__par01: ((((pd instVarNamed: #ports) at: #default) instVarNamed: #ports) at: #default).	].	"set descriptor's name"	(((ports at: #name) instVarNamed: #ports) at: #connectedPorts)		cs__connectTo__par01: (Smalltalk at: #ConnectionDescription) name defaultPort.			(Smalltalk at: #ConnectionDescription) compile: 'printOn: aStream	|srcC srcP destC destP isDis |		srcP := (((((ports at: #sourcePort) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts) at: 1) instVarNamed: #owner.	srcC := (((((ports at: #sourceComponent) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts) at: 1) instVarNamed: #owner.	destC := (((((ports at: #destinationComponent) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts) at: 1) instVarNamed: #owner.	destP := (((((ports at: #destinationPort) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts) at: 1) instVarNamed: #owner.	isDis := (((((ports at: #isDisconnection) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts) at: 1) instVarNamed: #owner.	aStream nextPutAll: ''a description of a ''.	(isDis)		ifTrue: [ aStream nextPutAll: ''disconnection'' ]		ifFalse: [ aStream nextPutAll: ''connection'' ].	aStream		space;		nextPutAll: ''from '';		nextPutAll: srcP asString;		nextPut: $@;		nextPutAll: srcC asString;		nextPutAll: '' to '';		nextPutAll: destP asString;		nextPut: $@;		nextPutAll: destC asString.' classified: 'compo-private'.! !!CompoBootstrap class methodsFor: 'private' stamp: 'PetrSpacek 11/10/2013 18:50'!initClsDescriptor	| ports portDescriptions |		ports := (Smalltalk at: #Descriptor) instVarNamed: #ports.	ports at: #default put: (Smalltalk at: #DefaultPort) new.	ports at: #args put: (Smalltalk at: #CRequiredPort) new.	ports at: #self put: (Smalltalk at: #SelfPort) new.	ports at: #super put: (Smalltalk at: #SuperPort) new.	ports at: #name put: (Smalltalk at: #SRequiredPort) new.	ports at: #ports put: (Smalltalk at: #CRequiredPort) new.	ports at: #architecture put: (Smalltalk at: #CRequiredPort) new.	ports at: #services put: (Smalltalk at: #CRequiredPort) new.		ports keysAndValuesDo: [ :n :p |		self initPortInstance: p.		p instVarNamed: #owner put: (Smalltalk at: #Descriptor).		((p instVarNamed: #ports) at: #name) cs__connectTo__par01: (n defaultPort).	].	portDescriptions := Dictionary new.		portDescriptions at: #name put: (self getPortDescriptionInstance_name: #name role: #required visibility: #internal interface: #* kind: #SRequiredPort isCollection: false ).	portDescriptions at: #ports put: (self getPortDescriptionInstance_name: #ports role: #required visibility: #internal interface: #* kind: #CRequiredPort isCollection: true ).	portDescriptions at: #architecture put: (self getPortDescriptionInstance_name: #architecture role: #required visibility: #internal interface: #* kind: #CRequiredPort isCollection: true ).	portDescriptions at: #services put: (self getPortDescriptionInstance_name: #services role: #required visibility: #internal interface: #* kind: #CRequiredPort isCollection: true ).		portDescriptions do: [ :pd |		(((ports at: #ports) instVarNamed: #ports) at: #connectedPorts)			cs__connectTo__par01: ((((pd instVarNamed: #ports) at: #default) instVarNamed: #ports) at: #default).	].	(Smalltalk at: #Descriptor) class compile: 'isKindOf: cls	((cls == (Smalltalk at: #Component)) or: [ (cls == (Smalltalk at: #Descriptor)) ])		ifTrue: [ ^ true ]		ifFalse: [ ^ super isKindOf: cls ].'  classified: 'compo-private'.			(Smalltalk at: #Descriptor) compile: 'isKindOf: cls	((cls == (Smalltalk at: #Component)) or: [ (cls == (Smalltalk at: #Descriptor)) ])		ifTrue: [ ^ true ]		ifFalse: [ ^ super isKindOf: cls ].'  classified: 'compo-private'.			"set descriptor's name"	(((ports at: #name) instVarNamed: #ports) at: #connectedPorts)		cs__connectTo__par01: (Smalltalk at: #Descriptor) name defaultPort.! !!CompoBootstrap class methodsFor: 'private' stamp: 'PetrSpacek 11/8/2013 17:26'!initClsPort	| ports portDescriptions |		ports := (Smalltalk at: #Port) instVarNamed: #ports.	ports at: #default put: (Smalltalk at: #DefaultPort) new.	ports at: #args put: (Smalltalk at: #CRequiredPort) new.	ports at: #self put: (Smalltalk at: #SelfPort) new.	ports at: #super put: (Smalltalk at: #SuperPort) new.	ports at: #name put: (Smalltalk at: #SRequiredPort) new.	ports at: #ports put: (Smalltalk at: #CRequiredPort) new.	ports at: #architecture put: (Smalltalk at: #CRequiredPort) new.	ports at: #services put: (Smalltalk at: #CRequiredPort) new.		ports keysAndValuesDo: [ :n :p |		self initPortInstance: p.		p instVarNamed: #owner put: (Smalltalk at: #Port).		((p instVarNamed: #ports) at: #name) cs__connectTo__par01: (n defaultPort).	].	portDescriptions := Dictionary new.		portDescriptions at: #owner put: (self getPortDescriptionInstance_name: #owner role: #required visibility: #external interface: #* kind: #AtomicPort isCollection: false ).	portDescriptions at: #connectedPorts put: (self getPortDescriptionInstance_name: #connectedPorts role: #required visibility: #external interface: #* kind: #AtomicPort isCollection: true ).	portDescriptions at: #delegatedPorts put: (self getPortDescriptionInstance_name: #delegatedPorts role: #required visibility: #external interface: #* kind: #AtomicPort isCollection: true ).	portDescriptions at: #name put: (self getPortDescriptionInstance_name: #name role: #required visibility: #internal interface: #* kind: #AtomicPort isCollection: false ).	portDescriptions at: #interface put: (self getPortDescriptionInstance_name: #interface role: #required visibility: #internal interface: #* kind: #AtomicPort isCollection: false ).	portDescriptions at: #visibility put: (self getPortDescriptionInstance_name: #visibility role: #required visibility: #internal interface: #* kind: #AtomicPort isCollection: false ).		portDescriptions do: [ :pd |		(((ports at: #ports) instVarNamed: #ports) at: #connectedPorts)			cs__connectTo__par01: ((((pd instVarNamed: #ports) at: #default) instVarNamed: #ports) at: #default).	].	(Smalltalk at: #Port) compile: 'getName	^ (((ports at: #name) instVarNamed: #connectedPorts) at: 1) owner.'  classified: 'compo-private'.		(Smalltalk at: #Port) compile: 'printString	^ (super printString) , '' named '''''' , (self getName asString), '''''' '' .'  classified: 'compo-private'.		"set descriptor's name"	(((ports at: #name) instVarNamed: #ports) at: #connectedPorts)		cs__connectTo__par01: (Smalltalk at: #Port) name defaultPort.! !!CompoBootstrap class methodsFor: 'private' stamp: 'PetrSpacek 11/22/2013 01:35'!initClsPortDescription	| ports portDescriptions|		ports := (Smalltalk at: #PortDescription) instVarNamed: #ports.	ports at: #default put: (Smalltalk at: #DefaultPort)  new.	ports at: #args put: (Smalltalk at: #CRequiredPort) new.	ports at: #self put: (Smalltalk at: #SelfPort) new.	ports at: #super put: (Smalltalk at: #SuperPort) new.	ports at: #name put: (Smalltalk at: #SRequiredPort) new.	ports at: #ports put: (Smalltalk at: #CRequiredPort) new.	ports at: #architecture put: (Smalltalk at: #CRequiredPort) new.	ports at: #services put: (Smalltalk at: #CRequiredPort) new.		ports keysAndValuesDo: [ :n :p |		self initPortInstance: p.		p instVarNamed: #owner put: (Smalltalk at: #PortDescription).		((p instVarNamed: #ports) at: #name) cs__connectTo__par01: (n defaultPort).	].		portDescriptions := Dictionary new.		portDescriptions at: #name put: (self getPortDescriptionInstance_name: #name role: #required visibility: #internal interface: #* kind: #SRequiredPort isCollection: false ).	portDescriptions at: #role put: (self getPortDescriptionInstance_name: #role role: #required visibility: #internal interface: #* kind: #SRequiredPort isCollection: false ).	portDescriptions at: #visibility put: (self getPortDescriptionInstance_name: #visibility role: #required visibility: #internal interface: #* kind: #SRequiredPort isCollection: false ).	portDescriptions at: #interface put: (self getPortDescriptionInstance_name: #interface role: #required visibility: #internal interface: #* kind: #SRequiredPort isCollection: false ).	portDescriptions at: #kind put: (self getPortDescriptionInstance_name: #kind role: #required visibility: #internal interface: #* kind: #SRequiredPort isCollection: false ).	portDescriptions at: #isCollectionPort put: (self getPortDescriptionInstance_name: #isCollectionPort role: #required visibility: #internal interface: #* kind: #SRequiredPort isCollection: false ).		portDescriptions do: [ :pd |		(((ports at: #ports) instVarNamed: #ports) at: #connectedPorts)			cs__connectTo__par01: ((((pd instVarNamed: #ports) at: #default) instVarNamed: #ports) at: #default).	].	"set descriptor's name"	(((ports at: #name) instVarNamed: #ports) at: #connectedPorts)		cs__connectTo__par01: (Smalltalk at: #PortDescription) name defaultPort.			(Smalltalk at: #PortDescription) compile: 'printOn: aStream	|kind visib role name |		kind := (((((ports at: #kind) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts) at: 1) instVarNamed: #owner.	name := (((((ports at: #name) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts) at: 1) instVarNamed: #owner.	visib:= (((((ports at: #visibility) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts) at: 1) instVarNamed: #owner.	role := (((((ports at: #role) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts) at: 1) instVarNamed: #owner.	aStream		nextPutAll: ''a PortDescription of an '';		nextPutAll: visib asString;		space;		nextPutAll: role asString;		nextPutAll: '' port named '''''' ;		nextPutAll: name asString;		nextPutAll: '''''' of kind '';		nextPutAll: kind asString.' classified: 'compo-private'.! !!CompoBootstrap class methodsFor: 'private' stamp: 'PetrSpacek 11/22/2013 01:37'!initClsService	| ports portDescriptions serv |		ports := (Smalltalk at: #Service) instVarNamed: #ports.	ports at: #default put: (Smalltalk at: #DefaultPort) new.	ports at: #args put: (Smalltalk at: #CRequiredPort) new.	ports at: #self put: (Smalltalk at: #SelfPort) new.	ports at: #super put: (Smalltalk at: #SuperPort) new.	ports at: #name put: (Smalltalk at: #SRequiredPort) new.	ports at: #ports put: (Smalltalk at: #CRequiredPort) new.	ports at: #architecture put: (Smalltalk at: #CRequiredPort) new.	ports at: #services put: (Smalltalk at: #CRequiredPort) new.		ports keysAndValuesDo: [ :n :p |		self initPortInstance: p.		p instVarNamed: #owner put: (Smalltalk at: #Service).		((p instVarNamed: #ports) at: #name) cs__connectTo__par01: (n defaultPort).	].	"set descriptor's name"	(((ports at: #name) instVarNamed: #ports) at: #connectedPorts)		cs__connectTo__par01: (Smalltalk at: #Service) name defaultPort.	portDescriptions := Dictionary new.		portDescriptions at: #context put: (self getPortDescriptionInstance_name: #context role: #required visibility: #external interface: #* kind: #SRequiredPort  isCollection: false ).	portDescriptions at: #serviceSign put: (self getPortDescriptionInstance_name: #serviceSign role: #required visibility: #internal interface: #* kind: #SRequiredPort  isCollection: false ).	portDescriptions at: #tempsN put: (self getPortDescriptionInstance_name: #tempsN role: #required visibility: #internal interface: #* kind: #CRequiredPort isCollection: true ).	portDescriptions at: #tempsV put: (self getPortDescriptionInstance_name: #tempsV role: #required visibility: #internal interface: #* kind: #CRequiredPort isCollection: true ).		portDescriptions at: #code put: (self getPortDescriptionInstance_name: #code  role: #required visibility: #internal interface: #* kind: #SRequiredPort  isCollection: false ).		portDescriptions do: [ :pd |		(((ports at: #ports) instVarNamed: #ports) at: #connectedPorts)			cs__connectTo__par01: ((((pd instVarNamed: #ports) at: #default) instVarNamed: #ports) at: #default).	].	serv := self getServiceInstance_name: #execute paramNames: #() tempsNames: #(#bool1 #boo2)  code: '|bool1 bool2|bool1 := &context.isConnected();bool2 := &paramsV.isConnected();if( bool1 & bool2 ){return <primitive_execute>;}'.	(((ports at: #services) instVarNamed: #ports) at: #connectedPorts)			cs__connectTo__par01: ((((serv instVarNamed: #ports) at: #default) instVarNamed: #ports) at: #default).				serv := self getServiceInstance_name: #getSignature paramNames: #() tempsNames: #()  code: 'return serviceSign'.	(((ports at: #services) instVarNamed: #ports) at: #connectedPorts)			cs__connectTo__par01: ((((serv instVarNamed: #ports) at: #default) instVarNamed: #ports) at: #default).	(Smalltalk at: #Service) compile: 'primitive_execute	self halt.'  classified: 'compo-private'.		(Smalltalk at: #Service) compile:  'printOn: aStream	|signature|		signature := ((((((ports at: #serviceSign) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts) at: 1) instVarNamed: #owner) instVarNamed: #owner.	signature printOn: aStream.' classified: 'compo-private'.! !!CompoBootstrap class methodsFor: 'private' stamp: 'PetrSpacek 11/22/2013 13:06'!initClsServiceSign	| ports portDescriptions |		ports := (Smalltalk at: #ServiceSign) instVarNamed: #ports.	ports at: #default put: (Smalltalk at: #DefaultPort) new.	ports at: #args put: (Smalltalk at: #CRequiredPort) new.	ports at: #self put: (Smalltalk at: #SelfPort) new.	ports at: #super put: (Smalltalk at: #SuperPort) new.	ports at: #name put: (Smalltalk at: #SRequiredPort) new.	ports at: #ports put: (Smalltalk at: #CRequiredPort) new.	ports at: #architecture put: (Smalltalk at: #CRequiredPort) new.	ports at: #services put: (Smalltalk at: #CRequiredPort) new.		ports keysAndValuesDo: [ :n :p |		self initPortInstance: p.		p instVarNamed: #owner put: (Smalltalk at: #Service).		((p instVarNamed: #ports) at: #name) cs__connectTo__par01: (n defaultPort).	].	"set descriptor's name"	(((ports at: #name) instVarNamed: #ports) at: #connectedPorts)		cs__connectTo__par01: (Smalltalk at: #ServiceSign) name defaultPort.			portDescriptions := Dictionary new.		portDescriptions at: #name put: (self getPortDescriptionInstance_name: #name role: #required visibility: #internal interface: #* kind: #SRequiredPort  isCollection: false ).	portDescriptions at: #paramNames put: (self getPortDescriptionInstance_name: #paramNames role: #required visibility: #internal interface: #* kind: #CRequiredPort isCollection: true ).			portDescriptions do: [ :pd |		(((ports at: #ports) instVarNamed: #ports) at: #connectedPorts)			cs__connectTo__par01: ((((pd instVarNamed: #ports) at: #default) instVarNamed: #ports) at: #default).	].	(Smalltalk at: #ServiceSign) compile:  'printOn: aStream	|selector arguments|	selector := (((((ports at: #name) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts) at: 1) instVarNamed: #owner.	arguments := ((((ports at: #paramNames) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts).	aStream		nextPutAll: ''service '';		nextPutAll: selector asString;		nextPut: $(.		arguments do: [ :dp |		aStream			nextPutAll: (dp instVarNamed: #owner) asString;			nextPut: $, ;			space.	].	(arguments size > 0) ifTrue: [aStream position: (aStream position - 2)].	aStream nextPut: $); space.' classified: 'compo-private'.! !!CompoBootstrap class methodsFor: 'private' stamp: 'PetrSpacek 11/6/2013 22:17'!initPortInstance: p	| pports |	p instVarNamed: #ports put: (Dictionary new).	pports :=p instVarNamed: #ports.		pports at: #default put: (AtomicPort newNamed: #default owner: p 											role: #provided visibility: #external interface: #*											isCollectionPort: false).	pports at: #args put: (AtomicPort newNamed: #args owner: p 											role: #required visibility: #external interface: #*											isCollectionPort: true).	pports at: #self put: (AtomicPort newNamed: #self  owner: p 											role: #provided visibility: #internal interface: #*											isCollectionPort: false).	pports at: #super put: (AtomicPort newNamed: #super  owner: p 											role: #provided visibility: #internal interface: #*											isCollectionPort: false).	pports at: #owner put: (AtomicPort newNamed: #owner  owner: p 											role: #required visibility: #external interface: #*											isCollectionPort: false).	pports at: #connectedPorts put: (AtomicPort newNamed: #connectedPorts  owner: p 											role: #required visibility: #external interface: #*											isCollectionPort: true).	pports at: #delegatedPorts put: (AtomicPort newNamed: #delegatedPorts  owner: p 											role: #required visibility: #external interface: #*											isCollectionPort: true).	pports at: #name put: (AtomicPort newNamed: #name  owner: p 											role: #required visibility: #internal interface: #*											isCollectionPort: false).	pports at: #interface put: (AtomicPort newNamed: #interface  owner: p 											role: #required visibility: #internal interface: #*											isCollectionPort: false).	pports at: #visibility put: (AtomicPort newNamed: #visibility  owner: p 											role: #required visibility: #internal interface: #*											isCollectionPort: false).	! !!CompoBootstrap class methodsFor: 'private' stamp: 'PetrSpacek 11/7/2013 00:21'!initSubclassesOfPort	| clss ports  |	clss  := Array new: 9.	clss at: 1 put: #SinglePort.	clss at: 2 put: #CollectionPort.	clss at: 3 put: #CRequiredPort.	clss at: 4 put: #CProvidedPort.	clss at: 5 put: #SRequiredPort.	clss at: 6 put: #SProvidedPort.	clss at: 7 put: #DefaultPort.	clss at: 8 put: #SelfPort.	clss at: 9 put: #SuperPort.	clss		do: [:cls | 			ports := (Smalltalk at: cls) instVarNamed: #ports.			ports at: #default put: (Smalltalk at: #DefaultPort) new.			ports at: #args put: (Smalltalk at: #CRequiredPort) new.			ports at: #self put: (Smalltalk at: #SelfPort) new.			ports at: #super put: (Smalltalk at: #SuperPort) new.			ports at: #name put: (Smalltalk at: #SRequiredPort) new.			ports at: #ports put: (Smalltalk at: #CRequiredPort) new.			ports at: #architecture put: (Smalltalk at: #CRequiredPort) new.			ports at: #services put: (Smalltalk at: #CRequiredPort) new.				ports do: [ :p |				self initPortInstance: p.				p instVarNamed: #owner put: (Smalltalk at: cls).			].		]! !Object subclass: #DescriptorBuilder	instanceVariableNames: 'session sessionTarget connectionArray'	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Meta'!!DescriptorBuilder methodsFor: 'building' stamp: 'PetrSpacek 11/11/2013 15:16'!applyPortInheritanceRulez: aStackOfPortDescriptions 	"The argument [aStackOfPortDescriptions] contains a stack of PortDescriptions of the same port	as it was redefined in sub-descriptors. The top of the stack is the port description of the oldests parent.	This method applies the Compo-ports inheritance on the PortDescriptions given in the argument [aStackOfPortDescriptions]"		^ aStackOfPortDescriptions pop.! !!DescriptorBuilder methodsFor: 'building' stamp: 'PetrSpacek 11/10/2013 18:45'!checkSession	session ifNil: [self error: 'You have to start a new building session before creating a new descritor'].! !!DescriptorBuilder methodsFor: 'building' stamp: 'Fred 2/10/2015 12:40'!startBuildSession	session		ifNil: [ 			session := true.			connectionArray := Dictionary new.		]		ifNotNil: [ self error: 'Building session already started!!' ].! !!DescriptorBuilder methodsFor: 'building' stamp: 'PetrSpacek 11/10/2013 18:42'!stopBuildSession	session		ifNil: [  self error: 'There is no building session to stop!!' ]		ifNotNil: [ session := nil ].! !!DescriptorBuilder methodsFor: 'building' stamp: 'PetrSpacek 11/10/2013 18:33'!superdescriptor: aSuperDesc subdescriptor: aNameSymb providedPorts: pp requiredPorts: rp internallyProvidedPorts: ipp internallyRequiredPorts: irp architecture: arch category: cat		| newClass newSuperMeta newMeta newFormat cb organization oldClass instVarArray usedNames|				aSuperDesc		ifNil:[newSuperMeta := (Smalltalk at: #Descriptor)]		ifNotNil: [			(aSuperDesc isKindOf: (Smalltalk at: #Descriptor))				ifTrue: [					newSuperMeta := aSuperDesc class.				]				ifFalse: [ self error: (aSuperDesc asString , ' is not kind of Descriptor!!')].		].		"MAGIC 1 HERE !!!!!!!!"	newMeta := Metaclass new.	newMeta 		superclass: newSuperMeta 		methodDictionary: MethodDictionary new 		format: newSuperMeta format.			"compute new instVarsNames"	instVarArray := pp , rp , ipp , irp.	instVarArray := instVarArray collect: [:assoc | assoc key asString].	usedNames := aSuperDesc allInstVarNames asSet.	instVarArray := instVarArray reject: [:iv | usedNames includes: iv ].			"MAGIC 2 HERE !!!!!!!!"	newClass := newMeta new.		"this is neccary for [ClassBuilder>>validateInstvars: instVarArray from: oldClass forSuper: newSuper] called in [establishPorts...]"	oldClass := (aSuperDesc environment) at: aNameSymb  ifAbsent: [ nil ].	oldClass isBehavior ifFalse: [ oldClass := nil ].		"we have to verify new instVar names and compute class format"	cb := ClassBuilder new.	cb validateInstvars: instVarArray from: oldClass forSuper: aSuperDesc.	newFormat := cb computeFormat: (aSuperDesc typeOfClass) instSize: (instVarArray size) forSuper: aSuperDesc ccIndex: (oldClass ifNil:[0] ifNotNil:[oldClass indexIfCompact]).		"we set up the newClass"	newClass 		superclass: aSuperDesc		methodDictionary: MethodDictionary new		format: newFormat.	newClass setInstVarNames: instVarArray.	newClass setName: aNameSymb.	newClass initDescriptor.	newClass category: cat.	newClass environment: aSuperDesc environment.	organization := aSuperDesc environment ifNotNil: [ aSuperDesc environment organization ].	organization classify: newClass name under: cat.		self establishPorts: pp role: #provided visibility: #external forClass: newClass oldClass: oldClass superclass: aSuperDesc .	self establishPorts: rp role: #required visibility: #external forClass: newClass oldClass: oldClass superclass: aSuperDesc .	self establishPorts: ipp role: #provided visibility: #internal forClass: newClass oldClass: oldClass superclass: aSuperDesc .	self establishPorts: irp role: #required visibility: #internal forClass: newClass oldClass: oldClass superclass: aSuperDesc .		self establishArchitecture: arch forClass: newClass.	Smalltalk globals flushClassNameCache.	Smalltalk at: aNameSymb put: newClass.	SystemAnnouncer uniqueInstance classAdded: newClass inCategory: cat.	^ newClass.! !!DescriptorBuilder methodsFor: 'private' stamp: 'Fred 2/10/2015 16:55'!addToTargetNewConnectionDescriptionInstance_srcComp: srcCompString srcPort: srcPortString destComp: destCompString destPort: destPortString isDisconn: isDisconn	| inst pports srcComp destComp srcPort destPort |	srcComp := self findComponentFrom: srcCompString.	srcComp isNil ifTrue: [ self error: 'Couldn''t identify component in ', srcCompString, ' sentence' ].	srcPort := self findPortFrom: srcPortString in: srcComp.	destComp := self findComponentFrom: destCompString.	(destComp isKindOf: Component) 		ifTrue: [ 			destPort := self findPortFrom: destPortString in: destComp.	srcComp == sessionTarget "Port can be used as identifier"			ifTrue: [ connectionArray at: srcPortString put: (Array with: destPort with: destComp) ].	(self areInterfacesCompatibleBetween: srcPort and: destPort)			ifFalse: [ self error: 'Incompatible interfaces between ', srcPortString, '@', srcCompString,' and ', destPortString, '@', destCompString ].	 		]		ifFalse: [  			destComp isNil 				ifTrue: [ self error: 'Couldn''t identify component in ', destCompString, ' sentence' ]				ifFalse: [ 					(destPortString compare: 'default') == 2 						ifTrue: [ destPort := 'default' ]						ifFalse: [ self error: 'Literal components have only one provided port named ''default''' ]				]		].						inst := (Smalltalk at: #ConnectionDescription) new.		inst instVarNamed: #ports put: (Dictionary new).	pports := inst instVarNamed: #ports.		pports at: #default put: (Smalltalk at: #DefaultPort) new.	pports at: #args put: (Smalltalk at: #CRequiredPort) new.	pports at: #self put: (Smalltalk at: #SelfPort) new.	pports at: #super put: (Smalltalk at: #SuperPort) new.		pports at: #sourceComponent put: (Smalltalk at: #SRequiredPort) new.	pports at: #sourcePort put: (Smalltalk at: #SRequiredPort) new.	pports at: #destinationComponent put: (Smalltalk at: #SRequiredPort) new.	pports at: #destinationPort put: (Smalltalk at: #SRequiredPort) new.	pports at: #isDisconnection put: (Smalltalk at: #SRequiredPort) new.		pports keysAndValuesDo: [ :n :p |		self initPortInstance: p.		p instVarNamed: #owner put: inst.		((p instVarNamed: #ports) at: #name) cs__connectTo__par01: (n defaultPort).	].		(((pports at: #sourceComponent) instVarNamed: #ports) at: #connectedPorts) cs__connectTo__par01: (srcCompString defaultPort).	(((pports at: #sourcePort) instVarNamed: #ports) at: #connectedPorts) cs__connectTo__par01: (srcPortString defaultPort).	(((pports at: #destinationComponent) instVarNamed: #ports) at: #connectedPorts) cs__connectTo__par01: (destCompString defaultPort).	(((pports at: #destinationPort) instVarNamed: #ports) at: #connectedPorts) cs__connectTo__par01: (destPortString defaultPort).	(((pports at: #isDisconnection) instVarNamed: #ports) at: #connectedPorts) cs__connectTo__par01: (isDisconn defaultPort).			"we connect the new connection description instance to the session target"	 ((((sessionTarget instVarNamed: #ports) at: #architecture) instVarNamed: #ports) at: #connectedPorts)			cs__connectTo__par01: ((((inst instVarNamed: #ports) at: #default) instVarNamed: #ports) at: #default).! !!DescriptorBuilder methodsFor: 'private' stamp: 'Fred 2/7/2015 20:08'!addToTargetNewPortDescriptionInstance_name: aName role: aRole visibility: aVisibility interface: anInterface kind: aKind isCollection: isCollectionPort 	| inst pports  |		inst := (Smalltalk at: #PortDescription) new.		inst instVarNamed: #ports put: (Dictionary new).	pports := inst instVarNamed: #ports.		pports at: #default put: (Smalltalk at: #DefaultPort) new.	pports at: #args put: (Smalltalk at: #CRequiredPort) new.	pports at: #self put: (Smalltalk at: #SelfPort) new.	pports at: #super put: (Smalltalk at: #SuperPort) new.		pports at: #name put: (Smalltalk at: #SRequiredPort) new.	pports at: #role put: (Smalltalk at: #SRequiredPort) new.	pports at: #visibility put: (Smalltalk at: #SRequiredPort) new.	pports at: #interface put: (Smalltalk at: #SRequiredPort) new.	pports at: #kind put: (Smalltalk at: #SRequiredPort) new.	pports at: #isCollectionPort put: (Smalltalk at: #SRequiredPort) new.		pports keysAndValuesDo: [ :n :p |		self initPortInstance: p.		p instVarNamed: #owner put: inst.		((p instVarNamed: #ports) at: #name) cs__connectTo__par01: (n defaultPort).	].		(((pports at: #name) instVarNamed: #ports) at: #connectedPorts) cs__connectTo__par01: (aName defaultPort).	(((pports at: #role) instVarNamed: #ports) at: #connectedPorts) cs__connectTo__par01: (aRole defaultPort).	(((pports at: #visibility) instVarNamed: #ports) at: #connectedPorts) cs__connectTo__par01: (aVisibility defaultPort).	(((pports at: #interface) instVarNamed: #ports) at: #connectedPorts) cs__connectTo__par01: (anInterface defaultPort).	(((pports at: #kind) instVarNamed: #ports) at: #connectedPorts) cs__connectTo__par01: (aKind defaultPort).	(((pports at: #isCollectionPort) instVarNamed: #ports) at: #connectedPorts) cs__connectTo__par01: (isCollectionPort defaultPort).	"we connect the new port descrption instance to the session target"	 ((((sessionTarget instVarNamed: #ports) at: #ports) instVarNamed: #ports) at: #connectedPorts)			cs__connectTo__par01: ((((inst instVarNamed: #ports) at: #default) instVarNamed: #ports) at: #default).! !!DescriptorBuilder methodsFor: 'private' stamp: 'PetrSpacek 11/11/2013 16:49'!addToTargetNewServiceInstance_name: aName paramNames: aParamNamesArray tempsNames: aTempsNamesArray code: code	| inst pports servicesign |		inst := (Smalltalk at: #Service) new.		inst instVarNamed: #ports put: (Dictionary new).	pports := inst instVarNamed: #ports.		pports at: #default put: (Smalltalk at: #DefaultPort) new.	pports at: #args put: (Smalltalk at: #CRequiredPort) new.	pports at: #self put: (Smalltalk at: #SelfPort) new.	pports at: #super put: (Smalltalk at: #SuperPort) new.		pports at: #context put: (Smalltalk at: #SRequiredPort) new.	pports at: #serviceSign put: (Smalltalk at: #SRequiredPort) new.	pports at: #tempsN put: (Smalltalk at: #CRequiredPort) new.	pports at: #tempsV put: (Smalltalk at: #CRequiredPort) new.	pports at: #code put: (Smalltalk at: #SRequiredPort) new.		pports keysAndValuesDo: [ :n :p |		self initPortInstance: p.		p instVarNamed: #owner put: inst.		((p instVarNamed: #ports) at: #name) cs__connectTo__par01: (n defaultPort).	].		servicesign := self getServiceSignInstance_name: aName paramNames:  aParamNamesArray.	(((pports at: #serviceSign) instVarNamed: #ports) at: #connectedPorts)		cs__connectTo__par01: ((((servicesign instVarNamed: #ports) at: #default) instVarNamed: #ports) at: #default).			aTempsNamesArray do: [  :n | 			(((pports at: #tempsN) instVarNamed: #ports) at: #connectedPorts)			cs__connectTo__par01: (n defaultPort).	].	(((pports at: #code) instVarNamed: #ports) at: #connectedPorts) cs__connectTo__par01: (code defaultPort).		"we connect the new service instance to the session target"	 ((((sessionTarget instVarNamed: #ports) at: #services) instVarNamed: #ports) at: #connectedPorts)			cs__connectTo__par01: ((((inst instVarNamed: #ports) at: #default) instVarNamed: #ports) at: #default).	! !!DescriptorBuilder methodsFor: 'private' stamp: 'PetrSpacek 10/26/2012 16:45'!establishArchitecture: archArray forClass: aClass	"archArray example: #('connect x@y to a@b' 'disconnect x@y from a@b') "	archArray ifNil: [^self].		archArray do: [:string |		|asc asp adc adp isDisconnection nodes|		nodes := (Smalltalk at: #PPCompoGrammar) parseConnection: string.		((nodes first) value = 'connect') ifTrue: [isDisconnection := false] ifFalse: [isDisconnection := true].		asp := ((nodes at: 2) at: 1) value.		asc := ((nodes at: 2) at: 3).		adp := ((nodes at: 4) at: 1) value.		adc := ((nodes at: 4) at: 3).				(asc isArray)			ifTrue: [				asc := asc first collection copyFrom: (asc first stop) to: (asc last start).			]			ifFalse: [ asc := asc value].		(adc isArray)			ifTrue: [				adc := adc first collection copyFrom: (adc first stop) to: (adc last start).			]			ifFalse: [ adc := adc value].				(isDisconnection)			ifTrue: [aClass addDescriptionOfDisconnectionWithSourceComponent: asc andPort: asp andDestinationComponent: adc andPort: adp kind: #Connection]			ifFalse: [aClass addDescriptionOfConnectionWithSourceComponent: asc andPort: asp andDestinationComponent: adc andPort: adp kind: #Connection].	].	^ self.			! !!DescriptorBuilder methodsFor: 'private' stamp: 'PetrSpacek 11/9/2012 16:55'!establishPorts: aDeclArray role: aRole visibility: aVisibility forClass: aClass oldClass: oldClass superclass: aSuperclass	"aDeclArray example: { #portName1->#(#service1 #service2:). #portName2->#interfaceName. }"	| cb |	aDeclArray ifNil: [ ^ self ].	cb := ClassBuilder new.	aDeclArray		do: [ :anAssoc | 			| portNameStr interface |			portNameStr := anAssoc key asString.			interface := anAssoc value.			[ cb validateInstvars: (Array with: portNameStr) from: oldClass forSuper: aSuperclass ]				on: DuplicatedVariableError				do: [  ].			aClass				addDescriptionOfPortNamed: anAssoc key				interface: interface				role: aRole				visibility: aVisibility				injection: #NULL				kind: #Port				isCollectionPort: false ].	^ self! !!DescriptorBuilder methodsFor: 'private' stamp: 'PetrSpacek 11/11/2013 15:15'!getAllDeclaredPortDescriptionsFrom: aMetaDesc	"returns a dictionary of stacks"	|pdDict currentDesc pd pn|	(aMetaDesc isKindOf: (Smalltalk at: #Descriptor))		ifFalse: [ self error: ((aMetaDesc name asString) , ' has to be a descriptor') ].			pdDict := Dictionary new.		currentDesc := aMetaDesc.		[ currentDesc ~= (Smalltalk at: #Object) ]		whileTrue: [ 						(((((currentDesc instVarNamed: #ports) at: #ports) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts)				do: [ :atomicport |					pd := (atomicport  instVarNamed: #owner) instVarNamed: #owner. "get the current port description"					pn := ((((((pd instVarNamed: #ports) at: #name) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts) at: 1) instVarNamed: #owner.					(pdDict includesKey: pn) ifFalse: [ pdDict at: pn put: (Stack new) ].					(pdDict at: pn) push: pd.				].			"cs__connectTo__par01: ((((pd instVarNamed: #ports) at: #default) instVarNamed: #ports) at: #default)"						currentDesc := currentDesc superclass.			(currentDesc == (Smalltalk at: #Class))				ifTrue: [ currentDesc :=  (Smalltalk at: #Component)].		].			^ pdDict.! !!DescriptorBuilder methodsFor: 'private' stamp: 'PetrSpacek 11/11/2013 16:43'!getServiceSignInstance_name: aName paramNames: aParamNamesArray	| inst pports  |		inst := (Smalltalk at: #ServiceSign) new.		inst instVarNamed: #ports put: (Dictionary new).	pports := inst instVarNamed: #ports.		pports at: #default put: (Smalltalk at: #DefaultPort) new.	pports at: #args put: (Smalltalk at: #CRequiredPort) new.	pports at: #self put: (Smalltalk at: #SelfPort) new.	pports at: #super put: (Smalltalk at: #SuperPort) new.		pports at: #name put: (Smalltalk at: #SRequiredPort) new.	pports at: #paramNames put: (Smalltalk at: #SRequiredPort) new.		pports keysAndValuesDo: [ :n :p |		self initPortInstance: p.		p instVarNamed: #owner put: inst.		((p instVarNamed: #ports) at: #name) cs__connectTo__par01: (n defaultPort).	].		(((pports at: #name) instVarNamed: #ports) at: #connectedPorts) cs__connectTo__par01: (aName defaultPort).	aParamNamesArray do: [ :n |		(((pports at: #paramNames) instVarNamed: #ports) at: #connectedPorts)			cs__connectTo__par01: (n defaultPort).	].			^ inst.! !!DescriptorBuilder methodsFor: 'private' stamp: 'PetrSpacek 11/11/2013 13:35'!initPortInstance: p	| pports |	p instVarNamed: #ports put: (Dictionary new).	pports :=p instVarNamed: #ports.		pports at: #default put: (AtomicPort newNamed: #default owner: p 											role: #provided visibility: #external interface: #*											isCollectionPort: false).	pports at: #args put: (AtomicPort newNamed: #args owner: p 											role: #required visibility: #external interface: #*											isCollectionPort: true).	pports at: #self put: (AtomicPort newNamed: #self  owner: p 											role: #provided visibility: #internal interface: #*											isCollectionPort: false).	pports at: #super put: (AtomicPort newNamed: #super  owner: p 											role: #provided visibility: #internal interface: #*											isCollectionPort: false).	pports at: #owner put: (AtomicPort newNamed: #owner  owner: p 											role: #required visibility: #external interface: #*											isCollectionPort: false).	pports at: #connectedPorts put: (AtomicPort newNamed: #connectedPorts  owner: p 											role: #required visibility: #external interface: #*											isCollectionPort: true).	pports at: #delegatedPorts put: (AtomicPort newNamed: #delegatedPorts  owner: p 											role: #required visibility: #external interface: #*											isCollectionPort: true).	pports at: #name put: (AtomicPort newNamed: #name  owner: p 											role: #required visibility: #internal interface: #*											isCollectionPort: false).	pports at: #interface put: (AtomicPort newNamed: #interface  owner: p 											role: #required visibility: #internal interface: #*											isCollectionPort: false).	pports at: #visibility put: (AtomicPort newNamed: #visibility  owner: p 											role: #required visibility: #internal interface: #*											isCollectionPort: false).	! !!DescriptorBuilder methodsFor: 'private' stamp: 'FerrandAnthony 2/12/2015 14:59'!instOf: aMetaDesc superdescriptor: aSuperDescSymb subdescriptor: aNameSymb category: cat 		| ports superCls newCls pdDict |		((aNameSymb = #Component) or: [ aNameSymb = #Descriptor ])		ifTrue: [			self inform: 'Be careful when modifying ', aNameSymb asString , '!!!!!!'.			newCls := (Smalltalk at: aNameSymb).		]		ifFalse: [			superCls := Smalltalk at: aSuperDescSymb.			superCls				subclass: aNameSymb				instanceVariableNames: ''				classVariableNames: ''				poolDictionaries: ''				category: cat.					newCls := (Smalltalk at: aNameSymb).				(aMetaDesc == (Smalltalk at: #Descriptor))			 	ifFalse: [ 					(aMetaDesc inheritsFrom: (Smalltalk at: #Descriptor))						ifTrue: [ newCls := self remakeCls: newCls asInstOf: aMetaDesc. ]						ifFalse:[ self error: (aMetaDesc name asString , ' is not a meta-descriptor.'). ].				].		].			newCls		instVarNamed: #ports		put: Dictionary new.	newCls		instVarNamed: #owner		put: nil.			(aNameSymb = #Component)		ifTrue: [CompoBootstrap initClsComponent].	(aNameSymb = #Descriptor)		ifTrue: [CompoBootstrap initClsDescriptor].	pdDict := self getAllDeclaredPortDescriptionsFrom: aMetaDesc.		ports := newCls instVarNamed: #ports.			pdDict keysAndValuesDo: [ :pn :pdColl |		|pInst pKind pVisibility pd|		pd := self applyPortInheritanceRulez: pdColl.		pKind := ((((((pd instVarNamed: #ports) at: #kind) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts) at: 1) instVarNamed: #owner.		pVisibility := ((((((pd instVarNamed: #ports) at: #visibility) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts) at: 1) instVarNamed: #owner.		pInst := (Smalltalk at: pKind) new.		self initPortInstance: pInst.		pInst instVarNamed: #owner put: newCls.		((pInst instVarNamed: #ports) at: #name) cs__connectTo__par01: (pn defaultPort).		((pInst instVarNamed: #ports) at: #visibility) cs__connectTo__par01: (pVisibility defaultPort).		ports at: pn put: pInst.	].	"connect owner port of ports"	ports do: [ :p |		((p instVarNamed: #ports) at: #owner) cs__connectTo__par01: ((ports) at: #self).	].		"set descriptor's name"	(((ports at: #name) instVarNamed: #ports) at: #connectedPorts)		cs__connectTo__par01: (Smalltalk at: aNameSymb) name defaultPort.		sessionTarget := Smalltalk at: aNameSymb.! !!DescriptorBuilder methodsFor: 'private' stamp: 'FerrandAnthony 2/12/2015 15:47'!remakeCls: aCls asInstOf: aMetaDesc	| temp clsName newCls instSizeNew instSizeOld | 	clsName := aCls name.	aCls class superclass: aMetaDesc.	aCls class setFormat: aMetaDesc format.	temp := aCls class.	newCls := temp basicNew.	instSizeNew := aMetaDesc instSize.	instSizeOld := Object class instSize.	1 to: instSizeNew do: [ :i | 		i < (instSizeOld + 1)			ifTrue: [ newCls instVarAt: i put: (aCls instVarAt: i) ]			ifFalse: [ newCls instVarAt: i put: nil ] ].	temp instVarAt: (temp class instVarIndexFor: #thisClass) put: newCls.	"re-register new class in global dictionary"	Smalltalk at: clsName put: temp soleInstance.	newCls := temp soleInstance.	temp := nil.			" we copy methods from [Object class] to [newCls class] "	Object class methodDict do: [ :m | newCls class compile: m getSource classified: 'object class protocol' ].		^ newCls.! !!DescriptorBuilder methodsFor: 'fred-add' stamp: 'Fred 2/10/2015 19:28'!areInterfacesCompatibleBetween: aPort and: anotherPort	| firstPortInterface secondPortInterface matcherSign serviceArray |	serviceArray := Dictionary new.	matcherSign := RxMatcher forString: '[ ]*([a-zA-Z0-9]+)\(([a-zA-Z0-9, ]*)\)[ ]*'.	firstPortInterface := ((((((aPort instVarNamed: #ports) at: #interface) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts) at: 1) instVarNamed: #owner.	secondPortInterface := ((((((anotherPort instVarNamed: #ports) at: #interface) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts) at: 1) instVarNamed: #owner.	secondPortInterface do: [ :service |		(matcherSign matches: service) ifTrue: [ 			| arguments |			arguments := matcherSign subexpression: 3.			arguments isAllSeparators				ifTrue: [ serviceArray at: (matcherSign subexpression: 2) put: 0 ]			 	ifFalse: [ serviceArray at: (matcherSign subexpression: 2) put: ((arguments subStrings: ',') size) ].		].	].	firstPortInterface isArray ifTrue: [ 		firstPortInterface do: [ :service |			(matcherSign matches: service) ifTrue: [ 				| name arguments argsCount |				name := matcherSign subexpression: 2.				arguments := matcherSign subexpression: 3.				arguments isAllSeparators					ifTrue: [ argsCount := 0 ]				 	ifFalse: [ argsCount := (arguments subStrings: ',') size ].				(serviceArray includesKey: name) 					ifTrue: [ 						(serviceArray at: name) == argsCount ifFalse: [ ^false ]					]					ifFalse: [ ^false ]			].		].	]	ifFalse: [ ^true ].	^true! !!DescriptorBuilder methodsFor: 'fred-add' stamp: 'Fred 2/10/2015 16:47'!findComponentFrom: compString 	| matcher comp |	matcher := RxMatcher forString: '\([ ]*([a-zA-Z0-9]+).new\(\)[ ]*\)'.	((compString compare: 'self') == 2) ifTrue: [ 		comp := sessionTarget.	] ifFalse: [ 		(matcher matches: compString) ifTrue: [ 			comp := Smalltalk at: ((matcher subexpression: 2) asSymbol).		]		ifFalse: [ 			(connectionArray includesKey: compString) 				ifTrue: [ comp := (connectionArray at: compString) at: 2]				ifFalse: [ 					(Smalltalk includesKey: (compString asSymbol))						ifTrue: [ comp :=  (Smalltalk at: (compString asSymbol)) getDescriptor ]						ifFalse: [ 							^compString 						] 				]		]	 ].	^comp! !!DescriptorBuilder methodsFor: 'fred-add' stamp: 'Fred 2/10/2015 16:13'!findPortFrom: portString in: compDesc 	| portList |	(compDesc isKindOf: Metaclass) 		ifTrue: [ 			portList := self getPortListOf: (compDesc thisClass)			]		ifFalse: [ 			portList := self getPortListOf: compDesc		].	portList do: [ :port |		| portName |		portName := (((((((port instVarNamed: #ports) at: #name) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts) at: 1) instVarNamed: #owner) asString.		((portName compare: portString) == 2)			ifTrue: [ ^ port ]	].	self error: 'Couldn''t find the port named ', portString, ' in ', (compDesc name asStringOrText)	! !!DescriptorBuilder methodsFor: 'fred-add' stamp: 'Fred 2/10/2015 16:11'!getPortListOf: compDesc	| parent intermediateList portList |	portList := OrderedCollection new.	intermediateList := ((((compDesc instVarNamed: #ports) at: #ports) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts.	intermediateList do: [ :iPort |		portList add: ((iPort instVarNamed: #owner) instVarNamed: #owner).	].	compDesc == Component ifTrue: [ 		^ portList	]	ifFalse: [ 		portList addAll: (self getPortListOf: (compDesc superclass)).		^portList	]! !Object subclass: #Component	instanceVariableNames: 'ports owner'	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Meta'!!Component methodsFor: 'default-interface' stamp: 'PetrSpacek 11/24/2013 22:34'!cs__getDescriptor	^ ((self primitive_getDescriptor "compo vm primitive call")).! !!Component methodsFor: 'default-interface' stamp: 'PetrSpacek 11/24/2013 22:34'!cs__getIdentityHash	^ ((self primitive_getIdentityHash "compo vm primitive call")).! !!Component methodsFor: 'default-interface' stamp: 'PetrSpacek 11/24/2013 22:34'!cs__getOwner	^ ((self primitive_getOwner "compo vm primitive call")).! !!Component methodsFor: 'default-interface' stamp: 'Fred 1/24/2015 17:25'!cs__getPortNamed: nameS	^ ((self primitive_getPortNamed: nameS "compo vm primitive call")).! !!Component methodsFor: 'default-interface' stamp: 'PetrSpacek 11/25/2013 00:46'!cs__getPortNamed__par01: nameS	^ ((self primitive_getPortNamed: nameS "compo vm primitive call")).! !!Component methodsFor: 'default-interface' stamp: 'PetrSpacek 11/24/2013 22:34'!cs__getPorts	^ ((self primitive_getPorts "compo vm primitive call")).! !!Component methodsFor: 'compo-private' stamp: 'PetrSpacek 11/25/2013 03:21'!cs__invoke__par01: serviceInv par02: isMetaCall	^ serviceInv  sendTo: self.! !!Component methodsFor: 'compo-private' stamp: 'PetrSpacek 11/24/2013 22:35'!primitive_getDescriptor	^ (self class instVarNamed: #ports) at: #default.! !!Component methodsFor: 'compo-private' stamp: 'PetrSpacek 11/24/2013 22:34'!primitive_getIdentityHash	^ self identityHash .! !!Component methodsFor: 'compo-private' stamp: 'PetrSpacek 11/24/2013 22:33'!primitive_getOwner	((self instVarNamed: #owner) isKindOf: (Smalltalk at: #Component))		ifTrue: [ ^ ((self instVarNamed: #owner) instVarNamed: #ports) at: #default ]		ifFalse: [ ^ (self instVarNamed: #owner) defaultPort ].! !!Component methodsFor: 'compo-private' stamp: 'PetrSpacek 11/24/2013 22:30'!primitive_getPortNamed: name	^ (self instVarNamed: #ports) at: name.! !!Component methodsFor: 'compo-private' stamp: 'PetrSpacek 11/24/2013 22:30'!primitive_getPorts	^ (self instVarNamed: #ports).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Component class	instanceVariableNames: ''!!Component class methodsFor: 'Object class protocol' stamp: 'PetrSpacek 11/22/2013 14:25'!fileReaderServicesForDirectory: aFileDirectory	<directoryService>	"Backstop"	^#()! !!Component class methodsFor: 'Object class protocol' stamp: 'PetrSpacek 11/22/2013 14:25'!fileReaderServicesForFile: fullName suffix: suffix	<fileService>	"Backstop"	^#()! !!Component class methodsFor: 'Object class protocol' stamp: 'PetrSpacek 11/22/2013 14:25'!flushDependents	DependentsFields keysAndValuesDo:[:key :dep|		key ifNotNil:[key removeDependent: nil].	].	DependentsFields finalizeValues.! !!Component class methodsFor: 'Object class protocol' stamp: 'PetrSpacek 11/22/2013 14:25'!flushEvents	"Object flushEvents"	EventManager flushEvents. ! !!Component class methodsFor: 'Object class protocol' stamp: 'PetrSpacek 11/22/2013 14:25'!howToModifyPrimitives	"You are allowed to write methods which specify primitives, but please use 	caution.  If you make a subclass of a class which contains a primitive method, 	the subclass inherits the primitive.  The message which is implemented 	primitively may be overridden in the subclass (E.g., see at:put: in String's 	subclass Symbol).  The primitive behavior can be invoked using super (see 	Symbol string:). 	 	A class which attempts to mimic the behavior of another class without being 	its subclass may or may not be able to use the primitives of the original class.  	In general, if the instance variables read or written by a primitive have the 	same meanings and are in the same fields in both classes, the primitive will 	work.  	For certain frequently used 'special selectors', the compiler emits a 	send-special-selector bytecode instead of a send-message bytecode.  	Special selectors were created because they offer two advantages.  Code 	which sends special selectors compiles into fewer bytes than normal.  For 	some pairs of receiver classes and special selectors, the interpreter jumps 	directly to a primitive routine without looking up the method in the class.  	This is much faster than a normal message lookup. 	 	A selector which is a special selector solely in order to save space has a 	normal behavior.  Methods whose selectors are special in order to 	gain speed contain the comment, 'No Lookup'.  When the interpreter 	encounters a send-special-selector bytecode, it checks the class of the 	receiver and the selector.  If the class-selector pair is a no-lookup pair, 	then the interpreter swiftly jumps to the routine which implements the 	corresponding primitive.  (A special selector whose receiver is not of the 	right class to make a no-lookup pair, is looked up normally).  The pairs are 	listed below.  No-lookup methods contain a primitive number specification, 	<primitive: xx>, which is redundant.  Since the method is not normally looked 	up, deleting the primitive number specification cannot prevent this 	primitive from running.  If a no-lookup primitive fails, the method is looked 	up normally, and the expressions in it are executed. 	 	No Lookup pairs of (class, selector) 	 	SmallInteger with any of		+ - * /  \\  bitOr: bitShift: bitAnd:  // 	SmallInteger with any of		=  ~=  >  <  >=  <= 	Any class with					== 	Any class with 					@ 	Point with either of				x y 	ContextPart with					blockCopy: 	BlockContext with either of 		value value:	"	self error: 'comment only'! !!Component class methodsFor: 'Object class protocol' stamp: 'PetrSpacek 11/22/2013 14:25'!initialize	"Object initialize"	DependentsFields ifNil:[self initializeDependentsFields].! !!Component class methodsFor: 'Object class protocol' stamp: 'PetrSpacek 11/22/2013 14:25'!initializeDependentsFields	"Object initialize"	DependentsFields := WeakIdentityKeyDictionary new.! !!Component class methodsFor: 'Object class protocol' stamp: 'PetrSpacek 11/22/2013 14:25'!lastMetacelloVersionLoad	"Answer the last version loaded and the list of packages loaded for that version.	 See MetacelloConfigTemplate."	^nil -> 'default'! !!Component class methodsFor: 'Object class protocol' stamp: 'PetrSpacek 11/22/2013 14:25'!metacelloVersion: versionString loads: anArrayOrString	"Stash the last version loaded and the list of packages loaded for that version. The list	 of packages will be used by the tools when doing 'Load Package Version'.	See MetacelloConfigTemplate for example"		"noop by default"! !!Component class methodsFor: 'Object class protocol' stamp: 'PetrSpacek 11/22/2013 14:25'!newFrom: aSimilarObject	"Create an object that has similar contents to aSimilarObject. If the classes have any instance varaibles with the same names, copy them across. If this is bad for a class, override this method."	^ (self isVariable		ifTrue: [self basicNew: aSimilarObject basicSize]		ifFalse: [self basicNew]) copySameFrom: aSimilarObject! !!Component class methodsFor: 'Object class protocol' stamp: 'PetrSpacek 11/22/2013 14:25'!reInitializeDependentsFields	"Object reInitializeDependentsFields"	| oldFields |	oldFields := DependentsFields.	DependentsFields := WeakIdentityKeyDictionary new.	oldFields keysAndValuesDo:[:obj :deps|		deps do:[:d| obj addDependent: d]].! !!Component class methodsFor: 'Object class protocol' stamp: 'PetrSpacek 11/22/2013 14:25'!readFrom: textStringOrStream	"Create an object based on the contents of textStringOrStream."	| object |	(self class evaluatorClass couldEvaluate: textStringOrStream)		ifFalse: [^ self error: 'expected String, Stream, or Text'].	object := self class evaluatorClass evaluate: textStringOrStream.	(object isKindOf: self) ifFalse: [self error: self name, ' expected'].	^object! !!Component class methodsFor: 'Object class protocol' stamp: 'PetrSpacek 11/22/2013 14:25'!registerToolsOn: aToolRegistry	" Override to register any tools for Smalltalk tools registry. " ! !!Component class methodsFor: 'Object class protocol' stamp: 'PetrSpacek 11/22/2013 14:25'!services	"Backstop"	^#()! !!Component class methodsFor: 'Object class protocol' stamp: 'PetrSpacek 11/22/2013 14:25'!taskbarIcon	"Answer the icon for an instance of the receiver in a task bar	or nil for the default."	^nil ! !!Component class methodsFor: 'Object class protocol' stamp: 'PetrSpacek 11/22/2013 14:25'!taskbarLabel	"Answer the label string for the receiver in a task bar	or nil for the default."	^nil! !!Component class methodsFor: 'Object class protocol' stamp: 'PetrSpacek 11/22/2013 14:25'!whatIsAPrimitive	"Some messages in the system are responded to primitively. A primitive   	response is performed directly by the interpreter rather than by evaluating   	expressions in a method. The methods for these messages indicate the   	presence of a primitive response by including <primitive: xx> before the   	first expression in the method.   	  	Primitives exist for several reasons. Certain basic or 'primitive' 	operations cannot be performed in any other way. Smalltalk without 	primitives can move values from one variable to another, but cannot add two 	SmallIntegers together. Many methods for arithmetic and comparison 	between numbers are primitives. Some primitives allow Smalltalk to 	communicate with I/O devices such as the disk, the display, and the keyboard. 	Some primitives exist only to make the system run faster; each does the same 	thing as a certain Smalltalk method, and its implementation as a primitive is 	optional.  	  	When the Smalltalk interpreter begins to execute a method which specifies a 	primitive response, it tries to perform the primitive action and to return a 	result. If the routine in the interpreter for this primitive is successful, 	it will return a value and the expressions in the method will not be evaluated. 	If the primitive routine is not successful, the primitive 'fails', and the 	Smalltalk expressions in the method are executed instead. These 	expressions are evaluated as though the primitive routine had not been 	called.  	  	The Smalltalk code that is evaluated when a primitive fails usually 	anticipates why that primitive might fail. If the primitive is optional, the 	expressions in the method do exactly what the primitive would have done (See 	Number @). If the primitive only works on certain classes of arguments, the 	Smalltalk code tries to coerce the argument or appeals to a superclass to find 	a more general way of doing the operation (see SmallInteger +). If the 	primitive is never supposed to fail, the expressions signal an error (see 	SmallInteger asFloat).  	  	Each method that specifies a primitive has a comment in it. If the primitive is 	optional, the comment will say 'Optional'. An optional primitive that is not 	implemented always fails, and the Smalltalk expressions do the work 	instead.  	 	If a primitive is not optional, the comment will say, 'Essential'. Some 	methods will have the comment, 'No Lookup'. See Object 	howToModifyPrimitives for an explanation of special selectors which are 	not looked up.  	  	For the primitives for +, -, *, and bitShift: in SmallInteger, and truncated 	in Float, the primitive constructs and returns a 16-bit 	LargePositiveInteger when the result warrants it. Returning 16-bit 	LargePositiveIntegers from these primitives instead of failing is 	optional in the same sense that the LargePositiveInteger arithmetic 	primitives are optional. The comments in the SmallInteger primitives say, 	'Fails if result is not a SmallInteger', even though the implementor has the 	option to construct a LargePositiveInteger. For further information on 	primitives, see the 'Primitive Methods' part of the chapter on the formal 	specification of the interpreter in the Smalltalk book."	self error: 'comment only'! !Component subclass: #MemoObject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Meta'!!MemoObject methodsFor: 'default-interface' stamp: 'Fred 11/25/2014 11:36'!cs__main	((self cs__getPortNamed__par01: (#compteur)) cs__invoke__par01: (ServiceInvocation selector: #initialiser arguments: {} originPort: (self cs__getPortNamed__par01: (#compteur)) ) par02: false)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MemoObject class	instanceVariableNames: ''!!MemoObject class methodsFor: 'object class protocol' stamp: 'Fred 11/25/2014 11:36'!fileReaderServicesForDirectory: aFileDirectory	<directoryService>	"Backstop"	^#()! !!MemoObject class methodsFor: 'object class protocol' stamp: 'Fred 11/25/2014 11:36'!fileReaderServicesForFile: fullName suffix: suffix	<fileService>	"Backstop"	^#()! !!MemoObject class methodsFor: 'object class protocol' stamp: 'Fred 11/25/2014 11:36'!flushDependents	DependentsFields keysAndValuesDo:[:key :dep|		key ifNotNil:[key removeDependent: nil].	].	DependentsFields finalizeValues.! !!MemoObject class methodsFor: 'object class protocol' stamp: 'Fred 11/25/2014 11:36'!flushEvents	"Object flushEvents"	EventManager flushEvents. ! !!MemoObject class methodsFor: 'object class protocol' stamp: 'Fred 11/25/2014 11:36'!howToModifyPrimitives	"You are allowed to write methods which specify primitives, but please use 	caution.  If you make a subclass of a class which contains a primitive method, 	the subclass inherits the primitive.  The message which is implemented 	primitively may be overridden in the subclass (E.g., see at:put: in String's 	subclass Symbol).  The primitive behavior can be invoked using super (see 	Symbol string:). 	 	A class which attempts to mimic the behavior of another class without being 	its subclass may or may not be able to use the primitives of the original class.  	In general, if the instance variables read or written by a primitive have the 	same meanings and are in the same fields in both classes, the primitive will 	work.  	For certain frequently used 'special selectors', the compiler emits a 	send-special-selector bytecode instead of a send-message bytecode.  	Special selectors were created because they offer two advantages.  Code 	which sends special selectors compiles into fewer bytes than normal.  For 	some pairs of receiver classes and special selectors, the interpreter jumps 	directly to a primitive routine without looking up the method in the class.  	This is much faster than a normal message lookup. 	 	A selector which is a special selector solely in order to save space has a 	normal behavior.  Methods whose selectors are special in order to 	gain speed contain the comment, 'No Lookup'.  When the interpreter 	encounters a send-special-selector bytecode, it checks the class of the 	receiver and the selector.  If the class-selector pair is a no-lookup pair, 	then the interpreter swiftly jumps to the routine which implements the 	corresponding primitive.  (A special selector whose receiver is not of the 	right class to make a no-lookup pair, is looked up normally).  The pairs are 	listed below.  No-lookup methods contain a primitive number specification, 	<primitive: xx>, which is redundant.  Since the method is not normally looked 	up, deleting the primitive number specification cannot prevent this 	primitive from running.  If a no-lookup primitive fails, the method is looked 	up normally, and the expressions in it are executed. 	 	No Lookup pairs of (class, selector) 	 	SmallInteger with any of		+ - * /  \\  bitOr: bitShift: bitAnd:  // 	SmallInteger with any of		=  ~=  >  <  >=  <= 	Any class with					== 	Any class with 					@ 	Point with either of				x y 	ContextPart with					blockCopy: 	BlockContext with either of 		value value:	"	self error: 'comment only'! !!MemoObject class methodsFor: 'object class protocol' stamp: 'Fred 11/25/2014 11:36'!initialize	"Object initialize"	DependentsFields ifNil:[self initializeDependentsFields].! !!MemoObject class methodsFor: 'object class protocol' stamp: 'Fred 11/25/2014 11:36'!initializeDependentsFields	"Object initialize"	DependentsFields := WeakIdentityKeyDictionary new.! !!MemoObject class methodsFor: 'object class protocol' stamp: 'Fred 11/25/2014 11:36'!lastMetacelloVersionLoad	"Answer the last version loaded and the list of packages loaded for that version.	 See MetacelloConfigTemplate."	^nil -> 'default'! !!MemoObject class methodsFor: 'object class protocol' stamp: 'Fred 11/25/2014 11:36'!metacelloVersion: versionString loads: anArrayOrString	"Stash the last version loaded and the list of packages loaded for that version. The list	 of packages will be used by the tools when doing 'Load Package Version'.	See MetacelloConfigTemplate for example"		"noop by default"! !!MemoObject class methodsFor: 'object class protocol' stamp: 'Fred 11/25/2014 11:36'!newC	|inst|	inst := self new.	^ inst defaultPort.! !!MemoObject class methodsFor: 'object class protocol' stamp: 'Fred 11/25/2014 11:36'!newFrom: aSimilarObject	"Create an object that has similar contents to aSimilarObject. If the classes have any instance varaibles with the same names, copy them across. If this is bad for a class, override this method."	^ (self isVariable		ifTrue: [self basicNew: aSimilarObject basicSize]		ifFalse: [self basicNew]) copySameFrom: aSimilarObject! !!MemoObject class methodsFor: 'object class protocol' stamp: 'Fred 11/25/2014 11:36'!reInitializeDependentsFields	"Object reInitializeDependentsFields"	| oldFields |	oldFields := DependentsFields.	DependentsFields := WeakIdentityKeyDictionary new.	oldFields keysAndValuesDo:[:obj :deps|		deps do:[:d| obj addDependent: d]].! !!MemoObject class methodsFor: 'object class protocol' stamp: 'Fred 11/25/2014 11:36'!readFrom: textStringOrStream	"Create an object based on the contents of textStringOrStream."	| object |	(self class evaluatorClass couldEvaluate: textStringOrStream)		ifFalse: [^ self error: 'expected String, Stream, or Text'].	object := self class evaluatorClass evaluate: textStringOrStream.	(object isKindOf: self) ifFalse: [self error: self name, ' expected'].	^object! !!MemoObject class methodsFor: 'object class protocol' stamp: 'Fred 11/25/2014 11:36'!registerToolsOn: aToolRegistry	" Override to register any tools for Smalltalk tools registry. " ! !!MemoObject class methodsFor: 'object class protocol' stamp: 'Fred 11/25/2014 11:36'!services	"Backstop"	^#()! !!MemoObject class methodsFor: 'object class protocol' stamp: 'Fred 11/25/2014 11:36'!taskbarIcon	"Answer the icon for an instance of the receiver in a task bar	or nil for the default."	^nil ! !!MemoObject class methodsFor: 'object class protocol' stamp: 'Fred 11/25/2014 11:36'!taskbarLabel	"Answer the label string for the receiver in a task bar	or nil for the default."	^nil! !!MemoObject class methodsFor: 'object class protocol' stamp: 'Fred 11/25/2014 11:36'!whatIsAPrimitive	"Some messages in the system are responded to primitively. A primitive   	response is performed directly by the interpreter rather than by evaluating   	expressions in a method. The methods for these messages indicate the   	presence of a primitive response by including <primitive: xx> before the   	first expression in the method.   	  	Primitives exist for several reasons. Certain basic or 'primitive' 	operations cannot be performed in any other way. Smalltalk without 	primitives can move values from one variable to another, but cannot add two 	SmallIntegers together. Many methods for arithmetic and comparison 	between numbers are primitives. Some primitives allow Smalltalk to 	communicate with I/O devices such as the disk, the display, and the keyboard. 	Some primitives exist only to make the system run faster; each does the same 	thing as a certain Smalltalk method, and its implementation as a primitive is 	optional.  	  	When the Smalltalk interpreter begins to execute a method which specifies a 	primitive response, it tries to perform the primitive action and to return a 	result. If the routine in the interpreter for this primitive is successful, 	it will return a value and the expressions in the method will not be evaluated. 	If the primitive routine is not successful, the primitive 'fails', and the 	Smalltalk expressions in the method are executed instead. These 	expressions are evaluated as though the primitive routine had not been 	called.  	  	The Smalltalk code that is evaluated when a primitive fails usually 	anticipates why that primitive might fail. If the primitive is optional, the 	expressions in the method do exactly what the primitive would have done (See 	Number @). If the primitive only works on certain classes of arguments, the 	Smalltalk code tries to coerce the argument or appeals to a superclass to find 	a more general way of doing the operation (see SmallInteger +). If the 	primitive is never supposed to fail, the expressions signal an error (see 	SmallInteger asFloat).  	  	Each method that specifies a primitive has a comment in it. If the primitive is 	optional, the comment will say 'Optional'. An optional primitive that is not 	implemented always fails, and the Smalltalk expressions do the work 	instead.  	 	If a primitive is not optional, the comment will say, 'Essential'. Some 	methods will have the comment, 'No Lookup'. See Object 	howToModifyPrimitives for an explanation of special selectors which are 	not looked up.  	  	For the primitives for +, -, *, and bitShift: in SmallInteger, and truncated 	in Float, the primitive constructs and returns a 16-bit 	LargePositiveInteger when the result warrants it. Returning 16-bit 	LargePositiveIntegers from these primitives instead of failing is 	optional in the same sense that the LargePositiveInteger arithmetic 	primitives are optional. The comments in the SmallInteger primitives say, 	'Fails if result is not a SmallInteger', even though the implementor has the 	option to construct a LargePositiveInteger. For further information on 	primitives, see the 'Primitive Methods' part of the chapter on the formal 	specification of the interpreter in the Smalltalk book."	self error: 'comment only'! !Component subclass: #NewComponent	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Meta'!Component subclass: #ServiceSign	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Meta'!!ServiceSign methodsFor: 'compo-private' stamp: 'PetrSpacek 11/22/2013 14:25'!printOn: aStream	|selector arguments|	selector := (((((ports at: #name) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts) at: 1) instVarNamed: #owner.	arguments := ((((ports at: #paramNames) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts).	aStream		nextPutAll: 'service ';		nextPutAll: selector asString;		nextPut: $(.		arguments do: [ :dp |		aStream			nextPutAll: (dp instVarNamed: #owner) asString;			nextPut: $, ;			space.	].	(arguments size > 0) ifTrue: [aStream position: (aStream position - 2)].	aStream nextPut: $); space.! !!ServiceSign methodsFor: 'default-interface' stamp: 'PetrSpacek 11/23/2013 07:51'!cs__getParamName__par01: index	! !!ServiceSign methodsFor: 'default-interface' stamp: 'PetrSpacek 11/23/2013 07:51'!cs__getParamsCount	! !!ServiceSign methodsFor: 'default-interface' stamp: 'PetrSpacek 11/23/2013 07:51'!cs__getSelector	! !!ServiceSign methodsFor: 'default-interface' stamp: 'PetrSpacek 11/23/2013 07:51'!cs__setParamName__par01: index	! !!ServiceSign methodsFor: 'default-interface' stamp: 'PetrSpacek 11/23/2013 07:51'!cs__setSelector__par01: name	! !Component subclass: #PortDescription	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Meta'!!PortDescription methodsFor: 'compo-private' stamp: 'PetrSpacek 11/22/2013 14:25'!printOn: aStream	|kind visib role name |		kind := (((((ports at: #kind) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts) at: 1) instVarNamed: #owner.	name := (((((ports at: #name) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts) at: 1) instVarNamed: #owner.	visib:= (((((ports at: #visibility) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts) at: 1) instVarNamed: #owner.	role := (((((ports at: #role) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts) at: 1) instVarNamed: #owner.	aStream		nextPutAll: 'a PortDescription of an ';		nextPutAll: visib asString;		space;		nextPutAll: role asString;		nextPutAll: ' port named ''' ;		nextPutAll: name asString;		nextPutAll: ''' of kind ';		nextPutAll: kind asString.! !Component subclass: #Service	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Meta'!!Service methodsFor: 'compo-private' stamp: 'PetrSpacek 11/22/2013 14:25'!primitive_execute	self halt.! !!Service methodsFor: 'compo-private' stamp: 'PetrSpacek 11/22/2013 14:25'!printOn: aStream	|signature|		signature := ((((((ports at: #serviceSign) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts) at: 1) instVarNamed: #owner) instVarNamed: #owner.	signature printOn: aStream.! !!Service methodsFor: 'default-interface' stamp: 'PetrSpacek 11/22/2013 15:29'!cs__execute	"compo vm primitive call"
	(self primitive_execute).
! !Component subclass: #FooBarExample	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Meta'!Component subclass: #Compteur	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Meta'!!Compteur methodsFor: 'default-interface' stamp: 'FerrandAnthony 2/12/2015 16:24'!cs__decrementer	| t |	t := ((((self cs__getPortNamed__par01: (#compteurVal)) cs__invoke__par01: (ServiceInvocation selector: #asString arguments: {} originPort: (self cs__getPortNamed__par01: (#compteurVal)) ) par02: false)) cs__invoke__par01: (ServiceInvocation selector: #asInteger arguments: {} originPort: (((self cs__getPortNamed__par01: (#compteurVal)) cs__invoke__par01: (ServiceInvocation selector: #asString arguments: {} originPort: (self cs__getPortNamed__par01: (#compteurVal)) ) par02: false)) ) par02: false) 				- 1.	(((self cs__getPortNamed: #self) cs__invoke__par01: (ServiceInvocation selector: #getPortNamed arguments: { #'compteurVal'} originPort: (self cs__getPortNamed: #self) index: nil) par02: false))		cs__connectTo__par01: (t).! !!Compteur methodsFor: 'default-interface' stamp: 'Fred 2/11/2015 14:39'!cs__getPrinter	^ (self cs__getPortNamed__par01: (#printer)).! !!Compteur methodsFor: 'default-interface' stamp: 'Fred 2/11/2015 14:39'!cs__getValue	^ (self cs__getPortNamed__par01: (#compteurVal)).! !!Compteur methodsFor: 'default-interface' stamp: 'FerrandAnthony 2/12/2015 16:24'!cs__incrementer	| t |	t := ((((self cs__getPortNamed__par01: (#compteurVal)) cs__invoke__par01: (ServiceInvocation selector: #asString arguments: {} originPort: (self cs__getPortNamed__par01: (#compteurVal)) ) par02: false)) cs__invoke__par01: (ServiceInvocation selector: #asInteger arguments: {} originPort: (((self cs__getPortNamed__par01: (#compteurVal)) cs__invoke__par01: (ServiceInvocation selector: #asString arguments: {} originPort: (self cs__getPortNamed__par01: (#compteurVal)) ) par02: false)) ) par02: false) 				+ 1.	(((self cs__getPortNamed: #self) cs__invoke__par01: (ServiceInvocation selector: #getPortNamed arguments: { #'compteurVal'} originPort: (self cs__getPortNamed: #self) index: nil) par02: false))		cs__connectTo__par01: (t).! !!Compteur methodsFor: 'default-interface' stamp: 'Fred 2/11/2015 14:39'!cs__initialiser	(((self cs__getPortNamed__par01: #compteurVal)) cs__invoke__par01: (ServiceInvocation selector: #connectTo arguments: {(1). } originPort: ((self cs__getPortNamed__par01: #compteurVal)) ) par02: true)! !!Compteur methodsFor: 'default-interface' stamp: 'Fred 10/14/2014 22:35'!cs__main	(((self cs__getPortNamed: #self) cs__invoke__par01: (ServiceInvocation selector: #getPortNamed arguments: { #'printer'} originPort: (self cs__getPortNamed: #self) index: nil) par02: false))		cs__connectTo__par01: (((((Printer cs__getPortNamed__par01: #default) cs__invoke__par01: (ServiceInvocation selector: #new arguments: {} originPort: (Printer cs__getPortNamed__par01: #default) ) par02: false)) cs__invoke__par01: (ServiceInvocation selector: #getPortNamed arguments: { #'printing'} originPort: (((Printer cs__getPortNamed__par01: #default) cs__invoke__par01: (ServiceInvocation selector: #new arguments: {} originPort: (Printer cs__getPortNamed__par01: #default) ) par02: false)) index: nil) par02: false)).! !!Compteur methodsFor: 'default-interface' stamp: 'FerrandAnthony 2/12/2015 16:24'!cs__showResult	((self cs__getPortNamed__par01: (#printer)) cs__invoke__par01: (ServiceInvocation selector: #print arguments: {(((self cs__getPortNamed__par01: (#compteurVal)) cs__invoke__par01: (ServiceInvocation selector: #asString arguments: {} originPort: (self cs__getPortNamed__par01: (#compteurVal)) ) par02: false)). } originPort: (self cs__getPortNamed__par01: (#printer)) ) par02: false)! !Component subclass: #ConnectionDescription	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Meta'!!ConnectionDescription methodsFor: 'compo-private' stamp: 'PetrSpacek 11/22/2013 14:25'!printOn: aStream	|srcC srcP destC destP isDis |		srcP := (((((ports at: #sourcePort) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts) at: 1) instVarNamed: #owner.	srcC := (((((ports at: #sourceComponent) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts) at: 1) instVarNamed: #owner.	destC := (((((ports at: #destinationComponent) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts) at: 1) instVarNamed: #owner.	destP := (((((ports at: #destinationPort) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts) at: 1) instVarNamed: #owner.	isDis := (((((ports at: #isDisconnection) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts) at: 1) instVarNamed: #owner.	aStream nextPutAll: 'a description of a '.	(isDis)		ifTrue: [ aStream nextPutAll: 'disconnection' ]		ifFalse: [ aStream nextPutAll: 'connection' ].	aStream		space;		nextPutAll: 'from ';		nextPutAll: srcP asString;		nextPut: $@;		nextPutAll: srcC asString;		nextPutAll: ' to ';		nextPutAll: destP asString;		nextPut: $@;		nextPutAll: destC asString.! !Component subclass: #CompteurTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Meta'!!CompteurTest methodsFor: 'default-interface' stamp: 'Fred 10/14/2014 22:46'!cs__decrementer	((self cs__getPortNamed__par01: (#compteurVal)) cs__invoke__par01: (ServiceInvocation selector: #setValue arguments: {(((self cs__getPortNamed__par01: (#compteurVal)) cs__invoke__par01: (ServiceInvocation selector: #getValue arguments: {} originPort: (self cs__getPortNamed__par01: (#compteurVal)) ) par02: false) 		- 1). } originPort: (self cs__getPortNamed__par01: (#compteurVal)) ) par02: false)! !!CompteurTest methodsFor: 'default-interface' stamp: 'Fred 10/14/2014 22:46'!cs__incrementer	((self cs__getPortNamed__par01: (#compteurVal)) cs__invoke__par01: (ServiceInvocation selector: #setValue arguments: {(((self cs__getPortNamed__par01: (#compteurVal)) cs__invoke__par01: (ServiceInvocation selector: #getValue arguments: {} originPort: (self cs__getPortNamed__par01: (#compteurVal)) ) par02: false) 		+ 1). } originPort: (self cs__getPortNamed__par01: (#compteurVal)) ) par02: false)! !!CompteurTest methodsFor: 'default-interface' stamp: 'Fred 10/14/2014 22:46'!cs__initialiser	((self cs__getPortNamed__par01: (#compteurVal)) cs__invoke__par01: (ServiceInvocation selector: #setValue arguments: {(0). } originPort: (self cs__getPortNamed__par01: (#compteurVal)) ) par02: false)! !!CompteurTest methodsFor: 'default-interface' stamp: 'Fred 2/11/2015 14:39'!cs__main	(((self cs__getPortNamed: #compteur) cs__invoke__par01: (ServiceInvocation selector: #getPortNamed arguments: { #'printer'} originPort: (self cs__getPortNamed: #compteur) index: nil) par02: false))		cs__connectTo__par01: (((self cs__getPortNamed: #printer) cs__invoke__par01: (ServiceInvocation selector: #getPortNamed arguments: { #'printing'} originPort: (self cs__getPortNamed: #printer) index: nil) par02: false))..	((self cs__getPortNamed__par01: (#compteur)) cs__invoke__par01: (ServiceInvocation selector: #showResult arguments: {} originPort: (self cs__getPortNamed__par01: (#compteur)) ) par02: false)! !!CompteurTest methodsFor: 'default-interface' stamp: 'Fred 10/14/2014 22:46'!cs__showResult	((self cs__getPortNamed__par01: (#printer)) cs__invoke__par01: (ServiceInvocation selector: #print arguments: {(((self cs__getPortNamed__par01: (#compteurVal)) cs__invoke__par01: (ServiceInvocation selector: #getValue arguments: {} originPort: (self cs__getPortNamed__par01: (#compteurVal)) ) par02: false)). } originPort: (self cs__getPortNamed__par01: (#printer)) ) par02: false)! !Component subclass: #ServiceMover	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Meta'!!ServiceMover methodsFor: 'default-interface' stamp: 'Fred 6/27/2014 16:05'!cs__move__par01: selector	| srv |	srv := ((self cs__getPortNamed__par01: (#srcDesc)) cs__invoke__par01: (ServiceInvocation selector: #getService arguments: {(selector). } originPort: (self cs__getPortNamed__par01: (#srcDesc)) ) par02: false).	((self cs__getPortNamed__par01: (#destDesc)) cs__invoke__par01: (ServiceInvocation selector: #addService arguments: {(srv). } originPort: (self cs__getPortNamed__par01: (#destDesc)) ) par02: false).	((self cs__getPortNamed__par01: (#srcDesc)) cs__invoke__par01: (ServiceInvocation selector: #removeService arguments: {(selector). } originPort: (self cs__getPortNamed__par01: (#srcDesc)) ) par02: false)! !FooBarExample subclass: #BarC	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Meta'!!BarC methodsFor: 'default-interface' stamp: 'Fred 6/27/2014 13:56'!cs__bar__par01: txt	| str |	str := txt , 'Bar ne serait rien...'.	((self cs__getPortNamed__par01: (#outputP)) cs__invoke__par01: (ServiceInvocation selector: #print arguments: {(str). } originPort: (self cs__getPortNamed__par01: (#outputP)) ) par02: false)! !Component subclass: #IntrospectionTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Meta'!!IntrospectionTest methodsFor: 'default-interface' stamp: 'Fred 6/27/2014 15:35'!cs__getPortsOf__par01: aComponent	| temp temp2 |	temp := ((aComponent) cs__invoke__par01: (ServiceInvocation selector: #getPortNamed arguments: { #'ports'} originPort: (aComponent) index: nil) par02: false).	temp2 := temp.	((self cs__getPortNamed__par01: (#print)) cs__invoke__par01: (ServiceInvocation selector: #print arguments: {(temp2). } originPort: (self cs__getPortNamed__par01: (#print)) ) par02: false).	temp := temp2.	((self cs__getPortNamed__par01: (#print)) cs__invoke__par01: (ServiceInvocation selector: #print arguments: {(temp). } originPort: (self cs__getPortNamed__par01: (#print)) ) par02: false).	temp2 := temp.	((self cs__getPortNamed__par01: (#print)) cs__invoke__par01: (ServiceInvocation selector: #print arguments: {(temp2). } originPort: (self cs__getPortNamed__par01: (#print)) ) par02: false).	temp := temp2.	((self cs__getPortNamed__par01: (#print)) cs__invoke__par01: (ServiceInvocation selector: #print arguments: {(temp). } originPort: (self cs__getPortNamed__par01: (#print)) ) par02: false).	temp2 := temp.	((self cs__getPortNamed__par01: (#print)) cs__invoke__par01: (ServiceInvocation selector: #print arguments: {(temp2). } originPort: (self cs__getPortNamed__par01: (#print)) ) par02: false).	temp := temp2.	^ (temp).! !IntrospectionTest subclass: #Test2	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Meta'!FooBarExample subclass: #FooC	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Meta'!!FooC methodsFor: 'default-interface' stamp: 'Fred 2/10/2015 16:16'!cs__foo	((self cs__getPortNamed__par01: (#outputP)) cs__invoke__par01: (ServiceInvocation selector: #bar arguments: {('Sans Foo, '). } originPort: (self cs__getPortNamed__par01: (#outputP)) ) par02: false)! !Component subclass: #MemoComponent	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Meta'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MemoComponent class	instanceVariableNames: ''!!MemoComponent class methodsFor: 'object class protocol' stamp: 'Fred 11/25/2014 11:39'!fileReaderServicesForDirectory: aFileDirectory	<directoryService>	"Backstop"	^#()! !!MemoComponent class methodsFor: 'object class protocol' stamp: 'Fred 11/25/2014 11:39'!fileReaderServicesForFile: fullName suffix: suffix	<fileService>	"Backstop"	^#()! !!MemoComponent class methodsFor: 'object class protocol' stamp: 'Fred 11/25/2014 11:39'!flushDependents	DependentsFields keysAndValuesDo:[:key :dep|		key ifNotNil:[key removeDependent: nil].	].	DependentsFields finalizeValues.! !!MemoComponent class methodsFor: 'object class protocol' stamp: 'Fred 11/25/2014 11:39'!flushEvents	"Object flushEvents"	EventManager flushEvents. ! !!MemoComponent class methodsFor: 'object class protocol' stamp: 'Fred 11/25/2014 11:39'!howToModifyPrimitives	"You are allowed to write methods which specify primitives, but please use 	caution.  If you make a subclass of a class which contains a primitive method, 	the subclass inherits the primitive.  The message which is implemented 	primitively may be overridden in the subclass (E.g., see at:put: in String's 	subclass Symbol).  The primitive behavior can be invoked using super (see 	Symbol string:). 	 	A class which attempts to mimic the behavior of another class without being 	its subclass may or may not be able to use the primitives of the original class.  	In general, if the instance variables read or written by a primitive have the 	same meanings and are in the same fields in both classes, the primitive will 	work.  	For certain frequently used 'special selectors', the compiler emits a 	send-special-selector bytecode instead of a send-message bytecode.  	Special selectors were created because they offer two advantages.  Code 	which sends special selectors compiles into fewer bytes than normal.  For 	some pairs of receiver classes and special selectors, the interpreter jumps 	directly to a primitive routine without looking up the method in the class.  	This is much faster than a normal message lookup. 	 	A selector which is a special selector solely in order to save space has a 	normal behavior.  Methods whose selectors are special in order to 	gain speed contain the comment, 'No Lookup'.  When the interpreter 	encounters a send-special-selector bytecode, it checks the class of the 	receiver and the selector.  If the class-selector pair is a no-lookup pair, 	then the interpreter swiftly jumps to the routine which implements the 	corresponding primitive.  (A special selector whose receiver is not of the 	right class to make a no-lookup pair, is looked up normally).  The pairs are 	listed below.  No-lookup methods contain a primitive number specification, 	<primitive: xx>, which is redundant.  Since the method is not normally looked 	up, deleting the primitive number specification cannot prevent this 	primitive from running.  If a no-lookup primitive fails, the method is looked 	up normally, and the expressions in it are executed. 	 	No Lookup pairs of (class, selector) 	 	SmallInteger with any of		+ - * /  \\  bitOr: bitShift: bitAnd:  // 	SmallInteger with any of		=  ~=  >  <  >=  <= 	Any class with					== 	Any class with 					@ 	Point with either of				x y 	ContextPart with					blockCopy: 	BlockContext with either of 		value value:	"	self error: 'comment only'! !!MemoComponent class methodsFor: 'object class protocol' stamp: 'Fred 11/25/2014 11:39'!initialize	"Object initialize"	DependentsFields ifNil:[self initializeDependentsFields].! !!MemoComponent class methodsFor: 'object class protocol' stamp: 'Fred 11/25/2014 11:39'!initializeDependentsFields	"Object initialize"	DependentsFields := WeakIdentityKeyDictionary new.! !!MemoComponent class methodsFor: 'object class protocol' stamp: 'Fred 11/25/2014 11:39'!lastMetacelloVersionLoad	"Answer the last version loaded and the list of packages loaded for that version.	 See MetacelloConfigTemplate."	^nil -> 'default'! !!MemoComponent class methodsFor: 'object class protocol' stamp: 'Fred 11/25/2014 11:39'!metacelloVersion: versionString loads: anArrayOrString	"Stash the last version loaded and the list of packages loaded for that version. The list	 of packages will be used by the tools when doing 'Load Package Version'.	See MetacelloConfigTemplate for example"		"noop by default"! !!MemoComponent class methodsFor: 'object class protocol' stamp: 'Fred 11/25/2014 11:39'!newC	|inst|	inst := self new.	^ inst defaultPort.! !!MemoComponent class methodsFor: 'object class protocol' stamp: 'Fred 11/25/2014 11:39'!newFrom: aSimilarObject	"Create an object that has similar contents to aSimilarObject. If the classes have any instance varaibles with the same names, copy them across. If this is bad for a class, override this method."	^ (self isVariable		ifTrue: [self basicNew: aSimilarObject basicSize]		ifFalse: [self basicNew]) copySameFrom: aSimilarObject! !!MemoComponent class methodsFor: 'object class protocol' stamp: 'Fred 11/25/2014 11:39'!reInitializeDependentsFields	"Object reInitializeDependentsFields"	| oldFields |	oldFields := DependentsFields.	DependentsFields := WeakIdentityKeyDictionary new.	oldFields keysAndValuesDo:[:obj :deps|		deps do:[:d| obj addDependent: d]].! !!MemoComponent class methodsFor: 'object class protocol' stamp: 'Fred 11/25/2014 11:39'!readFrom: textStringOrStream	"Create an object based on the contents of textStringOrStream."	| object |	(self class evaluatorClass couldEvaluate: textStringOrStream)		ifFalse: [^ self error: 'expected String, Stream, or Text'].	object := self class evaluatorClass evaluate: textStringOrStream.	(object isKindOf: self) ifFalse: [self error: self name, ' expected'].	^object! !!MemoComponent class methodsFor: 'object class protocol' stamp: 'Fred 11/25/2014 11:39'!registerToolsOn: aToolRegistry	" Override to register any tools for Smalltalk tools registry. " ! !!MemoComponent class methodsFor: 'object class protocol' stamp: 'Fred 11/25/2014 11:39'!services	"Backstop"	^#()! !!MemoComponent class methodsFor: 'object class protocol' stamp: 'Fred 11/25/2014 11:39'!taskbarIcon	"Answer the icon for an instance of the receiver in a task bar	or nil for the default."	^nil ! !!MemoComponent class methodsFor: 'object class protocol' stamp: 'Fred 11/25/2014 11:39'!taskbarLabel	"Answer the label string for the receiver in a task bar	or nil for the default."	^nil! !!MemoComponent class methodsFor: 'object class protocol' stamp: 'Fred 11/25/2014 11:39'!whatIsAPrimitive	"Some messages in the system are responded to primitively. A primitive   	response is performed directly by the interpreter rather than by evaluating   	expressions in a method. The methods for these messages indicate the   	presence of a primitive response by including <primitive: xx> before the   	first expression in the method.   	  	Primitives exist for several reasons. Certain basic or 'primitive' 	operations cannot be performed in any other way. Smalltalk without 	primitives can move values from one variable to another, but cannot add two 	SmallIntegers together. Many methods for arithmetic and comparison 	between numbers are primitives. Some primitives allow Smalltalk to 	communicate with I/O devices such as the disk, the display, and the keyboard. 	Some primitives exist only to make the system run faster; each does the same 	thing as a certain Smalltalk method, and its implementation as a primitive is 	optional.  	  	When the Smalltalk interpreter begins to execute a method which specifies a 	primitive response, it tries to perform the primitive action and to return a 	result. If the routine in the interpreter for this primitive is successful, 	it will return a value and the expressions in the method will not be evaluated. 	If the primitive routine is not successful, the primitive 'fails', and the 	Smalltalk expressions in the method are executed instead. These 	expressions are evaluated as though the primitive routine had not been 	called.  	  	The Smalltalk code that is evaluated when a primitive fails usually 	anticipates why that primitive might fail. If the primitive is optional, the 	expressions in the method do exactly what the primitive would have done (See 	Number @). If the primitive only works on certain classes of arguments, the 	Smalltalk code tries to coerce the argument or appeals to a superclass to find 	a more general way of doing the operation (see SmallInteger +). If the 	primitive is never supposed to fail, the expressions signal an error (see 	SmallInteger asFloat).  	  	Each method that specifies a primitive has a comment in it. If the primitive is 	optional, the comment will say 'Optional'. An optional primitive that is not 	implemented always fails, and the Smalltalk expressions do the work 	instead.  	 	If a primitive is not optional, the comment will say, 'Essential'. Some 	methods will have the comment, 'No Lookup'. See Object 	howToModifyPrimitives for an explanation of special selectors which are 	not looked up.  	  	For the primitives for +, -, *, and bitShift: in SmallInteger, and truncated 	in Float, the primitive constructs and returns a 16-bit 	LargePositiveInteger when the result warrants it. Returning 16-bit 	LargePositiveIntegers from these primitives instead of failing is 	optional in the same sense that the LargePositiveInteger arithmetic 	primitives are optional. The comments in the SmallInteger primitives say, 	'Fails if result is not a SmallInteger', even though the implementor has the 	option to construct a LargePositiveInteger. For further information on 	primitives, see the 'Primitive Methods' part of the chapter on the formal 	specification of the interpreter in the Smalltalk book."	self error: 'comment only'! !Component subclass: #Sandra	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Meta'!IntrospectionTest subclass: #Test1	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Meta'!!Test1 methodsFor: 'default-interface' stamp: 'Fred 6/27/2014 15:39'!cs__test	^ ('boo').! !Component subclass: #ComplexExample	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Meta'!ComplexExample subclass: #Compo2	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Meta'!!Compo2 methodsFor: 'default-interface' stamp: 'Fred 6/20/2014 14:46'!cs__run	^ ('c2' 		, ((self cs__getPortNamed__par01: (#out)) cs__invoke__par01: (ServiceInvocation selector: #run arguments: {} originPort: (self cs__getPortNamed__par01: (#out)) ) par02: false)).! !ComplexExample subclass: #Compo3	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Meta'!!Compo3 methodsFor: 'default-interface' stamp: 'Fred 6/20/2014 14:46'!cs__run	^ ('c3' 		, ((self cs__getPortNamed__par01: (#out)) cs__invoke__par01: (ServiceInvocation selector: #run arguments: {} originPort: (self cs__getPortNamed__par01: (#out)) ) par02: false)).! !ComplexExample subclass: #Compo5	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Meta'!!Compo5 methodsFor: 'default-interface' stamp: 'Fred 6/20/2014 14:47'!cs__run	^ ('c5').! !Component subclass: #Port	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Meta'!!Port methodsFor: 'compo-private' stamp: 'PetrSpacek 11/22/2013 14:25'!getName	^ (((ports at: #name) instVarNamed: #connectedPorts) at: 1) owner.! !!Port methodsFor: 'compo-private' stamp: 'PetrSpacek 11/22/2013 14:25'!printString	^ (super printString) , ' named ''' , (self getName asString), ''' ' .! !!Port methodsFor: 'default-interface' stamp: 'Fred 2/10/2015 19:39'!cs__connectTo__par01: port! !!Port methodsFor: 'default-interface' stamp: 'Fred 1/24/2015 17:33'!cs__delegateTo__par01: port	! !!Port methodsFor: 'default-interface' stamp: 'Fred 1/24/2015 17:33'!cs__disconnect	(self primitive__disconnect "compo vm primitive call")! !!Port methodsFor: 'default-interface' stamp: 'Fred 1/24/2015 17:33'!cs__getIterface	! !!Port methodsFor: 'default-interface' stamp: 'Fred 1/24/2015 17:33'!cs__getName	! !!Port methodsFor: 'default-interface' stamp: 'Fred 1/24/2015 17:33'!cs__invoke__par01: service par02: isDerref	! !!Port methodsFor: 'default-interface' stamp: 'Fred 1/24/2015 17:33'!cs__isConnected	^ ((((self cs__getPortNamed__par01: #connectedPorts)) cs__invoke__par01: (ServiceInvocation selector: #isConnected arguments: {} originPort: ((self cs__getPortNamed__par01: #connectedPorts)) ) par02: true)).! !!Port methodsFor: 'default-interface' stamp: 'Fred 1/24/2015 17:33'!cs__isDelegated	! !!Port methodsFor: 'default-interface' stamp: 'Fred 1/24/2015 17:34'!primitive__disconnect	| connectedPorts |	connectedPorts := (ports at: #connectedPorts) instVarNamed: #connectedPorts.	connectedPorts removeAll! !!Port methodsFor: 'as yet unclassified' stamp: 'Fred 2/10/2015 19:51'!isInterfaceCompatibleWith: aPort 	| portInterface selfInterface matcherSign serviceArray |	serviceArray := Dictionary new.	matcherSign := RxMatcher forString: '[ ]*([a-zA-Z0-9]+)\(([a-zA-Z0-9, ]*)\)[ ]*'.	(aPort isKindOf: AtomicPort) 		ifTrue: [ 			(aPort isKindOf: LiteralAtomicPort) 				ifTrue: [ ^true ]				ifFalse: 				[ 					portInterface := aPort instVarNamed: #interface.					portInterface isArray ifFalse: [ 						(portInterface asString compare: '*') 							ifTrue: [ ^true ] 							ifFalse: [  								| portList portName |								(portInterface isKindOf: Component) 									ifTrue: [ 										portList := ((((portInterface instVarNamed: #ports) at: #ports) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts. 										portList  do: [ :portDesc |											portName := (((((((((portDesc instVarNamed: #owner) instVarNamed: #owner) instVarNamed: #ports) at: #name) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts) at: 1) instVarNamed: #owner) asString.											(portName compare: 'default') == 2 												ifTrue: [ 													| interface |													interface := ((((((((portDesc instVarNamed: #owner) instVarNamed: #owner) instVarNamed: #ports) at: #interface) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts) at: 1) instVarNamed: #owner.													(interface asString compare: '*') == 2 													ifTrue: [ ^true ]													ifFalse: [ portInterface := interface ]												]										]									]									ifFalse: [ self error: 'Unknown interface with name ',(portInterface name asString).] "named interface, not yet implemented"							]						]				] 		]		ifFalse: [ 			| portName |			portName := (((((aPort instVarNamed: #ports) at: #name) instVarNamed: #connectedPorts) at: 1)  instVarNamed: #owner) asString.			(portName compare: 'default') == 2 ifTrue: [ ^true ]. "Too dangerous for the moment to check type for default port"			portInterface := (((((aPort instVarNamed: #ports) at: #interface) instVarNamed: #connectedPorts) at: 1)  instVarNamed: #owner).			portInterface isArray 				ifFalse: [ "Named interface, we must get the interface of default port of the component"					| portList |					(portInterface asString compare: '*') == 2 ifTrue: [ ^ true ].					(portInterface isKindOf: Component) 						ifTrue: [ 							portList := ((((portInterface instVarNamed: #ports) at: #ports) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts. 							portList  do: [ :portDesc |								portName := (((((((((portDesc instVarNamed: #owner) instVarNamed: #owner) instVarNamed: #ports) at: #name) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts) at: 1) instVarNamed: #owner) asString.								(portName compare: 'default') == 2 									ifTrue: [ 										| interface |										interface := ((((((((portDesc instVarNamed: #owner) instVarNamed: #owner) instVarNamed: #ports) at: #interface) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts) at: 1) instVarNamed: #owner.										(interface asString compare: '*') == 2 											ifTrue: [ ^true ]											ifFalse: [ portInterface := interface ]									]							]						]						ifFalse: [ self error: 'Unknown interface with name ',(portInterface name asString).] "named interface, not yet implemented"				]		].	selfInterface := ((((self instVarNamed: #ports) at: #interface) instVarNamed: #connectedPorts) at: 1) instVarNamed: #owner.	selfInterface isArray ifFalse: [  		| portList portName |		(selfInterface asString compare: '*') == 2 ifTrue: [ ^ true ].					(selfInterface isKindOf: Component) 			ifTrue: [ 				portList := ((((selfInterface instVarNamed: #ports) at: #ports) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts. 				portList  do: [ :portDesc |					portName := (((((((((portDesc instVarNamed: #owner) instVarNamed: #owner) instVarNamed: #ports) at: #name) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts) at: 1) instVarNamed: #owner) asString.					(portName compare: 'default') == 2 						ifTrue: [ 							| interface |							interface := ((((((((portDesc instVarNamed: #owner) instVarNamed: #owner) instVarNamed: #ports) at: #interface) instVarNamed: #ports) at: #connectedPorts) instVarNamed: #connectedPorts) at: 1) instVarNamed: #owner.							(interface asString compare: '*') == 2 								ifTrue: [ ^true ]								ifFalse: [ selfInterface := interface ]						]				]			]			ifFalse: [ self error: 'Unknown interface with name ',(selfInterface name asString).] "named interface, not yet implemented"	].	portInterface do: [ :service |		(matcherSign matches: service) ifTrue: [ 			| arguments |			arguments := matcherSign subexpression: 3.			arguments isAllSeparators				ifTrue: [ serviceArray at: (matcherSign subexpression: 2) put: 0 ]			 	ifFalse: [ serviceArray at: (matcherSign subexpression: 2) put: ((arguments subStrings: ',') size) ].		].	].	selfInterface do: [ :service |		(matcherSign matches: service) ifTrue: [ 			| name arguments argsCount |			name := matcherSign subexpression: 2.			arguments := matcherSign subexpression: 3.			arguments isAllSeparators				ifTrue: [ argsCount := 0 ]			 	ifFalse: [ argsCount := (arguments subStrings: ',') size ].			(serviceArray includesKey: name) 				ifTrue: [ 					(serviceArray at: name) == argsCount ifFalse: [ ^false ]				]				ifFalse: [ ^false ]		].	].	^true.! !Port subclass: #SinglePort	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Meta'!Port subclass: #CollectionPort	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Meta'!CollectionPort subclass: #CProvidedPort	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Meta'!CollectionPort subclass: #CRequiredPort	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Meta'!!CRequiredPort methodsFor: 'default-interface' stamp: 'Fred 2/10/2015 19:41'!cs__connectTo__par01: port	(self primitive_connectTo: port "compo vm primitive call")! !!CRequiredPort methodsFor: 'default-interface' stamp: 'PetrSpacek 12/15/2013 20:30'!cs__invoke__par01: service par02: isDerref	( isDerref ) ifTrue: [ 		^ (((self cs__getPortNamed__par01: (#self)) cs__invoke__par01: (ServiceInvocation selector: #invoke arguments: {(service). (false). } originPort: (self cs__getPortNamed__par01: (#self)) ) par02: false)).	 ] ifFalse: [		^ ((self primitive_invoke: service "compo vm primitive call")).	 ]
.
! !!CRequiredPort methodsFor: 'default-interface' stamp: 'PetrSpacek 12/15/2013 20:30'!cs__size	^ (((self cs__getPortNamed__par01: (#connectedPort)) cs__invoke__par01: (ServiceInvocation selector: #size arguments: {} originPort: (self cs__getPortNamed__par01: (#connectedPort)) ) par02: false)).! !!CRequiredPort methodsFor: 'as yet unclassified' stamp: 'Fred 2/10/2015 19:42'!primitive_connectTo: port	|cP|	cP := (ports at: #connectedPorts).	cP cs__connectTo__par01: port.! !!CRequiredPort methodsFor: 'as yet unclassified' stamp: 'PetrSpacek 11/25/2013 13:30'!primitive_invoke: serviceinv	|cP|	cP := ((ports at: #connectedPorts) instVarNamed: #connectedPorts).	(cP size = 0) ifTrue: [ self error: 'Port is not connected' ].	cP do: [ :p | p cs__invoke__par01: serviceinv par02: false ].! !SinglePort subclass: #SRequiredPort	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Meta'!!SRequiredPort methodsFor: 'default-interface' stamp: 'PetrSpacek 12/15/2013 20:27'!cs__connectTo__par01: port	(self primitive_connectTo: port "compo vm primitive call")! !!SRequiredPort methodsFor: 'default-interface' stamp: 'PetrSpacek 12/15/2013 20:27'!cs__invoke__par01: service par02: isDerref	( isDerref ) ifTrue: [ 		^ (((self cs__getPortNamed__par01: (#self)) cs__invoke__par01: (ServiceInvocation selector: #invoke arguments: {(service). (false). } originPort: (self cs__getPortNamed__par01: (#self)) ) par02: false)).	 ] ifFalse: [		^ ((self primitive_invoke: service "compo vm primitive call")).	 ]
.
! !!SRequiredPort methodsFor: 'compo-private' stamp: 'FerrandAnthony 2/12/2015 15:57'!primitive_connectTo: port	| cP targetName selfName |	((port isKindOf: Port) | (port isKindOf: AtomicPort)) ifTrue: [ 		(self isInterfaceCompatibleWith: port) ifFalse: [			targetName := (((((port instVarNamed: #ports) at: #name) instVarNamed: #connectedPorts) at: 1) instVarNamed: #owner) asString.			selfName := (((((self instVarNamed: #ports) at: #name) instVarNamed: #connectedPorts) at: 1) instVarNamed: #owner) asString.			self error: 'Incompatible interfaces between ',selfName, ' and ', targetName.		]. ].		cP := (ports at: #connectedPorts).		cP cs__disconnect.		cP cs__connectTo__par01: port.! !!SRequiredPort methodsFor: 'compo-private' stamp: 'FerrandAnthony 2/12/2015 15:08'!primitive_invoke: serviceinv	|cP aPort|	cP := ((ports at: #connectedPorts) instVarNamed: #connectedPorts).	(cP size = 0) ifTrue: [ self error: 'Port is not connected' ].	^ (cP at: 1) cs__invoke__par01: serviceinv par02: false.				"CREATED BY Lucas Nelaupe	|cP aPort result|	cP := ((ports at: #connectedPorts) instVarNamed: #connectedPorts).	(cP size = 0) ifTrue: [ self error: 'Port is not connected' ].	result := (cP at: 1) cs__invoke__par01: serviceinv par02: false.		aPort := AtomicPort newNamed: '?' owner: owner role: #required visibility: #internal interface: '' isCollectionPort: false.	aPort connectTo_port: result.		(result isKindOf: SProvidedPort) 		ifTrue: [ ^aPort. ]	ifFalse: [		(result isKindOf: SRequiredPort) 			ifFalse: [				(result isKindOf: AtomicPort ) 					ifTrue: [ (result role == #provided) ifTrue: [ ^aPort. ] ]		]	 ].	^result."! !ComplexExample subclass: #Compo1	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Meta'!!Compo1 methodsFor: 'default-interface' stamp: 'Fred 7/17/2014 09:01'!cs__run	^ ('c1 ' 		, ((self cs__getPortNamed__par01: (#inC1)) cs__invoke__par01: (ServiceInvocation selector: #run arguments: {} originPort: (self cs__getPortNamed__par01: (#inC1)) ) par02: false) 			, ((self cs__getPortNamed__par01: (#out)) cs__invoke__par01: (ServiceInvocation selector: #run arguments: {} originPort: (self cs__getPortNamed__par01: (#out)) ) par02: false)).! !Message subclass: #ServiceInvocation	instanceVariableNames: 'originPort index'	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Meta'!!ServiceInvocation methodsFor: 'accessing' stamp: 'PetrSpacek 11/25/2013 03:15'!compoSelector	|stream|	stream := TextStream on: String new.	stream 		nextPutAll: 'cs__';		nextPutAll: (selector).	args withIndexDo: [ :arg :idx |		(idx == 1) ifTrue: [ stream nextPutAll: '__' ].		stream			nextPutAll: 'par'.		(idx < 10) ifTrue: [ stream nextPut: $0 ].		stream			nextPutAll: idx asString;			nextPut: $: .	].	^ stream contents asSymbol.							! !!ServiceInvocation methodsFor: 'accessing' stamp: 'PetrSpacek 11/24/2013 21:47'!index	^ index! !!ServiceInvocation methodsFor: 'accessing' stamp: 'PetrSpacek 11/24/2013 21:47'!index: anObject	index := anObject! !!ServiceInvocation methodsFor: 'accessing' stamp: 'PetrSpacek 11/25/2013 01:05'!objSelector	(args size = 1)		ifTrue: [ ^ ((selector asString),':') asSymbol . ]		ifFalse: [ ^ selector asSymbol.]! !!ServiceInvocation methodsFor: 'accessing' stamp: 'PetrSpacek 11/24/2013 17:52'!originPort	^ originPort! !!ServiceInvocation methodsFor: 'accessing' stamp: 'PetrSpacek 11/24/2013 17:52'!originPort: anObject	originPort := anObject! !!ServiceInvocation methodsFor: 'accessing' stamp: 'PetrSpacek 12/15/2013 22:05'!sendTo: receiver	"answer the result of sending this message to receiver"	(receiver isKindOf: (Smalltalk at: #Component))		ifTrue: [ ^ receiver perform: self compoSelector withArguments: args  ]		ifFalse: [			(receiver class = (Smalltalk at: #AtomicPort))				ifTrue: [ ^ receiver perform: self compoSelector withArguments: args  ]				ifFalse: [ ^ receiver perform: self objSelector withArguments: args ]		]	! !!ServiceInvocation methodsFor: 'as yet unclassified' stamp: 'PetrSpacek 11/24/2013 17:55'!setSelector: aSymbol arguments: anArray originPort: aP		selector :=  aSymbol.	args := anArray.	originPort := aP.! !!ServiceInvocation methodsFor: 'as yet unclassified' stamp: 'PetrSpacek 11/24/2013 21:47'!setSelector: aSymbol arguments: anArray originPort: aP index: idx		selector :=  aSymbol.	args := anArray.	originPort := aP.	index := idx.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ServiceInvocation class	instanceVariableNames: ''!!ServiceInvocation class methodsFor: 'as yet unclassified' stamp: 'PetrSpacek 11/24/2013 18:20'!selector: aSymbol 	self shouldNotImplement .! !!ServiceInvocation class methodsFor: 'as yet unclassified' stamp: 'PetrSpacek 11/24/2013 18:20'!selector: aSymbol argument: anObject 	self shouldNotImplement .! !!ServiceInvocation class methodsFor: 'as yet unclassified' stamp: 'PetrSpacek 11/24/2013 21:47'!selector: aSymbol arguments: anArray originPort: aP	"Answer an instance of me with selector, aSymbol, and arguments, 	anArray."	^self new setSelector: aSymbol arguments: anArray originPort: aP index: nil.! !!ServiceInvocation class methodsFor: 'as yet unclassified' stamp: 'PetrSpacek 11/24/2013 21:47'!selector: aSymbol arguments: anArray originPort: aP index: idx	"Answer an instance of me with selector, aSymbol, and arguments, 	anArray."	^self new setSelector: aSymbol arguments: anArray originPort: aP index: idx.! !Component subclass: #Value	instanceVariableNames: 'value'	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Meta'!!Value methodsFor: 'as yet unclassified' stamp: 'Fred 10/14/2014 21:24'!primitive_getValue 	^value! !!Value methodsFor: 'as yet unclassified' stamp: 'Fred 10/14/2014 22:21'!primitive_setValue: val 	value := val! !!Value methodsFor: 'default-interface' stamp: 'Fred 10/14/2014 22:03'!cs__getValue	^ ((self primitive_getValue "compo vm primitive call")).! !!Value methodsFor: 'default-interface' stamp: 'Fred 10/14/2014 22:15'!cs__setValue__par01: val	(self primitive_setValue: val "compo vm primitive call")! !FooBarExample subclass: #FooBarC	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Meta'!!FooBarC methodsFor: 'default-interface' stamp: 'Fred 2/10/2015 16:14'!cs__fooBar	((self cs__getPortNamed__par01: (#fooP)) cs__invoke__par01: (ServiceInvocation selector: #foo arguments: {} originPort: (self cs__getPortNamed__par01: (#fooP)) ) par02: false)! !!FooBarC methodsFor: 'default-interface' stamp: 'Fred 2/10/2015 16:14'!cs__main	((self cs__getPortNamed__par01: (#self)) cs__invoke__par01: (ServiceInvocation selector: #fooBar arguments: {} originPort: (self cs__getPortNamed__par01: (#self)) ) par02: false)! !ComplexExample subclass: #Compo4	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Meta'!!Compo4 methodsFor: 'default-interface' stamp: 'Fred 6/20/2014 14:46'!cs__run	^ ('c4').! !SinglePort subclass: #SProvidedPort	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Meta'!!SProvidedPort methodsFor: 'compo-private' stamp: 'PetrSpacek 11/25/2013 02:51'!primitive_invoke: serviceinv	^ serviceinv sendTo: owner.	! !!SProvidedPort methodsFor: 'default-interface' stamp: 'PetrSpacek 11/24/2013 20:55'!cs__connectTo__par01: port! !!SProvidedPort methodsFor: 'default-interface' stamp: 'PetrSpacek 12/15/2013 20:26'!cs__invoke__par01: service par02: isDerref	( isDerref ) ifTrue: [ 		^ (((self cs__getPortNamed__par01: (#self)) cs__invoke__par01: (ServiceInvocation selector: #invoke arguments: {(service). (false). } originPort: (self cs__getPortNamed__par01: (#self)) ) par02: false)).	 ] ifFalse: [		^ ((self primitive_invoke: service "compo vm primitive call")).	 ]
.
! !SProvidedPort subclass: #SelfPort	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Meta'!SProvidedPort subclass: #SuperPort	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Meta'!SProvidedPort subclass: #DefaultPort	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Meta'!ComplexExample subclass: #Container	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Meta'!!Container methodsFor: 'default-interface' stamp: 'Fred 7/16/2014 18:00'!cs__aFinalRun	((self cs__getPortNamed__par01: (#out)) cs__invoke__par01: (ServiceInvocation selector: #print arguments: {(((self cs__getPortNamed__par01: (#poorPort)) cs__invoke__par01: (ServiceInvocation selector: #run arguments: {} originPort: (self cs__getPortNamed__par01: (#poorPort)) ) par02: false)). } originPort: (self cs__getPortNamed__par01: (#out)) ) par02: false)! !!Container methodsFor: 'default-interface' stamp: 'Fred 7/17/2014 09:01'!cs__anotherRun	((self cs__getPortNamed__par01: (#anotherStupidPort)) cs__invoke__par01: (ServiceInvocation selector: #print arguments: {('Boom, component programmation model murdered'). } originPort: (self cs__getPortNamed__par01: (#anotherStupidPort)) ) par02: false)! !!Container methodsFor: 'default-interface' stamp: 'Fred 7/17/2014 09:01'!cs__finalRun	((self cs__getPortNamed__par01: (#out)) cs__invoke__par01: (ServiceInvocation selector: #print arguments: {(((self cs__getPortNamed__par01: (#poorPort)) cs__invoke__par01: (ServiceInvocation selector: #run arguments: {} originPort: (self cs__getPortNamed__par01: (#poorPort)) ) par02: false)). } originPort: (self cs__getPortNamed__par01: (#out)) ) par02: false)! !!Container methodsFor: 'default-interface' stamp: 'Fred 7/17/2014 09:01'!cs__otherRun	((self cs__getPortNamed__par01: (#out)) cs__invoke__par01: (ServiceInvocation selector: #print arguments: {(((self cs__getPortNamed__par01: (#stupidPort)) cs__invoke__par01: (ServiceInvocation selector: #run2 arguments: {} originPort: (self cs__getPortNamed__par01: (#stupidPort)) ) par02: false)). } originPort: (self cs__getPortNamed__par01: (#out)) ) par02: false)! !!Container methodsFor: 'default-interface' stamp: 'Fred 7/17/2014 09:01'!cs__run	^ ('Kaboom, component programmation model terminated ').! !!Container methodsFor: 'default-interface' stamp: 'Fred 7/17/2014 09:01'!cs__run2	^ ('Boom, component programmation model dynamited').! !!Container methodsFor: 'default-interface' stamp: 'Fred 7/17/2014 09:01'!cs__run__par01: a	((self cs__getPortNamed__par01: (#out)) cs__invoke__par01: (ServiceInvocation selector: #print arguments: {(((self cs__getPortNamed__par01: (#c1)) cs__invoke__par01: (ServiceInvocation selector: #run arguments: {} originPort: (self cs__getPortNamed__par01: (#c1)) ) par02: false)). } originPort: (self cs__getPortNamed__par01: (#out)) ) par02: false)! !Component subclass: #HelloerExample	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Meta'!HelloerExample subclass: #Printer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Meta'!!Printer methodsFor: 'default-interface' stamp: 'Fred 2/11/2015 14:29'!cs__print__par01: txt	((Transcript defaultPort) cs__invoke__par01: (ServiceInvocation selector: #crShow arguments: {(txt). } originPort: (Transcript defaultPort) ) par02: false)! !HelloerExample subclass: #MorphPrinter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Meta'!!MorphPrinter methodsFor: 'default-interface' stamp: 'PetrSpacek 11/25/2013 12:35'!cs__print__par01: txt	| sm |	sm := ((StringMorph defaultPort) cs__invoke__par01: (ServiceInvocation selector: #new arguments: {} originPort: (StringMorph defaultPort) ) par02: false).	((sm) cs__invoke__par01: (ServiceInvocation selector: #contents arguments: {(txt). } originPort: (sm) ) par02: false).	((sm) cs__invoke__par01: (ServiceInvocation selector: #fitContents arguments: {} originPort: (sm) ) par02: false).	((sm) cs__invoke__par01: (ServiceInvocation selector: #font arguments: {(((StandardFonts defaultPort) cs__invoke__par01: (ServiceInvocation selector: #windowTitleFont arguments: {} originPort: (StandardFonts defaultPort) ) par02: false)). } originPort: (sm) ) par02: false).	((sm) cs__invoke__par01: (ServiceInvocation selector: #openInWorld arguments: {} originPort: (sm) ) par02: false).	((sm) cs__invoke__par01: (ServiceInvocation selector: #position arguments: {(70 		@ 250). } originPort: (sm) ) par02: false).	((sm) cs__invoke__par01: (ServiceInvocation selector: #color arguments: {(((Color defaultPort) cs__invoke__par01: (ServiceInvocation selector: #yellow arguments: {} originPort: (Color defaultPort) ) par02: false)). } originPort: (sm) ) par02: false).	((sm) cs__invoke__par01: (ServiceInvocation selector: #borderWidth arguments: {(5). } originPort: (sm) ) par02: false).	((sm) cs__invoke__par01: (ServiceInvocation selector: #emphasis arguments: {(1). } originPort: (sm) ) par02: false).	((sm) cs__invoke__par01: (ServiceInvocation selector: #highlightColor arguments: {(((Color defaultPort) cs__invoke__par01: (ServiceInvocation selector: #red arguments: {} originPort: (Color defaultPort) ) par02: false)). } originPort: (sm) ) par02: false)! !HelloerExample subclass: #HelloApp	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Meta'!!HelloApp methodsFor: 'default-interface' stamp: 'PetrSpacek 11/25/2013 12:15'!cs__run	((self cs__getPortNamed__par01: (#helloer)) cs__invoke__par01: (ServiceInvocation selector: #sayHello arguments: {} originPort: (self cs__getPortNamed__par01: (#helloer)) ) par02: false)! !HelloApp subclass: #HelloApp2	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Meta'!HelloerExample subclass: #Helloer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Meta'!!Helloer methodsFor: 'default-interface' stamp: 'PetrSpacek 11/25/2013 14:52'!cs__sayHello	((self cs__getPortNamed__par01: (#printer)) cs__invoke__par01: (ServiceInvocation selector: #print arguments: {('Hello from Helloer component'). } originPort: (self cs__getPortNamed__par01: (#printer)) ) par02: false)! !HelloerExample subclass: #Reverser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Meta'!!Reverser methodsFor: 'default-interface' stamp: 'PetrSpacek 12/15/2013 20:37'!cs__print__par01: txt	((self cs__getPortNamed__par01: (#output)) cs__invoke__par01: (ServiceInvocation selector: #print arguments: {(((((txt) cs__invoke__par01: (ServiceInvocation selector: #getPortNamed arguments: { #'default'} originPort: (txt) index: nil) par02: false)) cs__invoke__par01: (ServiceInvocation selector: #reverse arguments: {} originPort: (((txt) cs__invoke__par01: (ServiceInvocation selector: #getPortNamed arguments: { #'default'} originPort: (txt) index: nil) par02: false)) ) par02: false)). } originPort: (self cs__getPortNamed__par01: (#output)) ) par02: false)! !Descriptor subclass: #MemoDescriptor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Meta'!!MemoDescriptor methodsFor: 'default-interface' stamp: 'Fred 11/25/2014 11:47'!cs__getInstances	^ (self cs__getPortNamed__par01: (#instances)).! !!MemoDescriptor methodsFor: 'default-interface' stamp: 'Fred 11/25/2014 11:47'!cs__new	| inst v |	inst := ((((self cs__getPortNamed: #self) cs__invoke__par01: (ServiceInvocation selector: #getPortNamed arguments: { #'super'} originPort: (self cs__getPortNamed: #self) index: nil) par02: false)) cs__invoke__par01: (ServiceInvocation selector: #new arguments: {} originPort: (((self cs__getPortNamed: #self) cs__invoke__par01: (ServiceInvocation selector: #getPortNamed arguments: { #'super'} originPort: (self cs__getPortNamed: #self) index: nil) par02: false)) ) par02: false).	v := ((Value cs__getPortNamed__par01: #default) cs__invoke__par01: (ServiceInvocation selector: #new arguments: {} originPort: (Value cs__getPortNamed__par01: #default) ) par02: false).	((v) cs__invoke__par01: (ServiceInvocation selector: #setValue arguments: {(inst). } originPort: (v) ) par02: false).	(((instances) cs__invoke__par01: (ServiceInvocation selector: #getPortNamed arguments: { #'self'} originPort: (instances) index: (((self cs__getPortNamed__par01: (#instances)) cs__invoke__par01: (ServiceInvocation selector: #size arguments: {} originPort: (self cs__getPortNamed__par01: (#instances)) ) par02: false)) par02: false)))		cs__connectTo__par01: (((v) cs__invoke__par01: (ServiceInvocation selector: #getPortNamed arguments: { #'default'} originPort: (v) index: nil) par02: false))..	^ (inst).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MemoDescriptor class	instanceVariableNames: 'instances'!!MemoDescriptor class methodsFor: 'as yet unclassified' stamp: 'Fred 11/25/2014 12:00'!cs__getInstances	^ (self cs__getPortNamed__par01: (#instances)).! !Component initialize!MemoObject initialize!MemoComponent initialize!