Object subclass: #CompoASTVisitorAbstract	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Parser-Visitor'!!CompoASTVisitorAbstract methodsFor: 'visiting' stamp: 'PetrSpacek 11/9/2012 23:31'!visitArgument: each 	"Here to allow subclasses to detect arguments or temporaries."	^self visitNode: each! !!CompoASTVisitorAbstract methodsFor: 'visiting' stamp: 'PetrSpacek 11/9/2012 23:31'!visitArguments: aNodeCollection 	^aNodeCollection do: [:each | self visitArgument: each]! !!CompoASTVisitorAbstract methodsFor: 'visiting' stamp: 'PetrSpacek 11/9/2012 10:01'!visitNode: aNode 	^aNode acceptVisitor: self! !!CompoASTVisitorAbstract methodsFor: 'visiting-compo-nodes' stamp: 'PetrSpacek 11/9/2012 09:57'!visitCompoArchitectureNode: node! !!CompoASTVisitorAbstract methodsFor: 'visiting-compo-nodes' stamp: 'PetrSpacek 11/9/2012 09:57'!visitCompoBindNode: node! !!CompoASTVisitorAbstract methodsFor: 'visiting-compo-nodes' stamp: 'PetrSpacek 11/9/2012 09:57'!visitCompoCollectionPortLiteralNode: node! !!CompoASTVisitorAbstract methodsFor: 'visiting-compo-nodes' stamp: 'PetrSpacek 11/9/2012 09:57'!visitCompoConnectionNode: node! !!CompoASTVisitorAbstract methodsFor: 'visiting-compo-nodes' stamp: 'PetrSpacek 11/9/2012 09:57'!visitCompoDereferenceLiteralNode: node! !!CompoASTVisitorAbstract methodsFor: 'visiting-compo-nodes' stamp: 'PetrSpacek 11/9/2012 09:57'!visitCompoDescriptorNode: node! !!CompoASTVisitorAbstract methodsFor: 'visiting-compo-nodes' stamp: 'PetrSpacek 11/9/2012 09:57'!visitCompoDisconnectionNode: node! !!CompoASTVisitorAbstract methodsFor: 'visiting-compo-nodes' stamp: 'PetrSpacek 11/9/2012 09:57'!visitCompoExProvisionsNode: node! !!CompoASTVisitorAbstract methodsFor: 'visiting-compo-nodes' stamp: 'PetrSpacek 11/9/2012 09:57'!visitCompoExRequirementsNode: node! !!CompoASTVisitorAbstract methodsFor: 'visiting-compo-nodes' stamp: 'PetrSpacek 11/11/2013 19:22'!visitCompoForNode: node! !!CompoASTVisitorAbstract methodsFor: 'visiting-compo-nodes' stamp: 'PetrSpacek 11/11/2013 19:22'!visitCompoIfNode: node! !!CompoASTVisitorAbstract methodsFor: 'visiting-compo-nodes' stamp: 'PetrSpacek 11/9/2012 09:57'!visitCompoInProvisionsNode: node! !!CompoASTVisitorAbstract methodsFor: 'visiting-compo-nodes' stamp: 'PetrSpacek 11/9/2012 09:57'!visitCompoInRequirementsNode: node! !!CompoASTVisitorAbstract methodsFor: 'visiting-compo-nodes' stamp: 'PetrSpacek 11/9/2012 09:57'!visitCompoInterfaceNode: node! !!CompoASTVisitorAbstract methodsFor: 'visiting-compo-nodes' stamp: 'PetrSpacek 11/9/2012 09:57'!visitCompoParseNode: node! !!CompoASTVisitorAbstract methodsFor: 'visiting-compo-nodes' stamp: 'PetrSpacek 11/9/2012 09:57'!visitCompoPortAddressNode: node! !!CompoASTVisitorAbstract methodsFor: 'visiting-compo-nodes' stamp: 'PetrSpacek 11/9/2012 09:57'!visitCompoPortNode: node! !!CompoASTVisitorAbstract methodsFor: 'visiting-compo-nodes' stamp: 'PetrSpacek 11/9/2012 09:57'!visitCompoServiceInvocationNode: node! !!CompoASTVisitorAbstract methodsFor: 'visiting-compo-nodes' stamp: 'PetrSpacek 11/9/2012 09:57'!visitCompoServiceNode: node! !!CompoASTVisitorAbstract methodsFor: 'visiting-compo-nodes' stamp: 'PetrSpacek 11/9/2012 09:57'!visitCompoServiceSignNode: node! !!CompoASTVisitorAbstract methodsFor: 'visiting-compo-nodes' stamp: 'PetrSpacek 11/11/2013 19:22'!visitCompoWhileNode: node! !!CompoASTVisitorAbstract methodsFor: 'accepting-RBnodes' stamp: 'PetrSpacek 11/9/2012 10:12'!acceptArrayNode: node! !!CompoASTVisitorAbstract methodsFor: 'accepting-RBnodes' stamp: 'PetrSpacek 11/9/2012 10:12'!acceptAssignmentNode: node! !!CompoASTVisitorAbstract methodsFor: 'accepting-RBnodes' stamp: 'PetrSpacek 11/9/2012 10:12'!acceptBlockNode: node! !!CompoASTVisitorAbstract methodsFor: 'accepting-RBnodes' stamp: 'PetrSpacek 11/9/2012 10:12'!acceptCascadeNode: node! !!CompoASTVisitorAbstract methodsFor: 'accepting-RBnodes' stamp: 'PetrSpacek 11/9/2012 10:12'!acceptLiteralArrayNode: node! !!CompoASTVisitorAbstract methodsFor: 'accepting-RBnodes' stamp: 'PetrSpacek 11/9/2012 10:12'!acceptLiteralNode: node! !!CompoASTVisitorAbstract methodsFor: 'accepting-RBnodes' stamp: 'PetrSpacek 11/9/2012 10:12'!acceptMessageNode: node! !!CompoASTVisitorAbstract methodsFor: 'accepting-RBnodes' stamp: 'PetrSpacek 11/9/2012 10:12'!acceptMethodNode: node! !!CompoASTVisitorAbstract methodsFor: 'accepting-RBnodes' stamp: 'PetrSpacek 11/9/2012 10:12'!acceptPatternBlockNode: node! !!CompoASTVisitorAbstract methodsFor: 'accepting-RBnodes' stamp: 'PetrSpacek 11/9/2012 10:12'!acceptPatternWrapperBlockNode: node! !!CompoASTVisitorAbstract methodsFor: 'accepting-RBnodes' stamp: 'PetrSpacek 11/9/2012 10:12'!acceptPragmaNode: node! !!CompoASTVisitorAbstract methodsFor: 'accepting-RBnodes' stamp: 'PetrSpacek 11/9/2012 10:12'!acceptReturnNode: node! !!CompoASTVisitorAbstract methodsFor: 'accepting-RBnodes' stamp: 'PetrSpacek 11/9/2012 10:12'!acceptSequenceNode: node! !!CompoASTVisitorAbstract methodsFor: 'accepting-RBnodes' stamp: 'PetrSpacek 11/9/2012 10:12'!acceptVariableNode: node! !!CompoASTVisitorAbstract methodsFor: 'as yet unclassified' stamp: 'FerrandAnthony 2/5/2015 12:49'!visitCompoConnectionRockNode: node! !!CompoASTVisitorAbstract methodsFor: 'as yet unclassified' stamp: 'FerrandAnthony 2/11/2015 20:46'!visitCompoSmalltalkInjectionNode: node! !CompoASTVisitorAbstract subclass: #CompoFormatter	instanceVariableNames: 'codeStream lineStart firstLineLength tabs'	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Parser-Visitor'!!CompoFormatter methodsFor: 'accessing' stamp: 'PetrSpacek 11/9/2012 23:32'!firstLineLength	^firstLineLength isNil		ifTrue: [codeStream position]		ifFalse: [firstLineLength]! !!CompoFormatter methodsFor: 'accessing' stamp: 'PetrSpacek 11/9/2012 23:32'!format: aNode 	self visitNode: aNode.	^codeStream contents! !!CompoFormatter methodsFor: 'accessing' stamp: 'PetrSpacek 11/9/2012 23:32'!isMultiLine	^firstLineLength notNil! !!CompoFormatter methodsFor: 'accessing' stamp: 'PetrSpacek 11/9/2012 23:32'!lastLineLength	^codeStream position - (lineStart max: 0)! !!CompoFormatter methodsFor: 'copying' stamp: 'PetrSpacek 11/9/2012 23:32'!postCopy	super postCopy.	lineStart := self lineLength negated.	codeStream := WriteStream on: (String new: 60).	firstLineLength := nil! !!CompoFormatter methodsFor: 'initialize-release' stamp: 'PetrSpacek 11/9/2012 23:32'!initialize	super initialize.	codeStream := WriteStream on: (String new: 60).	tabs := 0.	lineStart := 0! !!CompoFormatter methodsFor: 'testing' stamp: 'PetrSpacek 11/9/2012 23:32'!startMessageSendOnNewLine: aMessageNode 	(self selectorsToStartOnNewLine includes: aMessageNode selector) 		ifTrue: [^true].	(self selectorsToLeaveOnLine includes: aMessageNode selector) 		ifTrue: [^false].	^aMessageNode selector numArgs > self maximumArgumentsPerLine! !!CompoFormatter methodsFor: 'visiting' stamp: 'PetrSpacek 11/9/2012 23:32'!visitNode: aNode 	| parenthesis |	parenthesis := self needsParenthesisFor: aNode.	parenthesis ifTrue: [codeStream nextPut: $(].	aNode acceptVisitor: self.	parenthesis ifTrue: [codeStream nextPut: $)]! !!CompoFormatter methodsFor: 'visitor-double dispatching' stamp: 'PetrSpacek 11/9/2012 23:32'!acceptArrayNode: anArrayNode	codeStream nextPut: ${.	anArrayNode statements isEmpty ifFalse: [		anArrayNode statements size > 1			ifTrue: [				self indent: 1 while: [					self indent.					self formatStatementsFor: anArrayNode ].				self indent ]			ifFalse: [ self formatStatementsFor: anArrayNode ] ].	codeStream nextPut: $}! !!CompoFormatter methodsFor: 'visitor-double dispatching' stamp: 'PetrSpacek 11/9/2012 23:32'!acceptAssignmentNode: anAssignmentNode 	self indent: 2		while: 			[self visitNode: anAssignmentNode variable.			codeStream space; nextPutAll: anAssignmentNode assignmentOperator; space.			self visitNode: anAssignmentNode value]! !!CompoFormatter methodsFor: 'visitor-double dispatching' stamp: 'PetrSpacek 11/9/2012 23:32'!acceptBlockNode: aBlockNode 	self 		acceptBlockNode: aBlockNode		startBlockString: '['		endBlockString: ']'! !!CompoFormatter methodsFor: 'visitor-double dispatching' stamp: 'PetrSpacek 11/9/2012 23:32'!acceptBlockNode: aBlockNode startBlockString: startBlockString endBlockString: endBlockString 	| seqNode multiline formattedBody formatter |	seqNode := aBlockNode body.	formatter := (self copy)				lineStart: 0;				yourself.	formattedBody := formatter format: seqNode.	multiline := self lineLength + formattedBody size > self maxLineSize 				or: [formatter isMultiLine].	multiline ifTrue: [self indent].	codeStream nextPutAll: startBlockString.	aBlockNode arguments do: 			[:each | 			codeStream nextPut: $:.			self visitNode: each.			codeStream nextPut: $ ].	aBlockNode arguments notEmpty 		ifTrue: 			[codeStream nextPutAll: '| '.			multiline ifTrue: [self indent]].	codeStream		nextPutAll: formattedBody;		nextPutAll: endBlockString! !!CompoFormatter methodsFor: 'visitor-double dispatching' stamp: 'PetrSpacek 11/9/2012 23:32'!acceptCascadeNode: aCascadeNode 	| messages |	messages := aCascadeNode messages.	self visitNode: messages first receiver.	self indentWhile: 			[self 				for: messages				do: 					[:each | 					self						indent;						indentWhile: [self formatMessage: each cascade: true]]				separatedBy: [codeStream nextPut: $;]]! !!CompoFormatter methodsFor: 'visitor-double dispatching' stamp: 'PetrSpacek 11/9/2012 23:32'!acceptLiteralArrayNode: aRBArrayLiteralNode 	codeStream nextPutAll: (aRBArrayLiteralNode isForByteArray 				ifTrue: ['#[']				ifFalse: ['#(']).	self 		for: aRBArrayLiteralNode contents		do: [:each | self visitNode: each]		separatedBy: [codeStream nextPut: $ ].	codeStream 		nextPut: (aRBArrayLiteralNode isForByteArray ifTrue: [$]] ifFalse: [$)])! !!CompoFormatter methodsFor: 'visitor-double dispatching' stamp: 'PetrSpacek 11/9/2012 23:32'!acceptLiteralNode: aLiteralNode 	aLiteralNode token storeOn: codeStream! !!CompoFormatter methodsFor: 'visitor-double dispatching' stamp: 'PetrSpacek 11/9/2012 23:32'!acceptMessageNode: aMessageNode 	| newFormatter code |	newFormatter := self copy.	code := newFormatter format: aMessageNode receiver.	codeStream nextPutAll: code.	codeStream nextPut: $ .	newFormatter isMultiLine		ifTrue: [lineStart := codeStream position - newFormatter lastLineLength].	self indent: (newFormatter isMultiLine ifTrue: [2] ifFalse: [1])		while: [self formatMessage: aMessageNode cascade: false]! !!CompoFormatter methodsFor: 'visitor-double dispatching' stamp: 'PetrSpacek 11/9/2012 23:32'!acceptMethodNode: aMethodNode 	self formatMethodPatternFor: aMethodNode.	self indentWhile: [		self formatMethodCommentFor: aMethodNode indentBefore: true.		self indent.		self formatPragmasFor: aMethodNode.		aMethodNode body statements notEmpty 			ifTrue: [ self visitNode: aMethodNode body ] ]! !!CompoFormatter methodsFor: 'visitor-double dispatching' stamp: 'PetrSpacek 11/9/2012 23:32'!acceptPatternBlockNode: aRBPatternBlockNode 	self 		acceptBlockNode: aRBPatternBlockNode		startBlockString: '`{'		endBlockString: '}'! !!CompoFormatter methodsFor: 'visitor-double dispatching' stamp: 'PetrSpacek 11/9/2012 23:32'!acceptPatternWrapperBlockNode: aRBPatternWrapperBlockNode 	self visitNode: aRBPatternWrapperBlockNode wrappedNode.	self 		acceptBlockNode: aRBPatternWrapperBlockNode		startBlockString: '`{'		endBlockString: '}'! !!CompoFormatter methodsFor: 'visitor-double dispatching' stamp: 'PetrSpacek 11/9/2012 23:32'!acceptPragmaNode: aPragmaNode	codeStream nextPut: $<.	aPragmaNode selector isInfix		ifTrue: [ codeStream nextPut: $ ].	self formatMessage: aPragmaNode cascade: false.		codeStream nextPut: $>! !!CompoFormatter methodsFor: 'visitor-double dispatching' stamp: 'PetrSpacek 11/11/2012 20:31'!acceptReturnNode: aReturnNode 	codeStream nextPutAll: 'return '.	self visitNode: aReturnNode value! !!CompoFormatter methodsFor: 'visitor-double dispatching' stamp: 'PetrSpacek 11/9/2012 23:32'!acceptSequenceNode: aSequenceNode 	self formatMethodCommentFor: aSequenceNode indentBefore: false.	self formatTemporariesFor: aSequenceNode.	self formatStatementsFor: aSequenceNode! !!CompoFormatter methodsFor: 'visitor-double dispatching' stamp: 'PetrSpacek 11/9/2012 23:32'!acceptVariableNode: aVariableNode 	codeStream nextPutAll: aVariableNode name! !!CompoFormatter methodsFor: 'private' stamp: 'PetrSpacek 11/9/2012 23:32'!for: aValue do: doBlock separatedBy: separatorBlock 	"This is implemented here since IBM Smalltalk doesn't implement a do:separatedBy: method"	aValue isEmpty ifTrue: [^self].	1 to: aValue size - 1		do: 			[:i | 			doBlock value: (aValue at: i).			separatorBlock value].	doBlock value: aValue last! !!CompoFormatter methodsFor: 'private' stamp: 'PetrSpacek 11/9/2012 23:32'!indent	firstLineLength isNil ifTrue: [firstLineLength := codeStream position].	codeStream cr.	tabs timesRepeat: [codeStream tab].	lineStart := codeStream position! !!CompoFormatter methodsFor: 'private' stamp: 'PetrSpacek 11/9/2012 23:32'!indent: anInteger while: aBlock 	tabs := tabs + anInteger.	aBlock value.	tabs := tabs - anInteger! !!CompoFormatter methodsFor: 'private' stamp: 'PetrSpacek 11/9/2012 23:32'!indentWhile: aBlock 	self indent: 1 while: aBlock! !!CompoFormatter methodsFor: 'private' stamp: 'PetrSpacek 11/9/2012 23:32'!lineLength	^codeStream position - lineStart! !!CompoFormatter methodsFor: 'private' stamp: 'PetrSpacek 11/9/2012 23:32'!lineStart: aPosition 	lineStart := aPosition! !!CompoFormatter methodsFor: 'private' stamp: 'PetrSpacek 11/9/2012 23:32'!maxLineSize	^75! !!CompoFormatter methodsFor: 'private' stamp: 'PetrSpacek 11/9/2012 23:32'!maximumArgumentsPerLine	^2! !!CompoFormatter methodsFor: 'private' stamp: 'PetrSpacek 11/9/2012 23:32'!needsParenthesisFor: aNode	| parent grandparent |	aNode isValue ifFalse: [ ^ false ].	parent := aNode parent ifNil: [ ^ false ].	(aNode isMessage and: [ parent isMessage and: [ parent receiver == aNode ] ]) ifTrue: [		grandparent := parent parent.		(grandparent notNil and: [ grandparent isCascade ])			ifTrue: [ ^ true ] ].	(aNode precedence < parent precedence) ifTrue: [ ^ false ].	(aNode isAssignment and: [ parent isAssignment ]) ifTrue: [ ^ false ].	(aNode isAssignment and: [ aNode isCascade ]) ifTrue: [ ^ true ].	(aNode precedence = 0) ifTrue: [ ^ false ].	(aNode isMessage) ifFalse: [ ^ true ].	(aNode precedence = parent precedence) ifFalse: [ ^ true ].	(aNode isUnary) ifTrue: [ ^ false ].	(aNode isKeyword) ifTrue: [ ^ true ].	(parent receiver == aNode) ifFalse: [ ^ true ].	^ self precedenceOf: parent selector greaterThan: aNode selector! !!CompoFormatter methodsFor: 'private' stamp: 'PetrSpacek 11/9/2012 23:32'!precedenceOf: parentSelector greaterThan: childSelector 	"Put parenthesis around things that are preceived to have 'lower' precedence. For example, 'a + b * c' 	-> '(a + b) * c' but 'a * b + c' -> 'a * b + c'"	| childIndex parentIndex operators |	operators := #(#($| $& $?) #($= $~ $< $>) #($- $+) #($* $/ $% $\) #($@)).	childIndex := 0.	parentIndex := 0.	1 to: operators size		do: 			[:i | 			((operators at: i) includes: parentSelector first) 				ifTrue: [parentIndex := i].			((operators at: i) includes: childSelector first) 				ifTrue: [childIndex := i]].	^childIndex < parentIndex! !!CompoFormatter methodsFor: 'private' stamp: 'PetrSpacek 11/9/2012 23:32'!selectorsToLeaveOnLine	^#(#to:do: #to:by: #to:by:do:)! !!CompoFormatter methodsFor: 'private' stamp: 'PetrSpacek 11/9/2012 23:32'!selectorsToStartOnNewLine	^#(#ifTrue:ifFalse: #ifFalse:ifTrue: #ifTrue: #ifFalse:)! !!CompoFormatter methodsFor: 'private-formatting' stamp: 'PetrSpacek 11/9/2012 23:32'!formatMessage: aMessageNode cascade: cascadeBoolean 	| selectorParts arguments multiLine formattedArgs indentFirst firstArgLength length |	selectorParts := aMessageNode selectorParts.	arguments := aMessageNode arguments.	formattedArgs := OrderedCollection new.	multiLine := aMessageNode selector numArgs > self maximumArgumentsPerLine.	length := aMessageNode selector size + arguments size + 1.	firstArgLength := 0.	self indentWhile: 			[1 to: arguments size				do: 					[:i | 					| formatter string |					formatter := (self copy)								lineStart: (selectorParts at: i) length negated;								yourself.					string := formatter format: (arguments at: i).					formattedArgs add: string.					i == 1 ifTrue: [firstArgLength := formatter firstLineLength].					length := length + string size.					multiLine := multiLine or: [formatter isMultiLine]]].	multiLine := multiLine or: [length + self lineLength > self maxLineSize].	indentFirst := cascadeBoolean not and: 					[multiLine and: 							[(self startMessageSendOnNewLine: aMessageNode) or: 									[self lineLength + selectorParts first length + 2 + firstArgLength 										> self maxLineSize]]].	indentFirst ifTrue: [self indent].	self 		formatMessageSelector: selectorParts		withArguments: formattedArgs		multiline: multiLine! !!CompoFormatter methodsFor: 'private-formatting' stamp: 'PetrSpacek 11/9/2012 23:32'!formatMessageSelector: selectorParts withArguments: formattedArgs multiline: multiLine 	formattedArgs isEmpty 		ifTrue: [codeStream nextPutAll: selectorParts first value]		ifFalse: 			[1 to: formattedArgs size				do: 					[:i | 					(i ~= 1 and: [ multiLine not ])						ifTrue: [codeStream nextPut: $ ].					codeStream 						nextPutAll: (selectorParts at: i) value;						nextPut: $ ;						nextPutAll: (formattedArgs at: i).					(multiLine and: [i < formattedArgs size]) ifTrue: [self indent]]]! !!CompoFormatter methodsFor: 'private-formatting' stamp: 'PetrSpacek 11/9/2012 23:32'!formatMethodCommentFor: aNode indentBefore: aBoolean 	| source |	source := aNode source.	source isNil ifTrue: [^self].	aNode methodComments do: 			[:each | 			aBoolean ifTrue: [self indent].			codeStream				nextPutAll: (aNode source copyFrom: each first to: each last);				cr.			aBoolean ifFalse: [self indent]]! !!CompoFormatter methodsFor: 'private-formatting' stamp: 'PetrSpacek 11/9/2012 23:32'!formatMethodPatternFor: aMethodNode 	| selectorParts arguments |	selectorParts := aMethodNode selectorParts.	arguments := aMethodNode arguments.	arguments isEmpty 		ifTrue: [codeStream nextPutAll: selectorParts first value]		ifFalse: 			[selectorParts with: arguments				do: 					[:selector :arg | 					codeStream						nextPutAll: selector value;						nextPut: $ .					self visitArgument: arg.					codeStream nextPut: $ ]]! !!CompoFormatter methodsFor: 'private-formatting' stamp: 'PetrSpacek 11/9/2012 23:32'!formatPragmasFor: aNode	aNode pragmas do: [ :each | self visitNode: each; indent ]! !!CompoFormatter methodsFor: 'private-formatting' stamp: 'PetrSpacek 11/9/2012 23:32'!formatStatementCommentFor: aNode 	| source |	source := aNode source.	source isNil ifTrue: [^self].	aNode statementComments do: 			[:each | 			| crs |			crs := self newLinesFor: source startingAt: each first.			(crs - 1 max: 0) timesRepeat: [codeStream cr].			crs == 0 ifTrue: [codeStream tab] ifFalse: [self indent].			codeStream nextPutAll: (source copyFrom: each first to: each last)]! !!CompoFormatter methodsFor: 'private-formatting' stamp: 'PetrSpacek 11/9/2012 23:32'!formatStatementsFor: aSequenceNode 	| statements |	statements := aSequenceNode statements.	statements isEmpty ifTrue: [^self].	1 to: statements size - 1		do: 			[:i | 			self visitNode: (statements at: i).			codeStream nextPut: $..			self formatStatementCommentFor: (statements at: i).			self indent].	self visitNode: statements last.	self formatStatementCommentFor: statements last! !!CompoFormatter methodsFor: 'private-formatting' stamp: 'PetrSpacek 11/9/2012 23:32'!formatTemporariesFor: aSequenceNode 	| temps |	temps := aSequenceNode temporaries.	temps isEmpty ifTrue: [^self].	codeStream nextPutAll: '| '.	temps do: 			[:each | 			self visitArgument: each.			codeStream nextPut: $ ].	codeStream nextPut: $|.	self indent! !!CompoFormatter methodsFor: 'private-formatting' stamp: 'PetrSpacek 11/9/2012 23:32'!newLinesFor: aString startingAt: anIndex 	| count cr lf index char |	cr := Character value: 13.	lf := Character value: 10.	count := 0.	index := anIndex - 1.	[index > 0 and: 			[char := aString at: index.			char isSeparator]] 		whileTrue: 			[char == lf 				ifTrue: 					[count := count + 1.					(aString at: (index - 1 max: 1)) == cr ifTrue: [index := index - 1]].			char == cr ifTrue: [count := count + 1].			index := index - 1].	^count! !!CompoFormatter methodsFor: 'visiting-compo-nodes' stamp: 'PetrSpacek 11/10/2012 00:50'!visitCompoArchitectureNode: node	self indent.	codeStream nextPutAll: 'architecture {'.		self indentWhile: [node disconns do: [:n | self visitNode: n]].	self indentWhile: [node conns do: [:n | self visitNode: n]].		((node disconns isEmpty not) or: [node conns isEmpty not]) ifTrue: [self indent].		codeStream nextPutAll: '}'.! !!CompoFormatter methodsFor: 'visiting-compo-nodes' stamp: 'PetrSpacek 11/9/2012 23:42'!visitCompoBindNode: node! !!CompoFormatter methodsFor: 'visiting-compo-nodes' stamp: 'PetrSpacek 11/10/2012 00:59'!visitCompoCollectionPortLiteralNode: node	codeStream nextPutAll: (node portName value asString).	codeStream nextPut: $[.			self visitNode: (node indexExpr).		codeStream nextPut: $].! !!CompoFormatter methodsFor: 'visiting-compo-nodes' stamp: 'PetrSpacek 11/10/2012 01:04'!visitCompoConnectionNode: node	self indent.	codeStream		nextPutAll: 'connect';		space.			self visitNode: (node srcAddress).			codeStream		space;		nextPutAll: 'to';		space.		self visitNode: (node destAddress).		(node kind) ifNotNil: [		codeStream			space;			nextPutAll: 'kind-of';			space;			nextPutAll: (node kind value asString).	].	codeStream nextPut: $;.! !!CompoFormatter methodsFor: 'visiting-compo-nodes' stamp: 'PetrSpacek 11/10/2012 00:57'!visitCompoDereferenceLiteralNode: node	node applicationsCount timesRepeat: [ codeStream nextPut: $& ].	codeStream nextPutAll: (node literal value asString ).! !!CompoFormatter methodsFor: 'visiting-compo-nodes' stamp: 'PetrSpacek 11/10/2012 00:14'!visitCompoDescriptorNode: node	codeStream		nextPutAll: 'component descriptor';		space;		nextPutAll: node name value asString;		space.			(node extends) ifNotNil: [		codeStream			nextPutAll: 'extends';			space;			nextPutAll: (node extends value asString);			space.	].	codeStream nextPut: ${.		self indentWhile: [node body do: [:n | self visitNode: n]].		(node body isEmpty) ifFalse: [self indent].		codeStream nextPut: $}.			! !!CompoFormatter methodsFor: 'visiting-compo-nodes' stamp: 'PetrSpacek 11/10/2012 01:04'!visitCompoDisconnectionNode: nodeself indent.	codeStream		nextPutAll: 'disconnect';		space.			self visitNode: (node srcAddress).			codeStream		space;		nextPutAll: 'from';		space.		self visitNode: (node destAddress).		(node kind) ifNotNil: [		codeStream			space;			nextPutAll: 'kind-of';			space;			nextPutAll: (node kind value asString).	].	codeStream nextPut: $;.! !!CompoFormatter methodsFor: 'visiting-compo-nodes' stamp: 'PetrSpacek 11/10/2012 00:14'!visitCompoExProvisionsNode: node	self indent.	codeStream nextPutAll: 'provides {'.		self indentWhile: [node ports do: [:n | self visitNode: n]].	(node ports isEmpty) ifFalse: [self indent].		codeStream nextPutAll: '}'.! !!CompoFormatter methodsFor: 'visiting-compo-nodes' stamp: 'PetrSpacek 11/10/2012 00:14'!visitCompoExRequirementsNode: node	self indent.	codeStream nextPutAll: 'requires {'.		self indentWhile: [node ports do: [:n | self visitNode: n]].	(node ports isEmpty) ifFalse: [self indent].		codeStream nextPutAll: '}'.! !!CompoFormatter methodsFor: 'visiting-compo-nodes' stamp: 'PetrSpacek 11/11/2013 19:21'!visitCompoForNode: node	! !!CompoFormatter methodsFor: 'visiting-compo-nodes' stamp: 'PetrSpacek 11/11/2013 19:31'!visitCompoIfNode: node	codeStream		nextPutAll: 'if' ;		nextPut: $(.	self visitNode: (node seed).	codeStream		nextPut: $; ;		space.			self visitNode: (node condition).		codeStream		nextPut: $; ;		space.			self visitNode: (node incrementation).		codeStream		nextPut: $) ;		space;		nextPut: ${ .		self indentWhile: [		self indent.		self visitNode: node body.	].		(node body isEmpty not) ifTrue: [self indent].		codeStream nextPut: $}.		! !!CompoFormatter methodsFor: 'visiting-compo-nodes' stamp: 'PetrSpacek 11/10/2012 00:14'!visitCompoInProvisionsNode: node	self indent.	codeStream nextPutAll: 'internally provides {'.		self indentWhile: [node ports do: [:n | self visitNode: n]].		(node ports isEmpty) ifFalse: [self indent].		codeStream nextPutAll: '}'.! !!CompoFormatter methodsFor: 'visiting-compo-nodes' stamp: 'PetrSpacek 11/10/2012 00:14'!visitCompoInRequirementsNode: node	self indent.	codeStream nextPutAll: 'internally requires {'.		self indentWhile: [node ports do: [:n | self visitNode: n]].		(node ports isEmpty) ifFalse: [self indent].			codeStream nextPutAll: '}'.! !!CompoFormatter methodsFor: 'visiting-compo-nodes' stamp: 'PetrSpacek 11/10/2012 00:47'!visitCompoInterfaceNode: node	self shouldBeImplemented.! !!CompoFormatter methodsFor: 'visiting-compo-nodes' stamp: 'PetrSpacek 11/9/2012 23:42'!visitCompoParseNode: node! !!CompoFormatter methodsFor: 'visiting-compo-nodes' stamp: 'PetrSpacek 11/10/2012 01:13'!visitCompoPortAddressNode: node	codeStream		nextPutAll: (node left value asString);		nextPut: $@.			(node right isKindOf: (Smalltalk at: #CompoParseNode))		ifTrue: [			((node right isKindOf: (Smalltalk at: #CompoCollectionPortLiteralNode))			or: [node right isKindOf: (Smalltalk at: #CompoDereferenceLiteralNode)])				ifTrue: [ self visitNode: (node right) ]				ifFalse: [					codeStream nextPut: $(.					(node right isArray)						ifTrue: [(node right) do: [:e | self visitNode: e]]						ifFalse: [self visitNode: (node right)].					codeStream nextPut: $).				].		]		ifFalse: [codeStream nextPutAll: (node right value asString)].! !!CompoFormatter methodsFor: 'visiting-compo-nodes' stamp: 'PetrSpacek 11/11/2013 20:27'!visitCompoPortNode: node	self indent.	codeStream nextPutAll: (node pName value asString).		(node pIsCollectionPort) ifTrue: [ codeStream nextPutAll: '[]' ].		codeStream 		space;		nextPut: $: ;		space.		(node pInterface isArray)		ifTrue: [			codeStream nextPut: ${; space.			node pInterface do: [:n | self visitNode: n. codeStream nextPut: $; ; space. ].			codeStream nextPut: $}; nextPut: $;.		]		ifFalse: [ codeStream nextPutAll: (node pInterface value asString); nextPut: $;].		(node pKind) ifNotNil: [		codeStream			space;			nextPutAll: 'kind-of';			space;			nextPutAll: (node pKind value asString).	].	(node pInjection) ifNotNil: [		codeStream			space;			nextPutAll: 'inject-with';			space;			nextPutAll: (node pInjection value asString).	].! !!CompoFormatter methodsFor: 'visiting-compo-nodes' stamp: 'PetrSpacek 11/10/2012 01:23'!visitCompoServiceInvocationNode: node	self visitNode: (node receiver).	codeStream		nextPut: $. ;		nextPutAll: (node selector value asString);		nextPut: $(.			(node arguments) ifNotNil: [		(node arguments)			do: [:a |				self visitNode: a.				codeStream nextPut: $, ; space.			].		codeStream position: (codeStream position -2)	].	codeStream nextPut: $).	! !!CompoFormatter methodsFor: 'visiting-compo-nodes' stamp: 'PetrSpacek 11/10/2012 01:33'!visitCompoServiceNode: node	|pragmas statements|	self indent.	codeStream		nextPutAll: 'service';		space.	self visitNode: (node signature).	codeStream nextPut: ${.		pragmas := node body first.	statements := node body second.		self indentWhile: [		self indent.		pragmas do: [:p | self visitNode: p].		self visitNode: statements.	].		((pragmas isEmpty not) or: [statements statements isEmpty not]) ifTrue: [self indent].		codeStream nextPut: $}.! !!CompoFormatter methodsFor: 'visiting-compo-nodes' stamp: 'PetrSpacek 11/10/2012 00:24'!visitCompoServiceSignNode: node	codeStream		nextPutAll: (node selector value asString);		nextPut: $(.		(node arguments) ifNotNil: [			(node arguments)			do: [:a | codeStream nextPutAll: (a value asString); nextPut: $, ; space ].		codeStream position: (codeStream position -2)	].			codeStream 		nextPut: $).! !!CompoFormatter methodsFor: 'visiting-compo-nodes' stamp: 'PetrSpacek 11/11/2013 19:22'!visitCompoWhileNode: node	! !!CompoFormatter methodsFor: 'as yet unclassified' stamp: 'FerrandAnthony 2/5/2015 13:04'!visitCompoConnectionRockNode: node	self indent.	codeStream		nextPutAll: 'connect';		space.			self visitNode: (node srcAddress).			codeStream		space;		nextPutAll: 'to';		space.		self visitNode: (node destAddress).	codeStream nextPut: $;.! !CompoASTVisitorAbstract subclass: #CompoToSmalltalk	instanceVariableNames: 'codeStream declStream lineStart firstLineLength tabs areWeCompilingInvokeService target portNames sourceCode localNames forWorkspace'	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Parser-Visitor'!!CompoToSmalltalk methodsFor: 'accessing' stamp: 'PetrSpacek 11/13/2012 16:24'!convert: aNode	self visitNode: aNode.	(self isWhiteSpaceOnly: (declStream contents))		ifTrue: [			(self isWhiteSpaceOnly: (codeStream contents))				ifTrue: [^ String new]				ifFalse: [ ^ codeStream contents ].		]		ifFalse: [			^ declStream contents.		].! !!CompoToSmalltalk methodsFor: 'accessing' stamp: 'PetrSpacek 11/12/2013 00:03'!convert: aNode sourceCode: aString	sourceCode := aString.	self visitNode: aNode.	(self isWhiteSpaceOnly: (declStream contents))		ifTrue: [			(self isWhiteSpaceOnly: (codeStream contents))				ifTrue: [^ String new]				ifFalse: [ ^ codeStream contents ].		]		ifFalse: [			^ declStream contents.		].! !!CompoToSmalltalk methodsFor: 'accessing' stamp: 'PetrSpacek 11/11/2012 18:58'!firstLineLength	^firstLineLength isNil		ifTrue: [codeStream position]		ifFalse: [firstLineLength]! !!CompoToSmalltalk methodsFor: 'accessing' stamp: 'PetrSpacek 11/25/2013 02:45'!forWorkspace	^ forWorkspace! !!CompoToSmalltalk methodsFor: 'accessing' stamp: 'PetrSpacek 11/25/2013 02:45'!forWorkspace: anObject	forWorkspace := anObject! !!CompoToSmalltalk methodsFor: 'accessing' stamp: 'PetrSpacek 11/12/2012 16:21'!format: aNode 	self visitNode: aNode.	^codeStream contents! !!CompoToSmalltalk methodsFor: 'accessing' stamp: 'PetrSpacek 11/11/2012 18:58'!isMultiLine	^firstLineLength notNil! !!CompoToSmalltalk methodsFor: 'accessing' stamp: 'PetrSpacek 11/11/2012 18:58'!lastLineLength	^codeStream position - (lineStart max: 0)! !!CompoToSmalltalk methodsFor: 'accessing' stamp: 'PetrSpacek 11/12/2013 00:07'!sourceCode	^ sourceCode.! !!CompoToSmalltalk methodsFor: 'copying' stamp: 'PetrSpacek 11/11/2012 18:58'!postCopy	super postCopy.	lineStart := self lineLength negated.	codeStream := WriteStream on: (String new: 60).	firstLineLength := nil! !!CompoToSmalltalk methodsFor: 'initialize-release' stamp: 'PetrSpacek 12/15/2013 20:02'!initialize	super initialize.	codeStream := WriteStream on: (String new: 60).	declStream := WriteStream on: (String new: 60).	portNames := OrderedCollection new.	tabs := 0.	lineStart := 0.
	areWeCompilingInvokeService := false.	localNames := OrderedCollection new.! !!CompoToSmalltalk methodsFor: 'testing' stamp: 'PetrSpacek 11/11/2012 18:58'!startMessageSendOnNewLine: aMessageNode 	(self selectorsToStartOnNewLine includes: aMessageNode selector) 		ifTrue: [^true].	(self selectorsToLeaveOnLine includes: aMessageNode selector) 		ifTrue: [^false].	^aMessageNode selector numArgs > self maximumArgumentsPerLine! !!CompoToSmalltalk methodsFor: 'visiting' stamp: 'FerrandAnthony 2/6/2015 15:46'!visitNode: aNode 	| parenthesis |	parenthesis := self needsParenthesisFor: aNode.	parenthesis ifTrue: [codeStream nextPut: $(].	aNode acceptVisitor: self.	parenthesis ifTrue: [codeStream nextPut: $)]! !!CompoToSmalltalk methodsFor: 'visitor-double dispatching' stamp: 'PetrSpacek 11/11/2012 18:58'!acceptArrayNode: anArrayNode	codeStream nextPut: ${.	anArrayNode statements isEmpty ifFalse: [		anArrayNode statements size > 1			ifTrue: [				self indent: 1 while: [					self indent.					self formatStatementsFor: anArrayNode ].				self indent ]			ifFalse: [ self formatStatementsFor: anArrayNode ] ].	codeStream nextPut: $}! !!CompoToSmalltalk methodsFor: 'visitor-double dispatching' stamp: 'PetrSpacek 11/11/2012 18:58'!acceptAssignmentNode: anAssignmentNode 	self indent: 2		while: 			[self visitNode: anAssignmentNode variable.			codeStream space; nextPutAll: anAssignmentNode assignmentOperator; space.			self visitNode: anAssignmentNode value]! !!CompoToSmalltalk methodsFor: 'visitor-double dispatching' stamp: 'PetrSpacek 11/11/2012 18:58'!acceptBlockNode: aBlockNode 	self 		acceptBlockNode: aBlockNode		startBlockString: '['		endBlockString: ']'! !!CompoToSmalltalk methodsFor: 'visitor-double dispatching' stamp: 'PetrSpacek 11/25/2013 12:45'!acceptBlockNode: aBlockNode startBlockString: startBlockString endBlockString: endBlockString 	| seqNode multiline formattedBody formatter oldLocalNames|	seqNode := aBlockNode body.		oldLocalNames := localNames copy.	seqNode temporaries do: [ :varNode |		localNames add: (varNode name).	].		formatter := (self copy)				lineStart: 0;				yourself.	formattedBody := formatter format: seqNode.	multiline := self lineLength + formattedBody size > self maxLineSize 				or: [formatter isMultiLine].	multiline ifTrue: [self indent].	codeStream nextPutAll: startBlockString.	aBlockNode arguments do: 			[:each | 			codeStream nextPut: $:.			self visitNode: each.			codeStream nextPut: $ ].	aBlockNode arguments notEmpty 		ifTrue: 			[codeStream nextPutAll: '| '.			multiline ifTrue: [self indent]].	codeStream		nextPutAll: formattedBody;		nextPutAll: endBlockString.			localNames := oldLocalNames copy.! !!CompoToSmalltalk methodsFor: 'visitor-double dispatching' stamp: 'PetrSpacek 11/11/2012 18:58'!acceptCascadeNode: aCascadeNode 	| messages |	messages := aCascadeNode messages.	self visitNode: messages first receiver.	self indentWhile: 			[self 				for: messages				do: 					[:each | 					self						indent;						indentWhile: [self formatMessage: each cascade: true]]				separatedBy: [codeStream nextPut: $;]]! !!CompoToSmalltalk methodsFor: 'visitor-double dispatching' stamp: 'PetrSpacek 11/11/2012 18:58'!acceptLiteralArrayNode: aRBArrayLiteralNode 	codeStream nextPutAll: (aRBArrayLiteralNode isForByteArray 				ifTrue: ['#[']				ifFalse: ['#(']).	self 		for: aRBArrayLiteralNode contents		do: [:each | self visitNode: each]		separatedBy: [codeStream nextPut: $ ].	codeStream 		nextPut: (aRBArrayLiteralNode isForByteArray ifTrue: [$]] ifFalse: [$)])! !!CompoToSmalltalk methodsFor: 'visitor-double dispatching' stamp: 'PetrSpacek 11/11/2012 18:58'!acceptLiteralNode: aLiteralNode 	aLiteralNode token storeOn: codeStream! !!CompoToSmalltalk methodsFor: 'visitor-double dispatching' stamp: 'PetrSpacek 11/11/2012 18:58'!acceptMessageNode: aMessageNode 	| newFormatter code |	newFormatter := self copy.	code := newFormatter format: aMessageNode receiver.	codeStream nextPutAll: code.	codeStream nextPut: $ .	newFormatter isMultiLine		ifTrue: [lineStart := codeStream position - newFormatter lastLineLength].	self indent: (newFormatter isMultiLine ifTrue: [2] ifFalse: [1])		while: [self formatMessage: aMessageNode cascade: false]! !!CompoToSmalltalk methodsFor: 'visitor-double dispatching' stamp: 'PetrSpacek 11/11/2012 18:58'!acceptMethodNode: aMethodNode 	self formatMethodPatternFor: aMethodNode.	self indentWhile: [		self formatMethodCommentFor: aMethodNode indentBefore: true.		self indent.		self formatPragmasFor: aMethodNode.		aMethodNode body statements notEmpty 			ifTrue: [ self visitNode: aMethodNode body ] ]! !!CompoToSmalltalk methodsFor: 'visitor-double dispatching' stamp: 'PetrSpacek 11/11/2012 18:58'!acceptPatternBlockNode: aRBPatternBlockNode 	self 		acceptBlockNode: aRBPatternBlockNode		startBlockString: '`{'		endBlockString: '}'! !!CompoToSmalltalk methodsFor: 'visitor-double dispatching' stamp: 'PetrSpacek 11/11/2012 18:58'!acceptPatternWrapperBlockNode: aRBPatternWrapperBlockNode 	self visitNode: aRBPatternWrapperBlockNode wrappedNode.	self 		acceptBlockNode: aRBPatternWrapperBlockNode		startBlockString: '`{'		endBlockString: '}'! !!CompoToSmalltalk methodsFor: 'visitor-double dispatching' stamp: 'PetrSpacek 11/24/2013 22:17'!acceptPragmaNode: aPragmaNode	codeStream		nextPutAll: '(self '.			aPragmaNode selector isInfix		ifTrue: [ codeStream nextPut: $ ].	self formatMessage: aPragmaNode cascade: false.	codeStream		space		nextPut: $";		nextPutAll: 'compo vm primitive call';		nextPut: $";		nextPutAll: ')'.! !!CompoToSmalltalk methodsFor: 'visitor-double dispatching' stamp: 'PetrSpacek 11/11/2012 20:32'!acceptReturnNode: aReturnNode 	codeStream nextPutAll: '^ ('.	self visitNode: aReturnNode value.	codeStream nextPutAll: ').'.! !!CompoToSmalltalk methodsFor: 'visitor-double dispatching' stamp: 'PetrSpacek 11/24/2013 23:23'!acceptSelfNode: aSelfNode	^ self acceptVariableNode: aSelfNode! !!CompoToSmalltalk methodsFor: 'visitor-double dispatching' stamp: 'PetrSpacek 11/25/2013 12:47'!acceptSequenceNode: aSequenceNode 	|oldLocalNames|	oldLocalNames := localNames copy.	aSequenceNode temporaries do: [ :varNode |		localNames add: (varNode name).	].	self formatMethodCommentFor: aSequenceNode indentBefore: false.	self formatTemporariesFor: aSequenceNode.	self formatStatementsFor: aSequenceNode.		localNames := oldLocalNames copy.! !!CompoToSmalltalk methodsFor: 'visitor-double dispatching' stamp: 'PetrSpacek 11/25/2013 13:08'!acceptVariableNode: aVariableNode 	((localNames includes: aVariableNode name))		ifTrue: [ codeStream nextPutAll: aVariableNode name. ]		ifFalse: [ 						 (Smalltalk includesKey: aVariableNode name)				ifTrue: [ 					((Smalltalk at: aVariableNode name) isKindOf: (Smalltalk at: #Descriptor))						ifTrue: [							codeStream								nextPutAll: aVariableNode name asString;								nextPutAll: ' cs__getPortNamed__par01: #default'.						]						ifFalse: [ 							codeStream								nextPutAll: aVariableNode name asString;								nextPutAll: ' defaultPort'.						]				 ]				ifFalse: [ 					(forWorkspace)						ifTrue: [ codeStream nextPutAll: aVariableNode name ]						ifFalse: [ 							codeStream								nextPutAll: 'self cs__getPortNamed__par01: (#';								nextPutAll: aVariableNode name asString;								nextPutAll: ')'.						].				].		].! !!CompoToSmalltalk methodsFor: 'private' stamp: 'PetrSpacek 11/22/2013 02:49'!escapeString: aString	|sb|	sb := TextStream on: String new.	aString do: [ :char |		(char == $') ifTrue: [ sb nextPut: char. ].		sb nextPut: char. 	].	^sb contents.! !!CompoToSmalltalk methodsFor: 'private' stamp: 'PetrSpacek 11/11/2012 18:58'!for: aValue do: doBlock separatedBy: separatorBlock 	"This is implemented here since IBM Smalltalk doesn't implement a do:separatedBy: method"	aValue isEmpty ifTrue: [^self].	1 to: aValue size - 1		do: 			[:i | 			doBlock value: (aValue at: i).			separatorBlock value].	doBlock value: aValue last! !!CompoToSmalltalk methodsFor: 'private' stamp: 'PetrSpacek 11/11/2012 18:58'!indent	firstLineLength isNil ifTrue: [firstLineLength := codeStream position].	codeStream cr.	tabs timesRepeat: [codeStream tab].	lineStart := codeStream position! !!CompoToSmalltalk methodsFor: 'private' stamp: 'PetrSpacek 11/11/2012 18:58'!indent: anInteger while: aBlock 	tabs := tabs + anInteger.	aBlock value.	tabs := tabs - anInteger! !!CompoToSmalltalk methodsFor: 'private' stamp: 'PetrSpacek 11/11/2012 18:58'!indentWhile: aBlock 	self indent: 1 while: aBlock! !!CompoToSmalltalk methodsFor: 'private' stamp: 'PetrSpacek 11/13/2012 16:23'!isWhiteSpaceOnly: aString	|onlyWhiteSpace|	onlyWhiteSpace := true.	aString do: [:ch | onlyWhiteSpace := onlyWhiteSpace and: [ch isSeparator]].	^ onlyWhiteSpace.! !!CompoToSmalltalk methodsFor: 'private' stamp: 'PetrSpacek 11/11/2012 18:58'!lineLength	^codeStream position - lineStart! !!CompoToSmalltalk methodsFor: 'private' stamp: 'PetrSpacek 11/11/2012 18:58'!lineStart: aPosition 	lineStart := aPosition! !!CompoToSmalltalk methodsFor: 'private' stamp: 'PetrSpacek 11/11/2012 18:58'!maxLineSize	^75! !!CompoToSmalltalk methodsFor: 'private' stamp: 'PetrSpacek 11/11/2012 18:58'!maximumArgumentsPerLine	^2! !!CompoToSmalltalk methodsFor: 'private' stamp: 'PetrSpacek 11/11/2012 18:58'!needsParenthesisFor: aNode	| parent grandparent |	aNode isValue ifFalse: [ ^ false ].	parent := aNode parent ifNil: [ ^ false ].	(aNode isMessage and: [ parent isMessage and: [ parent receiver == aNode ] ]) ifTrue: [		grandparent := parent parent.		(grandparent notNil and: [ grandparent isCascade ])			ifTrue: [ ^ true ] ].	(aNode precedence < parent precedence) ifTrue: [ ^ false ].	(aNode isAssignment and: [ parent isAssignment ]) ifTrue: [ ^ false ].	(aNode isAssignment and: [ aNode isCascade ]) ifTrue: [ ^ true ].	(aNode precedence = 0) ifTrue: [ ^ false ].	(aNode isMessage) ifFalse: [ ^ true ].	(aNode precedence = parent precedence) ifFalse: [ ^ true ].	(aNode isUnary) ifTrue: [ ^ false ].	(aNode isKeyword) ifTrue: [ ^ true ].	(parent receiver == aNode) ifFalse: [ ^ true ].	^ self precedenceOf: parent selector greaterThan: aNode selector! !!CompoToSmalltalk methodsFor: 'private' stamp: 'PetrSpacek 11/11/2012 18:58'!precedenceOf: parentSelector greaterThan: childSelector 	"Put parenthesis around things that are preceived to have 'lower' precedence. For example, 'a + b * c' 	-> '(a + b) * c' but 'a * b + c' -> 'a * b + c'"	| childIndex parentIndex operators |	operators := #(#($| $& $?) #($= $~ $< $>) #($- $+) #($* $/ $% $\) #($@)).	childIndex := 0.	parentIndex := 0.	1 to: operators size		do: 			[:i | 			((operators at: i) includes: parentSelector first) 				ifTrue: [parentIndex := i].			((operators at: i) includes: childSelector first) 				ifTrue: [childIndex := i]].	^childIndex < parentIndex! !!CompoToSmalltalk methodsFor: 'private' stamp: 'PetrSpacek 11/11/2012 18:58'!selectorsToLeaveOnLine	^#(#to:do: #to:by: #to:by:do:)! !!CompoToSmalltalk methodsFor: 'private' stamp: 'PetrSpacek 11/11/2012 18:58'!selectorsToStartOnNewLine	^#(#ifTrue:ifFalse: #ifFalse:ifTrue: #ifTrue: #ifFalse:)! !!CompoToSmalltalk methodsFor: 'private-formatting' stamp: 'PetrSpacek 11/24/2013 22:26'!formatMessage: aMessageNode cascade: cascadeBoolean 	| selectorParts arguments multiLine formattedArgs indentFirst firstArgLength length |	selectorParts := aMessageNode selectorParts.	arguments := aMessageNode arguments.	formattedArgs := OrderedCollection new.	multiLine := aMessageNode selector numArgs > self maximumArgumentsPerLine.	length := aMessageNode selector size + arguments size + 1.	firstArgLength := 0.	self indentWhile: 			[1 to: arguments size				do: 					[:i | 					| formatter string |					formatter := (self copy)								lineStart: (selectorParts at: i) length negated;								yourself.					string := formatter format: (arguments at: i).					formattedArgs add: string.					i == 1 ifTrue: [firstArgLength := formatter firstLineLength].					length := length + string size.					multiLine := multiLine or: [formatter isMultiLine]]].	multiLine := multiLine or: [length + self lineLength > self maxLineSize].	indentFirst := cascadeBoolean not and: 					[multiLine and: 							[(self startMessageSendOnNewLine: aMessageNode) or: 									[self lineLength + selectorParts first length + 2 + firstArgLength 										> self maxLineSize]]].	indentFirst ifTrue: [self indent].	self 		formatMessageSelector: selectorParts		withArguments: formattedArgs		multiline: multiLine! !!CompoToSmalltalk methodsFor: 'private-formatting' stamp: 'PetrSpacek 11/11/2012 18:58'!formatMessageSelector: selectorParts withArguments: formattedArgs multiline: multiLine 	formattedArgs isEmpty 		ifTrue: [codeStream nextPutAll: selectorParts first value]		ifFalse: 			[1 to: formattedArgs size				do: 					[:i | 					(i ~= 1 and: [ multiLine not ])						ifTrue: [codeStream nextPut: $ ].					codeStream 						nextPutAll: (selectorParts at: i) value;						nextPut: $ ;						nextPutAll: (formattedArgs at: i).					(multiLine and: [i < formattedArgs size]) ifTrue: [self indent]]]! !!CompoToSmalltalk methodsFor: 'private-formatting' stamp: 'PetrSpacek 11/11/2012 18:58'!formatMethodCommentFor: aNode indentBefore: aBoolean 	| source |	source := aNode source.	source isNil ifTrue: [^self].	aNode methodComments do: 			[:each | 			aBoolean ifTrue: [self indent].			codeStream				nextPutAll: (aNode source copyFrom: each first to: each last);				cr.			aBoolean ifFalse: [self indent]]! !!CompoToSmalltalk methodsFor: 'private-formatting' stamp: 'PetrSpacek 11/11/2012 18:58'!formatMethodPatternFor: aMethodNode 	| selectorParts arguments |	selectorParts := aMethodNode selectorParts.	arguments := aMethodNode arguments.	arguments isEmpty 		ifTrue: [codeStream nextPutAll: selectorParts first value]		ifFalse: 			[selectorParts with: arguments				do: 					[:selector :arg | 					codeStream						nextPutAll: selector value;						nextPut: $ .					self visitArgument: arg.					codeStream nextPut: $ ]]! !!CompoToSmalltalk methodsFor: 'private-formatting' stamp: 'PetrSpacek 11/11/2012 18:58'!formatPragmasFor: aNode	aNode pragmas do: [ :each | self visitNode: each; indent ]! !!CompoToSmalltalk methodsFor: 'private-formatting' stamp: 'PetrSpacek 11/11/2012 18:58'!formatStatementCommentFor: aNode 	| source |	source := aNode source.	source isNil ifTrue: [^self].	aNode statementComments do: 			[:each | 			| crs |			crs := self newLinesFor: source startingAt: each first.			(crs - 1 max: 0) timesRepeat: [codeStream cr].			crs == 0 ifTrue: [codeStream tab] ifFalse: [self indent].			codeStream nextPutAll: (source copyFrom: each first to: each last)]! !!CompoToSmalltalk methodsFor: 'private-formatting' stamp: 'PetrSpacek 11/11/2012 18:58'!formatStatementsFor: aSequenceNode 	| statements |	statements := aSequenceNode statements.	statements isEmpty ifTrue: [^self].	1 to: statements size - 1		do: 			[:i | 			self visitNode: (statements at: i).			codeStream nextPut: $..			self formatStatementCommentFor: (statements at: i).			self indent].	self visitNode: statements last.	self formatStatementCommentFor: statements last! !!CompoToSmalltalk methodsFor: 'private-formatting' stamp: 'PetrSpacek 11/11/2012 18:58'!formatTemporariesFor: aSequenceNode 	| temps |	temps := aSequenceNode temporaries.	temps isEmpty ifTrue: [^self].	codeStream nextPutAll: '| '.	temps do: 			[:each | 			self visitArgument: each.			codeStream nextPut: $ ].	codeStream nextPut: $|.	self indent! !!CompoToSmalltalk methodsFor: 'private-formatting' stamp: 'PetrSpacek 11/11/2012 18:58'!newLinesFor: aString startingAt: anIndex 	| count cr lf index char |	cr := Character value: 13.	lf := Character value: 10.	count := 0.	index := anIndex - 1.	[index > 0 and: 			[char := aString at: index.			char isSeparator]] 		whileTrue: 			[char == lf 				ifTrue: 					[count := count + 1.					(aString at: (index - 1 max: 1)) == cr ifTrue: [index := index - 1]].			char == cr ifTrue: [count := count + 1].			index := index - 1].	^count! !!CompoToSmalltalk methodsFor: 'visiting-compo-nodes' stamp: 'PetrSpacek 11/26/2013 18:05'!extVisitCompoServiceInvocationNode: node	|isMetacall|		isMetacall := (node receiver isKindOf: (Smalltalk at: #CompoDereferenceLiteralNode)).			codeStream nextPut: $(; nextPut: $(.	self visitNode: (node receiver).	codeStream 		nextPut: $) ;		space.						codeStream 		nextPutAll: 'cs__invoke__par01: ';		nextPutAll: 'service'; 		space;		nextPutAll: 'par02: ';		nextPutAll: (isMetacall asString);		nextPut: $ .					! !!CompoToSmalltalk methodsFor: 'visiting-compo-nodes' stamp: 'PetrSpacek 11/26/2013 18:00'!stdVisitCompoServiceInvocationNode: node	|isMetacall|					codeStream nextPut: $(; nextPut: $(.	self visitNode: (node receiver).	codeStream 		nextPut: $) ;		space.			isMetacall := (node receiver isKindOf: (Smalltalk at: #CompoDereferenceLiteralNode)).			codeStream 		nextPutAll: 'cs__invoke__par01: (ServiceInvocation selector: #';		nextPutAll: (node selector value asString);		nextPutAll: ' arguments: {'.			(node arguments) ifNotNil: [		(node arguments)			do: [:a |				codeStream nextPut: $(.				self visitNode: a.				codeStream nextPutAll: '). '.			].	].	codeStream		nextPut: $};		nextPutAll: ' originPort: ('.	self visitNode: (node receiver).	codeStream 		nextPut: $) ;		space.		(node receiver isKindOf: (Smalltalk at: #CompoCollectionPortLiteralNode))		ifTrue: [			codeStream nextPutAll: ' index: ('.			self visitNode: (node receiver indexExpr).			codeStream nextPut: $).		].		codeStream 		nextPut: $) ;		space;		nextPutAll: 'par02: ';		nextPutAll: (isMetacall asString);		nextPut: $) .					! !!CompoToSmalltalk methodsFor: 'visiting-compo-nodes' stamp: 'PetrSpacek 11/11/2012 18:58'!visitCompoArchitectureNode: node	self indent.	codeStream nextPutAll: 'architecture {'.		self indentWhile: [node disconns do: [:n | self visitNode: n]].	self indentWhile: [node conns do: [:n | self visitNode: n]].		((node disconns isEmpty not) or: [node conns isEmpty not]) ifTrue: [self indent].		codeStream nextPutAll: '}'.! !!CompoToSmalltalk methodsFor: 'visiting-compo-nodes' stamp: 'PetrSpacek 11/11/2012 18:58'!visitCompoBindNode: node! !!CompoToSmalltalk methodsFor: 'visiting-compo-nodes' stamp: 'PetrSpacek 11/11/2012 19:39'!visitCompoCollectionPortLiteralNode: node	codeStream nextPutAll: (node portName value asString).	"codeStream nextPut: $[."	"this is done in visitPortAddressNode"	"self visitNode: (node indexExpr)."	"codeStream nextPut: $]."! !!CompoToSmalltalk methodsFor: 'visiting-compo-nodes' stamp: 'FerrandAnthony 2/7/2015 10:28'!visitCompoConnectionNode: node	|cKind sComp dComp sPort dPort |	(node parent isKindOf: (Smalltalk at: #CompoArchitectureNode))		ifTrue: [			target ifNil: [^ self].						(node kind isNil)				ifTrue: [ cKind := '#NULL']				ifFalse: [ cKind := '#', (node kind value asString) ].							sComp := (CompoFormatter new format: (node srcAddress)).			sComp := sComp copyFrom: ((node srcAddress left stop + 3) - (node srcAddress left start)) to: (sComp size).						dComp := (CompoFormatter new format: (node destAddress)).			dComp := dComp copyFrom: ((node destAddress left stop + 3) - (node destAddress left start)) to: (dComp size).						sPort := node srcAddress left value asString.			dPort := node destAddress left value asString.						"addToTargetNewConnectionDescriptionInstance_srcComp:srcPort:destComp:destPort:isDisconn:"			declStream 				nextPutAll: 'db addToTargetNewConnectionDescriptionInstance_srcComp:';				space;				nextPut: $' ;				nextPutAll: (sComp asString);				nextPut: $' ;				space;								nextPutAll: 'srcPort:';				space;				nextPut: $' ;				nextPutAll: (sPort asString);				nextPut: $' ;				space;								nextPutAll: 'destComp:';				space;				nextPut: $' ;				nextPutAll: (dComp asString);				nextPut: $' ;				space;								nextPutAll: 'destPort:';				space;				nextPut: $' ;				nextPutAll: (dPort asString);				nextPut: $' ;				space;								nextPutAll: 'isDisconn:';				space;				nextPutAll: (false asString);				space;				nextPut: $.;				crlf.		]		ifFalse: [			codeStream nextPut: $(.			self visitNode: (node srcAddress).			codeStream nextPut: $).			self indent.			codeStream				tab;				nextPutAll:  'cs__connectTo__par01: ('.			self visitNode: (node destAddress).			codeStream				nextPut: $) ;				nextPut: $. 		].		! !!CompoToSmalltalk methodsFor: 'visiting-compo-nodes' stamp: 'PetrSpacek 12/15/2013 21:56'!visitCompoDereferenceLiteralNode: node	"node applicationsCount timesRepeat: [ codeStream nextPut: $& ]."	|varname|	varname := node literal value asString .	(localNames includes:  varname)		ifTrue: [codeStream nextPutAll: varname]		ifFalse: [ 			codeStream				nextPutAll: '(self cs__getPortNamed__par01: #';				nextPutAll: (node literal value asString );				nextPut: $).		].! !!CompoToSmalltalk methodsFor: 'visiting-compo-nodes' stamp: 'PetrSpacek 11/23/2013 07:57'!visitCompoDescriptorNode: node	|extends|	declStream 		nextPutAll: 'db := DescriptorBuilder new.';		crlf;		nextPutAll: 'db startBuildSession.';		crlf.		 	declStream		nextPutAll: 'db instOf:';		space;		nextPutAll: node metadesc value asString;		space;		nextPutAll: 'superdescriptor: '.		(node extends)		ifNil: [ extends := ' Component' ]		ifNotNil: [ extends := (node extends value asString) ].	declStream		nextPut: $#;		nextPutAll: (extends asString);		space;		nextPutAll: 'subdescriptor:';		space;		nextPut: $#;		nextPutAll: (node name value asString);		space;		nextPutAll: 'category:';		space;		nextPut: $';		nextPutAll: 'Compo-Meta';		nextPut: $';		nextPut: $. ;		crlf.		target := node name value asString.		node body do: [:n |		(n isKindOf: (Smalltalk at: #CompoServiceNode))			ifFalse: [ self visitNode: n ].	].	node body do: [:n |		(n isKindOf: (Smalltalk at: #CompoServiceNode))			ifTrue: [				|beforePos afterPos code|				beforePos := ((codeStream position) == 0) ifTrue: [1] ifFalse: [codeStream position + 1].				self visitNode: n.				afterPos := codeStream position.				code := (codeStream contents copyFrom: (beforePos) to: (afterPos)).				code := (code printString).								declStream					nextPutAll: '(Smalltalk at: #';					nextPutAll: (target asString);					nextPutAll: ') compile: (';					nextPutAll: code;					nextPutAll: ') classified: ''default-interface''.';					crlf.			].	].			declStream 		nextPutAll: '(Smalltalk at: #';		nextPutAll: (target asString);		nextPutAll: ') instVarNamed: #code put: (''';		nextPutAll: (self escapeString: (node source));		nextPutAll: ''').';		crlf;		nextPutAll: 'db stopBuildSession.';		crlf;		nextPutAll: '(Smalltalk at: #';		nextPutAll: (target asString);		nextPutAll: ').';		crlf.		! !!CompoToSmalltalk methodsFor: 'visiting-compo-nodes' stamp: 'PetrSpacek 11/13/2013 14:40'!visitCompoDisconnectionNode: node	|cKind sComp dComp sPort dPort |	(node parent isKindOf: (Smalltalk at: #CompoArchitectureNode))		ifTrue: [			target ifNil: [^ self].						(node kind isNil)				ifTrue: [ cKind := '#NULL']				ifFalse: [ cKind := '#', (node kind value asString) ].							sComp := (CompoFormatter new format: (node srcAddress)).			sComp := sComp copyFrom: ((node srcAddress left stop + 3) - (node srcAddress left start)) to: (sComp size).						dComp := (CompoFormatter new format: (node destAddress)).			dComp := dComp copyFrom: ((node destAddress left stop + 3) - (node destAddress left start)) to: (dComp size).						sPort := node srcAddress left value asString.			dPort := node destAddress left value asString.						"addToTargetNewConnectionDescriptionInstance_srcComp:srcPort:destComp:destPort:isDisconn:"			declStream 				nextPutAll: 'db addToTargetNewConnectionDescriptionInstance_srcComp:';				space;				nextPut: $' ;				nextPutAll: (sComp asString);				nextPut: $' ;				space;								nextPutAll: 'srcPort:';				space;				nextPut: $' ;				nextPutAll: (sPort asString);				nextPut: $' ;				space;								nextPutAll: 'destComp:';				space;				nextPut: $' ;				nextPutAll: (dComp asString);				nextPut: $' ;				space;								nextPutAll: 'destPort:';				space;				nextPut: $' ;				nextPutAll: (dPort asString);				nextPut: $' ;				space;								nextPutAll: 'isDisconn:';				space;				nextPutAll: (true asString);				space;				nextPut: $.;				crlf.		]		ifFalse: [			codeStream nextPut: $(.			self visitNode: (node srcAddress).			codeStream				nextPut: $);				space;				nextPutAll: 'cs__disconnect';				nextPut: $. 		].		! !!CompoToSmalltalk methodsFor: 'visiting-compo-nodes' stamp: 'PetrSpacek 11/11/2012 19:27'!visitCompoExProvisionsNode: node		node ports do: [:n | self visitNode: n].! !!CompoToSmalltalk methodsFor: 'visiting-compo-nodes' stamp: 'PetrSpacek 11/11/2012 19:27'!visitCompoExRequirementsNode: node	node ports do: [:n | self visitNode: n].! !!CompoToSmalltalk methodsFor: 'visiting-compo-nodes' stamp: 'PetrSpacek 11/25/2013 12:44'!visitCompoForNode: node	|pragmas statements oldLocalNames |		pragmas := node body first.	statements := node body second.		oldLocalNames := localNames copy.	statements temporaries do: [ :varNode |		localNames add: (varNode name).	].	codeStream nextPut: $[; space.	codeStream nextPutAll: '"For cycle begin"'.	self indentWhile: [		self indent.		codeStream nextPut: $|; space.		self visitNode: (node seed variable).		codeStream space; nextPut: $| .		self indent.		self visitNode: (node seed).		codeStream nextPut: $. .		self indent.		codeStream nextPut: $[; space.		self visitNode: (node condition).		codeStream			space;			nextPut: $];			space;			nextPutAll: 'whileTrue: [ '.			self indentWhile: [			self indent.			pragmas do: [:p | self visitNode: p].			self visitNode: statements.			self indent.			codeStream nextPutAll: '"iteration"'.			self indent.			self visitNode: node incrementation .			codeStream nextPut: $. .		].		self indent.		codeStream			space;			nextPut: $];			nextPut: $. .	].	self indent.	codeStream		nextPut: $]; space;		nextPutAll: 'value';		nextPut: $. ; space;		nextPutAll: '"For cycle end"';				crlf.	localNames := oldLocalNames copy.! !!CompoToSmalltalk methodsFor: 'visiting-compo-nodes' stamp: 'PetrSpacek 11/25/2013 12:44'!visitCompoIfNode: node	|pragmas statements oldLocalNames|	pragmas := node ifBody first.	statements := node ifBody second.		oldLocalNames := localNames copy.	statements temporaries do: [ :varNode |		localNames add: (varNode name).	].			codeStream nextPut: $(; space.	self visitNode: (node condition).	codeStream		space;		nextPut: $);		space;		nextPutAll: 'ifTrue: [ '.		self indentWhile: [		self indent.		pragmas do: [:p | self visitNode: p].		self visitNode: statements.	].	self indent.	codeStream		space;		nextPut: $].	"else"	node elseBody ifNotNil: [ 		codeStream nextPutAll: ' ifFalse: ['.		pragmas := node elseBody first.		statements := node elseBody second.				localNames := oldLocalNames copy.		statements temporaries do: [ :varNode |			localNames add: (varNode name).		].						self indentWhile: [			self indent.			pragmas do: [:p | self visitNode: p].			self visitNode: statements.		].		self indent.		codeStream			space;			nextPut: $];			crlf.	].	codeStream		nextPut: $.;		crlf.		localNames := oldLocalNames copy.! !!CompoToSmalltalk methodsFor: 'visiting-compo-nodes' stamp: 'PetrSpacek 11/11/2012 19:27'!visitCompoInProvisionsNode: node	node ports do: [:n | self visitNode: n].! !!CompoToSmalltalk methodsFor: 'visiting-compo-nodes' stamp: 'PetrSpacek 11/11/2012 19:27'!visitCompoInRequirementsNode: node	node ports do: [:n | self visitNode: n].! !!CompoToSmalltalk methodsFor: 'visiting-compo-nodes' stamp: 'PetrSpacek 11/11/2012 18:58'!visitCompoInterfaceNode: node	self shouldBeImplemented.! !!CompoToSmalltalk methodsFor: 'visiting-compo-nodes' stamp: 'PetrSpacek 11/11/2012 18:58'!visitCompoParseNode: node! !!CompoToSmalltalk methodsFor: 'visiting-compo-nodes' stamp: 'FerrandAnthony 2/11/2015 10:57'!visitCompoPortAddressNode: node	(node right isKindOf: (Smalltalk at: #CompoParseNode))		ifTrue: [			((node right isKindOf: (Smalltalk at: #CompoCollectionPortLiteralNode))			or: [node right isKindOf: (Smalltalk at: #CompoDereferenceLiteralNode)])				ifTrue: [					codeStream nextPut: $(.					codeStream nextPut: $(.					self visitNode: (node right).					codeStream nextPut: $).					(node right isKindOf: (Smalltalk at: #CompoCollectionPortLiteralNode))						ifTrue: [							codeStream								nextPutAll: ' cs__invoke__par01: (ServiceInvocation selector: #getPortNamed arguments: { #''';								nextPutAll: (node left value asString);								nextPutAll: '''} originPort: ('.							self visitNode: (node right).							codeStream								nextPutAll: ') index: ('.							self visitNode: (node right indexExpr).								codeStream								nextPut: $) ;								space;								nextPutAll: 'par02: false';								nextPut: $) .						]						ifFalse: [							codeStream								nextPutAll: ' cs__invoke__par01: (ServiceInvocation selector: #getPortNamed arguments: { #''';								nextPutAll: (node left value asString);								nextPutAll: '''} originPort: ('.							self visitNode: (node right).							codeStream								nextPutAll: ') index: nil) ';								nextPutAll: 'par02: true';								nextPut: $) .						].					codeStream nextPut: $).				]				ifFalse: [					codeStream						nextPut: $(;						nextPut: $(.					(node right isArray)						ifTrue: [(node right) do: [:e | self visitNode: e]]						ifFalse: [self visitNode: (node right)].					codeStream						nextPut: $);						nextPutAll: ' cs__invoke__par01: (ServiceInvocation selector: #getPortNamed arguments: { #''';						nextPutAll: (node left value asString);						nextPutAll: '''} originPort: ('.					(node right isArray)						ifTrue: [(node right) do: [:e | self visitNode: e]]						ifFalse: [self visitNode: (node right)].					codeStream						nextPutAll: ') index: nil) ';						nextPutAll: 'par02: false';						nextPut: $) .				].		]		ifFalse: [			codeStream				nextPut: $(;				nextPut: $(.			((localNames includes: node right value asSymbol) or: [ (localNames includes: node right value asString) ])				ifTrue: [ codeStream nextPutAll: (node right value asString)  ]				ifFalse: [ 					codeStream						nextPutAll: 'self cs__getPortNamed: #';						nextPutAll: (node right value asString).										].			codeStream				nextPut: $);				nextPutAll: ' cs__invoke__par01: (ServiceInvocation selector: #getPortNamed arguments: { #''';				nextPutAll: (node left value asString);				nextPutAll: '''} originPort: ('.						((localNames includes: node right value asSymbol) or: [ (localNames includes: node right value asString) ])				ifTrue: [ codeStream nextPutAll: (node right value asString)  ]				ifFalse: [ 					codeStream						nextPutAll: 'self cs__getPortNamed: #';						nextPutAll: (node right value asString).										].							codeStream				nextPutAll: ') index: nil) ';				nextPutAll: 'par02: false';				nextPut: $) .		].! !!CompoToSmalltalk methodsFor: 'visiting-compo-nodes' stamp: 'FerrandAnthony 2/11/2015 11:05'!visitCompoPortNode: node	|role visibility pName pInterface pKind pInjection|		target ifNil: [^ self].		(portNames includes: (node pName value asSymbol))		ifFalse: [ portNames add: (node pName value asSymbol) ].		(node parent isKindOf: (Smalltalk at: #CompoExRequirementsNode))		ifTrue: [ role:= #required. visibility := #external].			(node parent isKindOf: (Smalltalk at: #CompoExProvisionsNode))		ifTrue: [ role:= #provided. visibility := #external].		(node parent isKindOf: (Smalltalk at: #CompoInRequirementsNode))		ifTrue: [ role:= #required. visibility := #internal].		(node parent isKindOf: (Smalltalk at: #CompoInProvisionsNode))		ifTrue: [ role:= #provided. visibility := #internal].			(node pKind)		ifNil: [			pKind := '#Port'.			(role == #required)				ifTrue: [ 					(node pIsCollectionPort)						ifTrue: [ pKind := '#CRequiredPort' ]						ifFalse: [ pKind := '#SRequiredPort' ].				]				ifFalse: [ 					(node pIsCollectionPort)						ifTrue: [ pKind := '#CProvidedPort' ]						ifFalse: [ pKind := '#SProvidedPort' ].				]		]		ifNotNil: [ pKind := '#',(node pKind value asString) ].		(node pInjection)		ifNil: [ pInjection := '#NULL']		ifNotNil: [ pInjection := '#',(node pInjection value asString)	].			"finally we produce declaration"	declStream 		nextPutAll: 'db addToTargetNewPortDescriptionInstance_name: #';		nextPutAll: (node pName value asString);		nextPutAll: ' role: #';		nextPutAll: (role asString);		nextPutAll: ' visibility: #';		nextPutAll: (visibility asString);		nextPutAll: ' interface: '.			(node pInterface isArray)		ifTrue: [			declStream				nextPut: $#;				nextPut: $(;				space.						node pInterface do: [:n | 				declStream 					nextPutAll: '#''';					nextPutAll: (n selector value asString).									(n arguments isEmpty)					ifTrue: [ declStream nextPutAll: '()'.]					ifFalse: [														declStream nextPut: $( .						(n arguments) do: [:a |							declStream								nextPutAll: (a value asString);								nextPut: $, ;								space .						].						declStream position: (declStream position -2).						declStream nextPut: $).					].								declStream 					nextPutAll: ''''.			].					declStream nextPut: $).		]		ifFalse: [			declStream				nextPut: $#;				nextPutAll: (node pInterface value asString).		].				declStream				nextPutAll: ' kind: ';		nextPutAll: (pKind asString);		nextPutAll: ' isCollection: ';		nextPutAll: ((node pIsCollectionPort) asString);		nextPut: $. ;		crlf.! !!CompoToSmalltalk methodsFor: 'visiting-compo-nodes' stamp: 'PetrSpacek 11/26/2013 18:01'!visitCompoServiceInvocationNode: node		(areWeCompilingInvokeService)		ifTrue: [ self extVisitCompoServiceInvocationNode: node ]		ifFalse: [ self stdVisitCompoServiceInvocationNode: node ].				! !!CompoToSmalltalk methodsFor: 'visiting-compo-nodes' stamp: 'PetrSpacek 11/26/2013 17:59'!visitCompoServiceNode: node	|pragmas statements|	localNames removeAll.				self visitNode: (node signature).		areWeCompilingInvokeService := ((node signature selector = #invoke) and:										 [ (Smalltalk at: target asSymbol) inheritsFrom: (Smalltalk at: #Port) ]).		pragmas := node body first.	statements := node body second.		statements temporaries do: [ :varNode |		localNames add: (varNode name).	].		"code translation"	self indentWhile: [		self indent.		pragmas do: [:p | self visitNode: p].		self visitNode: statements.	].		declStream 		nextPutAll: 'db addToTargetNewServiceInstance_name:';		space;		nextPut: $#;		nextPutAll: (node signature selector value);		space;		nextPutAll: 'paramNames: #(';		space.			(node signature arguments) do: [ :ar |		declStream			nextPut: $#;			nextPutAll: ar value;			space.	].	declStream		nextPut: $);		space;		nextPutAll: 'tempsNames:';		space;		nextPutAll: '#()';		space;		nextPutAll: 'code:';		space;		nextPut: $' ;		nextPutAll: (self escapeString: (self sourceCode copyFrom: (node bodyStart) to: (node bodyEnd)));		nextPut: $' ;		nextPut: $. ;		crlf.	areWeCompilingInvokeService := false.! !!CompoToSmalltalk methodsFor: 'visiting-compo-nodes' stamp: 'PetrSpacek 11/24/2013 23:44'!visitCompoServiceSignNode: node	codeStream		nextPutAll: 'cs__';		nextPutAll: (node selector value asString).				((node arguments isNil == false ) and: [ node arguments size > 0 ]) ifTrue: [			codeStream			nextPut: $_;			nextPut: $_;			nextPutAll: 'par01:'.		(node arguments)			withIndexDo: [ :a :i |				codeStream						space;						nextPutAll: (a value asString).				localNames add: (a value asString).				"if it is not the last param"				((i) == (node arguments size))					ifFalse: [						codeStream 							space;							nextPutAll: 'par'.						((i+1) < 10) ifTrue: [ codeStream nextPut: $0 ] .						codeStream							nextPutAll: ((i+1) asString);							nextPut: $:.					]			].			].		! !!CompoToSmalltalk methodsFor: 'visiting-compo-nodes' stamp: 'PetrSpacek 11/25/2013 12:44'!visitCompoWhileNode: node	|pragmas statements oldLocalNames |	pragmas := node body first.	statements := node body second.		oldLocalNames := localNames copy.	statements temporaries do: [ :varNode |		localNames add: (varNode name).	].		codeStream nextPut: $[; space.	self visitNode: (node condition).	codeStream		space;		nextPut: $];		space;		nextPutAll: 'whileTrue: [ '.		self indentWhile: [		self indent.		pragmas do: [:p | self visitNode: p].		self visitNode: statements.	].	self indent.	codeStream		space;		nextPut: $];		nextPut: $.;		crlf.		localNames := oldLocalNames copy.! !!CompoToSmalltalk methodsFor: 'as yet unclassified' stamp: 'FerrandAnthony 2/7/2015 11:09'!brouillon: node	|cKind sComp dComp sPort |	(node parent isKindOf: (Smalltalk at: #CompoArchitectureNode))		ifTrue: [			target ifNil: [^ self].						(node kind isNil)				ifTrue: [ cKind := '#NULL']				ifFalse: [ cKind := '#', (node kind value asString) ].							sComp := (CompoFormatter new format: (node srcAddress)).			sComp := sComp copyFrom: ((node srcAddress left stop + 3) - (node srcAddress left start)) to: (sComp size).						dComp := (CompoFormatter new format: (node destAddress)).						sPort := node srcAddress left value asString.						"addToTargetNewConnectionDescriptionInstance_srcComp:srcPort:destComp:destPort:isDisconn:"			declStream 				nextPutAll: 'db addToTargetNewConnectionDescriptionInstance_srcComp:';				space;				nextPut: $' ;				nextPutAll: (sComp asString);				nextPut: $' ;				space;								nextPutAll: 'srcPort:';				space;				nextPut: $' ;				nextPutAll: (sPort asString);				nextPut: $' ;				space;								nextPutAll: 'destComp:';				space;				nextPut: $' ;				nextPutAll: (dComp asString);				nextPut: $' ;				space;								nextPutAll: 'destPort:';				space;				nextPut: $' ;				nextPutAll: 'default';				nextPut: $' ;				space;								nextPutAll: 'isDisconn:';				space;				nextPutAll: (false asString);				space;				nextPut: $.;				crlf.		]		ifFalse: [			codeStream nextPut: $(.			self visitNode: (node srcAddress).			codeStream nextPut: $).			self indent.			codeStream				tab;				nextPutAll:  'cs__connectTo__par01: ('.			self visitNode: (node destAddress).			codeStream				nextPut: $) ;				nextPut: $. 		].! !!CompoToSmalltalk methodsFor: 'as yet unclassified' stamp: 'FerrandAnthony 2/7/2015 21:43'!visitCompoConnectionRockNode: node	|cKind sComp dComp sPort |	(node parent isKindOf: (Smalltalk at: #CompoArchitectureNode))		ifTrue: [			target ifNil: [^ self].						(node kind isNil)				ifTrue: [ cKind := '#NULL']				ifFalse: [ cKind := '#', (node kind value asString) ].							sComp := (CompoFormatter new format: (node srcAddress)).			sComp := sComp copyFrom: ((node srcAddress left stop + 3) - (node srcAddress left start)) to: (sComp size).						dComp := (CompoFormatter new format: (node destAddress)).						sPort := node srcAddress left value asString.						"addToTargetNewConnectionDescriptionInstance_srcComp:srcPort:destComp:destPort:isDisconn:"			declStream				nextPutAll: 'db addToTargetNewConnectionDescriptionInstance_srcComp:';				space;				nextPut: $' ;				nextPutAll: (sComp asString);				nextPut: $' ;				space;								nextPutAll: 'srcPort:';				space;				nextPut: $' ;				nextPutAll: (sPort asString);				nextPut: $' ;				space;								nextPutAll: 'destComp:';				space;				nextPut: $' ;				nextPutAll: (dComp asString);				nextPut: $' ;				space;								nextPutAll: 'destPort:';				space;				nextPut: $' ;				nextPutAll: 'default';				nextPut: $' ;				space;								nextPutAll: 'isDisconn:';				space;				nextPutAll: (false asString);				space;				nextPut: $.;				crlf.		]		ifFalse: [			codeStream nextPut: $(.			self visitNode: (node srcAddress).			codeStream nextPut: $).			self indent.			codeStream				tab;				nextPutAll:  'cs__connectTo__par01: ('.			self visitNode: (node destAddress).			codeStream				nextPut: $) ;				nextPut: $. 		].! !!CompoToSmalltalk methodsFor: 'as yet unclassified' stamp: 'FerrandAnthony 2/11/2015 20:47'!visitCompoSmalltalkInjectionNode: node	codeStream nextPutAll: (node code).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CompoToSmalltalk class	instanceVariableNames: ''!!CompoToSmalltalk class methodsFor: 'converting' stamp: 'PetrSpacek 11/25/2013 02:43'!convert: aString	^ self convert: aString forWorkspace:  false.! !!CompoToSmalltalk class methodsFor: 'converting' stamp: 'Fred 7/18/2014 13:56'!convert: aString forWorkspace: aBool	|ast visitor|	ast := (Smalltalk at: #PPCompoParser) parse: aString.	visitor := self new.	visitor forWorkspace: aBool.	^ visitor convert: ast sourceCode: aString.! !