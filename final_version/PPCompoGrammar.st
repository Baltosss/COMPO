'From Pharo2.0 of 7 March 2013 [Latest update: #20619] on 12 February 2015 at 4:05:02 pm'!PPCompositeParser subclass: #PPCompoGrammar	instanceVariableNames: 'array arrayItem arrayLiteral arrayLiteralArray assignment assignmentToken binary binaryExpression binaryMessage binaryMethod binaryPragma binaryToken block blockArgument blockArguments blockArgumentsWith blockArgumentsWithout blockBody byteLiteral byteLiteralArray cascadeExpression cascadeMessage char charLiteral charToken expression falseLiteral falseToken identifier identifierToken keyword keywordExpression keywordMessage keywordMethod keywordPragma keywordToken literal message method methodDeclaration methodSequence multiword nilLiteral nilToken number numberLiteral numberToken parens period periodToken pragma pragmaMessage pragmas primary return sequence startExpression startMethod statements string stringLiteral stringToken symbol symbolLiteral symbolLiteralArray temporaries trueLiteral trueToken unary unaryExpression unaryMessage unaryMethod unaryPragma unaryToken variable dereferenceLiteral collectionPortLiteral portAddressLiteral compoIdent serviceSignsList serviceSign port connection disconnection connection_rock exProvisions exRequirements inProvisions inRequirements service architecture compoExpr descriptor interface semicolon semicolonToken comma commaToken constraint binaryMessageLimited binaryTokenLimited binaryExpressionLimited binaryLimited startDeclaration startConnection unarySubExpression startService forStatement whileStatement ifStatement smalltalkInjection'	classVariableNames: ''	poolDictionaries: ''	category: 'Compo-Parser-Core'!!PPCompoGrammar commentStamp: 'lr 11/29/2009 09:58' prior: 0!A parser for Smalltalk methods and expressions.!!PPCompoGrammar methodsFor: 'grammar' stamp: 'PetrSpacek 11/13/2013 14:15'!array	^ ${ asParser compoToken , (expression delimitedBy: semicolonToken ) optional , $} asParser compoToken! !!PPCompoGrammar methodsFor: 'grammar' stamp: 'lr 9/27/2009 12:42'!assignment	^ variable , assignmentToken! !!PPCompoGrammar methodsFor: 'grammar' stamp: 'lr 9/27/2009 12:42'!expression	^ assignment star , cascadeExpression! !!PPCompoGrammar methodsFor: 'grammar' stamp: 'PetrSpacek 11/18/2013 20:45'!forStatement	^ 'for' asParser compoToken , $( asParser compoToken , expression , semicolonToken , expression, semicolonToken , expression , $) asParser compoToken , ${ asParser compoToken , methodSequence, $} asParser compoToken.! !!PPCompoGrammar methodsFor: 'grammar' stamp: 'PetrSpacek 11/18/2013 16:58'!ifStatement	^ 'if' asParser compoToken , parens, ${ asParser compoToken , methodSequence, $} asParser compoToken, ('else' asParser compoToken , ${ asParser compoToken , methodSequence, $} asParser compoToken) optional.		! !!PPCompoGrammar methodsFor: 'grammar' stamp: 'PetrSpacek 11/8/2012 23:40'!literal	^ numberLiteral / stringLiteral / charLiteral / arrayLiteral / byteLiteral / symbolLiteral / nilLiteral / trueLiteral / falseLiteral / dereferenceLiteral / portAddressLiteral / collectionPortLiteral! !!PPCompoGrammar methodsFor: 'grammar' stamp: 'lr 9/27/2009 12:42'!message	^ keywordMessage / binaryMessage / unaryMessage! !!PPCompoGrammar methodsFor: 'grammar' stamp: 'lr 9/27/2009 12:42'!method	^ methodDeclaration , methodSequence! !!PPCompoGrammar methodsFor: 'grammar' stamp: 'lr 9/27/2009 12:42'!methodDeclaration	^ keywordMethod / unaryMethod / binaryMethod! !!PPCompoGrammar methodsFor: 'grammar' stamp: 'PetrSpacek 10/18/2012 15:02'!methodSequence	^ semicolonToken  star , pragmas , semicolonToken star , temporaries , semicolonToken star , pragmas , semicolonToken star , statements! !!PPCompoGrammar methodsFor: 'grammar' stamp: 'PetrSpacek 10/17/2012 15:26'!parens	^ $( asParser compoToken , expression , $) asParser compoToken! !!PPCompoGrammar methodsFor: 'grammar' stamp: 'FerrandAnthony 2/11/2015 20:35'!pragma	^ $< asParser compoToken , $!! asParser compoToken not, pragmaMessage , $> asParser compoToken! !!PPCompoGrammar methodsFor: 'grammar' stamp: 'lr 9/27/2009 12:42'!pragmas	^ pragma star! !!PPCompoGrammar methodsFor: 'grammar' stamp: 'lr 5/3/2010 21:39'!primary	^ literal / variable / block / parens / array! !!PPCompoGrammar methodsFor: 'grammar' stamp: 'PetrSpacek 11/9/2012 00:01'!return	"^ $^ asParser compoToken , expression"	^ 'return' asParser compoToken , expression! !!PPCompoGrammar methodsFor: 'grammar' stamp: 'PetrSpacek 10/18/2012 15:01'!sequence	^ temporaries , semicolonToken star , statements! !!PPCompoGrammar methodsFor: 'grammar' stamp: 'FerrandAnthony 1/31/2015 15:42'!statements	^ (return , semicolonToken star			==> [ :nodes | (Array with: nodes first) , (nodes last) ])	/ (forStatement , semicolonToken star			==> [ :nodes | (Array with: nodes first) , (nodes last) ])	/ (whileStatement , semicolonToken star			==> [ :nodes | (Array with: nodes first) , (nodes last) ])	/ (ifStatement , semicolonToken star			==> [ :nodes | (Array with: nodes first) , (nodes last) ])	/ ((connection / disconnection / connection_rock) wrapped , ((semicolonToken  plus , statements ==> [ :nodes | nodes first , nodes last ])								/ semicolonToken star)			==> [ :nodes | (Array with: nodes first) , (nodes last) ])	/	(expression wrapped , ((semicolonToken  plus , statements ==> [ :nodes | nodes first , nodes last ])								/ semicolonToken star)			==> [ :nodes | (Array with: nodes first) , (nodes last) ])	/	(semicolonToken star)! !!PPCompoGrammar methodsFor: 'grammar' stamp: 'PetrSpacek 10/17/2012 15:26'!temporaries	^ ($| asParser compoToken , variable star , $| asParser compoToken) optional ==> [ :nodes | nodes ifNil: [ #() ] ]! !!PPCompoGrammar methodsFor: 'grammar' stamp: 'lr 9/27/2009 12:42'!variable	^ identifierToken! !!PPCompoGrammar methodsFor: 'grammar' stamp: 'PetrSpacek 11/18/2013 16:59'!whileStatement	^ 'while' asParser compoToken , parens , ${ asParser compoToken , methodSequence, $} asParser compoToken.		! !!PPCompoGrammar methodsFor: 'grammar-literals' stamp: 'TestRunner 10/23/2009 17:39'!arrayItem	^ literal / symbolLiteralArray / arrayLiteralArray / byteLiteralArray! !!PPCompoGrammar methodsFor: 'grammar-literals' stamp: 'PetrSpacek 10/17/2012 15:26'!arrayLiteral	^ '#(' asParser compoToken , arrayItem star , $) asParser compoToken! !!PPCompoGrammar methodsFor: 'grammar-literals' stamp: 'PetrSpacek 10/17/2012 15:26'!arrayLiteralArray	^ $( asParser compoToken , arrayItem star , $) asParser compoToken! !!PPCompoGrammar methodsFor: 'grammar-literals' stamp: 'PetrSpacek 10/17/2012 15:26'!byteLiteral	^ '#[' asParser compoToken , numberLiteral star , $] asParser compoToken! !!PPCompoGrammar methodsFor: 'grammar-literals' stamp: 'PetrSpacek 10/17/2012 15:26'!byteLiteralArray	^ $[ asParser compoToken , numberLiteral star , $] asParser compoToken! !!PPCompoGrammar methodsFor: 'grammar-literals' stamp: 'lr 9/27/2009 12:42'!charLiteral	^ charToken! !!PPCompoGrammar methodsFor: 'grammar-literals' stamp: 'lr 9/27/2009 12:42'!falseLiteral	^ falseToken! !!PPCompoGrammar methodsFor: 'grammar-literals' stamp: 'lr 9/27/2009 12:42'!nilLiteral	^ nilToken! !!PPCompoGrammar methodsFor: 'grammar-literals' stamp: 'lr 9/27/2009 12:42'!numberLiteral	^ numberToken! !!PPCompoGrammar methodsFor: 'grammar-literals' stamp: 'lr 9/27/2009 12:42'!stringLiteral	^ stringToken! !!PPCompoGrammar methodsFor: 'grammar-literals' stamp: 'PetrSpacek 10/17/2012 15:26'!symbolLiteral	"This is totally fucked up: The Pharo compiler allows multiple #, arbitrary spaces between the # and the symbol, as well as comments inbetween. And yes, it is used."	^ $# asParser compoToken plus , symbol compoToken ==> [ :tokens | tokens first copyWith: tokens last ]! !!PPCompoGrammar methodsFor: 'grammar-literals' stamp: 'PetrSpacek 10/17/2012 15:26'!symbolLiteralArray	^ symbol compoToken! !!PPCompoGrammar methodsFor: 'grammar-literals' stamp: 'lr 9/27/2009 12:42'!trueLiteral	^ trueToken! !!PPCompoGrammar methodsFor: 'token' stamp: 'PetrSpacek 10/17/2012 15:26'!assignmentToken	^ self class allowUnderscoreAssignment		ifTrue: [ (':=' asParser / '_' asParser) compoToken ]		ifFalse: [ ':=' asParser compoToken ]! !!PPCompoGrammar methodsFor: 'token' stamp: 'PetrSpacek 10/17/2012 15:26'!binaryToken	^ binary compoToken! !!PPCompoGrammar methodsFor: 'token' stamp: 'PetrSpacek 10/19/2012 12:21'!binaryTokenLimited	^ binaryLimited compoToken! !!PPCompoGrammar methodsFor: 'token' stamp: 'PetrSpacek 10/17/2012 15:26'!charToken	^ char compoToken! !!PPCompoGrammar methodsFor: 'token' stamp: 'PetrSpacek 10/18/2012 14:47'!commaToken	^ comma compoToken! !!PPCompoGrammar methodsFor: 'token' stamp: 'PetrSpacek 10/17/2012 15:26'!falseToken	^ ('false' asParser , #word asParser not) compoToken! !!PPCompoGrammar methodsFor: 'token' stamp: 'PetrSpacek 10/17/2012 15:26'!identifierToken	^ identifier compoToken! !!PPCompoGrammar methodsFor: 'token' stamp: 'PetrSpacek 10/17/2012 15:26'!keywordToken	^ keyword compoToken! !!PPCompoGrammar methodsFor: 'token' stamp: 'PetrSpacek 10/17/2012 15:26'!nilToken	^ ('nil' asParser , #word asParser not) compoToken! !!PPCompoGrammar methodsFor: 'token' stamp: 'PetrSpacek 10/17/2012 15:26'!numberToken	^ number compoToken! !!PPCompoGrammar methodsFor: 'token' stamp: 'PetrSpacek 10/17/2012 15:26'!periodToken	^ period compoToken! !!PPCompoGrammar methodsFor: 'token' stamp: 'PetrSpacek 10/18/2012 14:44'!semicolonToken	^ semicolon compoToken! !!PPCompoGrammar methodsFor: 'token' stamp: 'PetrSpacek 10/17/2012 15:26'!stringToken	^ string compoToken! !!PPCompoGrammar methodsFor: 'token' stamp: 'PetrSpacek 10/17/2012 15:26'!trueToken	^ ('true' asParser , #word asParser not) compoToken! !!PPCompoGrammar methodsFor: 'token' stamp: 'PetrSpacek 10/17/2012 15:26'!unaryToken	^ unary compoToken! !!PPCompoGrammar methodsFor: 'primitives' stamp: 'lr 8/11/2011 23:29'!binary	^ (PPPredicateObjectParser anyOf: '!!%&*+,-/<=>?@\|~') plus! !!PPCompoGrammar methodsFor: 'primitives' stamp: 'PetrSpacek 10/19/2012 12:22'!binaryLimited	^ (PPPredicateObjectParser anyOf: '!!%&*+-/<=>?@\|~') plus! !!PPCompoGrammar methodsFor: 'primitives' stamp: 'lr 9/27/2009 12:42'!char	^ $$ asParser , #any asParser! !!PPCompoGrammar methodsFor: 'primitives' stamp: 'PetrSpacek 10/18/2012 14:47'!comma	^ $, asParser! !!PPCompoGrammar methodsFor: 'primitives' stamp: 'lr 7/11/2011 11:32'!identifier	^ self class allowUnderscoreAssignment		ifTrue: [ #letter asParser , #word asParser star ]		ifFalse: [			(PPPredicateObjectParser				on: [ :each | each isLetter or: [ each = $_ ] ]				message: 'letter expected') ,			(PPPredicateObjectParser				on: [ :each | each isAlphaNumeric or: [ each = $_ ] ]				message: 'letter or digit expected') star ]! !!PPCompoGrammar methodsFor: 'primitives' stamp: 'lr 9/27/2009 12:42'!keyword	^ identifier , $: asParser! !!PPCompoGrammar methodsFor: 'primitives' stamp: 'lr 9/27/2009 12:42'!multiword	^ keyword plus! !!PPCompoGrammar methodsFor: 'primitives' stamp: 'lr 8/13/2011 20:33'!number	^ ($- asParser optional , #digit asParser) and , [ :stream | 		[ Number readFrom: stream ] 			on: Error			do: [ :err | PPFailure message: err messageText at: stream position ] ] 				asParser! !!PPCompoGrammar methodsFor: 'primitives' stamp: 'lr 8/13/2011 20:51'!period	^ $. asParser! !!PPCompoGrammar methodsFor: 'primitives' stamp: 'PetrSpacek 10/18/2012 14:44'!semicolon	^ $; asParser! !!PPCompoGrammar methodsFor: 'primitives' stamp: 'lr 1/8/2010 15:38'!string	^ $' asParser , ('''''' asParser / $' asParser negate) star , $' asParser! !!PPCompoGrammar methodsFor: 'primitives' stamp: 'lr 9/27/2009 12:42'!symbol	^ unary / binary / multiword / string! !!PPCompoGrammar methodsFor: 'primitives' stamp: 'lr 9/27/2009 12:42'!unary	^ identifier , $: asParser not! !!PPCompoGrammar methodsFor: 'grammar-literals-compo' stamp: 'PetrSpacek 10/18/2012 13:42'!collectionPortLiteral	^ identifier compoToken, $[ asParser compoToken , expression , $] asParser compoToken.! !!PPCompoGrammar methodsFor: 'grammar-literals-compo' stamp: 'FerrandAnthony 1/31/2015 15:45'!dereferenceLiteral	^ $& asParser compoToken plus , identifier compoToken! !!PPCompoGrammar methodsFor: 'grammar-literals-compo' stamp: 'PetrSpacek 11/8/2012 13:26'!portAddressLiteral	^ identifier compoToken, $@ asParser compoToken , ( collectionPortLiteral / ($( asParser compoToken , cascadeExpression , $) asParser compoToken) / dereferenceLiteral / identifierToken ).! !!PPCompoGrammar methodsFor: 'grammar-messages' stamp: 'lr 9/27/2009 12:42'!binaryExpression	^ unaryExpression , binaryMessage star! !!PPCompoGrammar methodsFor: 'grammar-messages' stamp: 'PetrSpacek 10/19/2012 12:20'!binaryExpressionLimited	^ unaryExpression , binaryMessageLimited star! !!PPCompoGrammar methodsFor: 'grammar-messages' stamp: 'lr 12/6/2009 10:38'!binaryMessage	^ (binaryToken , unaryExpression) ==> [ :nodes | 		Array 			with: (Array with: nodes first)			with: (Array with: nodes second) ]! !!PPCompoGrammar methodsFor: 'grammar-messages' stamp: 'PetrSpacek 10/19/2012 12:20'!binaryMessageLimited	^ (binaryTokenLimited , unaryExpression) ==> [ :nodes | 		Array 			with: (Array with: nodes first)			with: (Array with: nodes second) ]! !!PPCompoGrammar methodsFor: 'grammar-messages' stamp: 'FerrandAnthony 2/11/2015 20:40'!cascadeExpression	"^ keywordExpression , cascadeMessage star"	^ keywordExpression / pragma / smalltalkInjection" ==> [:nodes | nodes first]."! !!PPCompoGrammar methodsFor: 'grammar-messages' stamp: 'PetrSpacek 10/18/2012 15:05'!cascadeMessage	^ $, asParser compoToken , message! !!PPCompoGrammar methodsFor: 'grammar-messages' stamp: 'PetrSpacek 10/26/2012 15:56'!keywordExpression	"^ binaryExpression , keywordMessage optional"	^ binaryExpression.! !!PPCompoGrammar methodsFor: 'grammar-messages' stamp: 'lr 12/6/2009 10:38'!keywordMessage	^ (keywordToken , binaryExpression) plus ==> [ :nodes | 		Array 			with: (nodes collect: [ :each | each first ])			with: (nodes collect: [ :each | each second ]) ]! !!PPCompoGrammar methodsFor: 'grammar-messages' stamp: 'PetrSpacek 11/13/2012 22:11'!unaryExpression	^ unarySubExpression , unaryMessage star! !!PPCompoGrammar methodsFor: 'grammar-messages' stamp: 'PetrSpacek 10/26/2012 16:12'!unaryMessage	"^ unaryToken ==> [ :node | 		Array 			with: (Array with: node)			with: Array new ]"	^ (periodToken, identifierToken , $( asParser compoToken , ( binaryExpressionLimited delimitedBy: comma) withoutSeparators optional , $) asParser compoToken) ==> [ :nodes | Array with: (nodes second) with: (nodes at: 4) ].			! !!PPCompoGrammar methodsFor: 'grammar-messages' stamp: 'PetrSpacek 10/26/2012 16:12'!unarySubExpression	^ primary , unaryMessage optional! !!PPCompoGrammar methodsFor: 'grammar-methods' stamp: 'lr 12/6/2009 10:38'!binaryMethod	^ (binaryToken , variable) ==> [ :nodes | 		Array 			with: (Array with: nodes first)			with: (Array with: nodes second) ]! !!PPCompoGrammar methodsFor: 'grammar-methods' stamp: 'lr 12/6/2009 10:38'!keywordMethod	^ (keywordToken , variable) plus ==> [ :nodes | 		Array 			with: (nodes collect: [ :each | each first ])			with: (nodes collect: [ :each | each second ]) ]! !!PPCompoGrammar methodsFor: 'grammar-methods' stamp: 'lr 12/6/2009 10:39'!unaryMethod	^ identifierToken ==> [ :node | 		Array 			with: (Array with: node)			with: Array new ]! !!PPCompoGrammar methodsFor: 'grammar-pragmas' stamp: 'TestRunner 10/23/2009 17:34'!binaryPragma	^ (binaryToken , arrayItem) ==> [ :nodes | 		Array 			with: (Array with: nodes first)			with: (Array with: nodes second) ]! !!PPCompoGrammar methodsFor: 'grammar-pragmas' stamp: 'TestRunner 10/23/2009 17:35'!keywordPragma	^ (keywordToken , arrayItem) plus ==> [ :nodes | 		Array 			with: (nodes collect: [ :each | each first ])			with: (nodes collect: [ :each | each second ]) ]! !!PPCompoGrammar methodsFor: 'grammar-pragmas' stamp: 'lr 9/27/2009 12:42'!pragmaMessage	^ keywordPragma / unaryPragma / binaryPragma! !!PPCompoGrammar methodsFor: 'grammar-pragmas' stamp: 'TestRunner 10/23/2009 16:35'!unaryPragma	^ identifierToken ==> [ :node | 		Array 			with: (Array with: node)			with: (Array new) ]! !!PPCompoGrammar methodsFor: 'grammar-compo' stamp: 'FerrandAnthony 2/1/2015 13:05'!architecture	^ 'architecture' asParser compoToken , ${ asParser compoToken , ((connection / disconnection / connection_rock) delimitedBy: semicolonToken) withoutSeparators optional , $} asParser compoToken! !!PPCompoGrammar methodsFor: 'grammar-compo' stamp: 'PetrSpacek 11/7/2012 15:09'!compoExpr	^ exProvisions / exRequirements / inProvisions / inRequirements / constraint / service / architecture! !!PPCompoGrammar methodsFor: 'grammar-compo' stamp: 'PetrSpacek 10/18/2012 15:13'!compoIdent	^ identifierToken! !!PPCompoGrammar methodsFor: 'grammar-compo' stamp: 'FerrandAnthony 2/12/2015 15:27'!connection	^ 'connect' asParser compoToken , portAddressLiteral , 'to' asParser compoToken , (portAddressLiteral / variable) , ('kind-of' asParser compoToken , compoIdent  ) optional! !!PPCompoGrammar methodsFor: 'grammar-compo' stamp: 'PetrSpacek 10/18/2012 14:27'!constraint	^ 'constraint' asParser compoToken , serviceSign , ${ asParser compoToken , methodSequence, $} asParser compoToken! !!PPCompoGrammar methodsFor: 'grammar-compo' stamp: 'PetrSpacek 11/11/2013 21:18'!descriptor	^ compoIdent , compoIdent , ('extends' asParser compoToken , compoIdent) optional , ${ asParser compoToken , compoExpr star, $} asParser compoToken! !!PPCompoGrammar methodsFor: 'grammar-compo' stamp: 'FerrandAnthony 2/1/2015 13:09'!disconnection	^ 'disconnect' asParser compoToken , portAddressLiteral , 'from' asParser compoToken , portAddressLiteral! !!PPCompoGrammar methodsFor: 'grammar-compo' stamp: 'PetrSpacek 11/7/2012 16:31'!exProvisions	^ 'externally' asParser compoToken optional , 'provides' asParser compoToken , ${ asParser  compoToken, (port delimitedBy: semicolonToken) withoutSeparators optional , $} asParser compoToken! !!PPCompoGrammar methodsFor: 'grammar-compo' stamp: 'PetrSpacek 11/7/2012 16:31'!exRequirements	^ 'externally' asParser compoToken optional , 'requires' asParser compoToken ,  ${ asParser  compoToken, (port delimitedBy: semicolonToken) withoutSeparators optional , $} asParser compoToken! !!PPCompoGrammar methodsFor: 'grammar-compo' stamp: 'PetrSpacek 11/7/2012 16:13'!inProvisions	^ 'internally' asParser compoToken optional , 'provides' asParser compoToken , ${ asParser  compoToken, (port delimitedBy: semicolonToken) withoutSeparators optional , $} asParser compoToken! !!PPCompoGrammar methodsFor: 'grammar-compo' stamp: 'PetrSpacek 11/7/2012 16:31'!inRequirements	^ 'internally' asParser compoToken optional , 'requires' asParser compoToken , ${ asParser  compoToken, ((port , ('inject-with' asParser compoToken , compoIdent) optional) delimitedBy: semicolonToken ) withoutSeparators optional , $} asParser compoToken! !!PPCompoGrammar methodsFor: 'grammar-compo' stamp: 'PetrSpacek 11/7/2012 15:06'!interface	^ 'interface' asParser compoToken , compoIdent , ('extends' asParser compoToken , compoIdent) optional , serviceSignsList ! !!PPCompoGrammar methodsFor: 'grammar-compo' stamp: 'PetrSpacek 11/22/2013 13:58'!port	^ compoIdent, '[]' asParser compoToken optional , $: asParser compoToken , (compoIdent / $* asParser compoToken / serviceSignsList) , ('ofKind' asParser compoToken , compoIdent) optional! !!PPCompoGrammar methodsFor: 'grammar-compo' stamp: 'FerrandAnthony 2/11/2015 11:05'!service	^ ('service' asParser compoToken / 'operation' asParser compoToken) , serviceSign , ${ asParser compoToken , methodSequence, $} asParser compoToken! !!PPCompoGrammar methodsFor: 'grammar-compo' stamp: 'PetrSpacek 11/7/2012 16:30'!serviceSign	^ compoIdent , $( asParser compoToken , (compoIdent delimitedBy: commaToken) withoutSeparators optional , $) asParser compoToken! !!PPCompoGrammar methodsFor: 'grammar-compo' stamp: 'PetrSpacek 11/7/2012 16:30'!serviceSignsList	^ ${ asParser compoToken , (serviceSign delimitedBy: semicolonToken) withoutSeparators optional , $} asParser compoToken ! !!PPCompoGrammar methodsFor: 'grammar-blocks' stamp: 'PetrSpacek 10/17/2012 15:26'!block	^ $[ asParser compoToken , blockBody , $] asParser compoToken! !!PPCompoGrammar methodsFor: 'grammar-blocks' stamp: 'PetrSpacek 10/17/2012 15:26'!blockArgument	^ $: asParser compoToken , variable! !!PPCompoGrammar methodsFor: 'grammar-blocks' stamp: 'lr 2/4/2010 13:21'!blockArguments	^ blockArgumentsWith / blockArgumentsWithout! !!PPCompoGrammar methodsFor: 'grammar-blocks' stamp: 'PetrSpacek 10/17/2012 15:26'!blockArgumentsWith	^ blockArgument plus , ($| asParser compoToken / ($] asParser compoToken and ==> [ :node | nil ]))! !!PPCompoGrammar methodsFor: 'grammar-blocks' stamp: 'lr 2/4/2010 11:44'!blockArgumentsWithout	^ nil asParser ==> [ :nodes | Array with: #() with: nil ]! !!PPCompoGrammar methodsFor: 'grammar-blocks' stamp: 'lr 2/4/2010 11:39'!blockBody	^ blockArguments , sequence! !!PPCompoGrammar methodsFor: 'parsing' stamp: 'PetrSpacek 10/26/2012 15:41'!parseConnection: aString 	^ self parseConnection: aString onError: [ :msg :pos | self error: msg ].! !!PPCompoGrammar methodsFor: 'parsing' stamp: 'PetrSpacek 10/26/2012 15:41'!parseConnection: aString onError: aBlock	^ startConnection parse: aString onError: aBlock.! !!PPCompoGrammar methodsFor: 'parsing' stamp: 'PetrSpacek 10/19/2012 16:23'!parseDeclaration: aString 	^ self parseDeclaration: aString onError: [ :msg :pos | self error: msg ]! !!PPCompoGrammar methodsFor: 'parsing' stamp: 'PetrSpacek 10/19/2012 23:12'!parseDeclaration: aString onError: aBlock	^ startDeclaration parse: aString onError: aBlock! !!PPCompoGrammar methodsFor: 'parsing' stamp: 'lr 2/19/2010 08:00'!parseExpression: aString 	^ self parseExpression: aString onError: [ :msg :pos | self error: msg ]! !!PPCompoGrammar methodsFor: 'parsing' stamp: 'lr 2/19/2010 08:04'!parseExpression: aString onError: aBlock	^ startExpression parse: aString onError: aBlock! !!PPCompoGrammar methodsFor: 'parsing' stamp: 'PetrSpacek 10/18/2012 15:18'!parseMethod: aString 	"^ self parseMethod: aString onError: [ :msg :pos | self error: msg ]"! !!PPCompoGrammar methodsFor: 'parsing' stamp: 'PetrSpacek 10/18/2012 15:18'!parseMethod: aString onError: aBlock	"^ startMethod parse: aString onError: aBlock"! !!PPCompoGrammar methodsFor: 'parsing' stamp: 'PetrSpacek 11/11/2012 18:25'!parseService: aString 	^ self parseService: aString onError: [ :msg :pos | self error: msg ]! !!PPCompoGrammar methodsFor: 'parsing' stamp: 'PetrSpacek 11/11/2012 18:25'!parseService: aString onError: aBlock	^ startService parse: aString onError: aBlock! !!PPCompoGrammar methodsFor: 'accessing' stamp: 'PetrSpacek 10/18/2012 14:38'!start	"Default start production."	^ (descriptor / interface) star end! !!PPCompoGrammar methodsFor: 'accessing' stamp: 'FerrandAnthony 2/1/2015 13:05'!startConnection 	^ (connection / disconnection / connection_rock) end.! !!PPCompoGrammar methodsFor: 'accessing' stamp: 'PetrSpacek 11/7/2012 15:09'!startDeclaration	^ (descriptor / interface) end! !!PPCompoGrammar methodsFor: 'accessing' stamp: 'lr 2/19/2010 08:03'!startExpression	"Start production for the expression."	^ sequence end! !!PPCompoGrammar methodsFor: 'accessing' stamp: 'PetrSpacek 10/18/2012 14:39'!startMethod	"Start production for the method."	"^ method end"! !!PPCompoGrammar methodsFor: 'accessing' stamp: 'PetrSpacek 11/11/2012 18:26'!startService	"Start production for the method."	^ service end.! !!PPCompoGrammar methodsFor: 'as yet unclassified' stamp: 'FerrandAnthony 2/12/2015 15:27'!connection_rock	^ 'rockonnect' asParser compoToken , portAddressLiteral , 'to' asParser compoToken , literal! !!PPCompoGrammar methodsFor: 'as yet unclassified' stamp: 'FerrandAnthony 2/11/2015 22:25'!smalltalkInjection	^ '<!!' asParser, ((PPPredicateObjectParser anyExceptAnyOf: '>') / ('>!!' asParser)) star, ( '>' asParser)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PPCompoGrammar class	instanceVariableNames: ''!!PPCompoGrammar class methodsFor: 'testing' stamp: 'lr 5/1/2012 09:33'!allowUnderscoreAssignment	^ (Scanner respondsTo: #allowUnderscoreAsAssignment) and: [ Scanner allowUnderscoreAsAssignment ]! !!PPCompoGrammar class methodsFor: 'accessing' stamp: 'PetrSpacek 11/15/2012 01:05'!parse: aString	|result wasError eMsg ePos copyStart copyEnd|	wasError := false.	ePos :=0.	result := self new parseDeclaration: aString onError: [ :msg :pos | eMsg := msg. ePos := pos. wasError := true ].	(wasError) ifTrue: [		wasError := false.		result := self new parseService: aString onError: [ :msg :pos | eMsg := msg. ePos := pos. wasError := true ]	].	(wasError) ifTrue: [		wasError := false.		result := self new parseConnection: aString onError: [ :msg :pos | eMsg := msg. ePos := pos. wasError := true ]	].	(wasError) ifTrue: [		wasError := false.		result := self new parseExpression: aString onError: [ :msg :pos | eMsg := msg. ePos := pos. wasError := true ]	].	(ePos > 4) ifTrue: [copyStart := ePos - 4] ifFalse: [copyStart := 1].	(ePos + 4 > (aString size)) ifTrue: [copyEnd := (aString size)] ifFalse: [copyEnd := ePos + 4].	(wasError) ifTrue: [ self error: 'Compo parse error ''', eMsg ,''' on position ',ePos asString,' near ''' , (aString copyFrom: copyStart to: copyEnd)  , '''' ].		^ result.! !!PPCompoGrammar class methodsFor: 'accessing' stamp: 'PetrSpacek 10/26/2012 15:47'!parseConenction: aString onError: aBlock	^ self new parseConnection: aString onError: aBlock! !!PPCompoGrammar class methodsFor: 'accessing' stamp: 'PetrSpacek 10/26/2012 15:48'!parseConnection: aString	^ self new parseConnection: aString! !!PPCompoGrammar class methodsFor: 'accessing' stamp: 'PetrSpacek 10/19/2012 23:09'!parseDeclaration: aString	^ self new parseDeclaration: aString! !!PPCompoGrammar class methodsFor: 'accessing' stamp: 'PetrSpacek 10/19/2012 23:10'!parseDeclaration: aString onError: aBlock	^ self new parseDeclaration: aString onError: aBlock! !!PPCompoGrammar class methodsFor: 'accessing' stamp: 'lr 2/19/2010 08:08'!parseExpression: aString	^ self new parseExpression: aString! !!PPCompoGrammar class methodsFor: 'accessing' stamp: 'lr 2/19/2010 08:09'!parseExpression: aString onError: aBlock	^ self new parseExpression: aString onError: aBlock! !!PPCompoGrammar class methodsFor: 'accessing' stamp: 'lr 2/19/2010 08:09'!parseMethod: aString	^ self new parseMethod: aString! !!PPCompoGrammar class methodsFor: 'accessing' stamp: 'lr 2/19/2010 08:09'!parseMethod: aString onError: aBlock	^ self new parseMethod: aString onError: aBlock! !!PPCompoGrammar class methodsFor: 'accessing' stamp: 'PetrSpacek 11/11/2012 18:28'!parseService: aString	^ self new parseService: aString! !!PPCompoGrammar class methodsFor: 'accessing' stamp: 'PetrSpacek 11/11/2012 18:28'!parseService: aString onError: aBlock	^ self new parseService: aString onError: aBlock! !!PPCompoGrammar class methodsFor: 'as yet unclassified' stamp: 'FerrandAnthony 2/7/2015 21:33'!matchesLiteral: aString	^ self new literal matches: aString! !